
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001974  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001e  00802000  00001974  00001a08  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000017e5  0080201e  0080201e  00001a26  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001a26  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000540  00000000  00000000  00001a58  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000080a5  00000000  00000000  00001f98  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000019f6  00000000  00000000  0000a03d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000356b  00000000  00000000  0000ba33  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000e90  00000000  00000000  0000efa0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002f48  00000000  00000000  0000fe30  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00004937  00000000  00000000  00012d78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000004f8  00000000  00000000  000176b0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	fd c0       	rjmp	.+506    	; 0x1fc <__ctors_end>
       2:	00 00       	nop
       4:	21 c1       	rjmp	.+578    	; 0x248 <__bad_interrupt>
       6:	00 00       	nop
       8:	1f c1       	rjmp	.+574    	; 0x248 <__bad_interrupt>
       a:	00 00       	nop
       c:	1d c1       	rjmp	.+570    	; 0x248 <__bad_interrupt>
       e:	00 00       	nop
      10:	1b c1       	rjmp	.+566    	; 0x248 <__bad_interrupt>
      12:	00 00       	nop
      14:	19 c1       	rjmp	.+562    	; 0x248 <__bad_interrupt>
      16:	00 00       	nop
      18:	17 c1       	rjmp	.+558    	; 0x248 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	15 c1       	rjmp	.+554    	; 0x248 <__bad_interrupt>
      1e:	00 00       	nop
      20:	13 c1       	rjmp	.+550    	; 0x248 <__bad_interrupt>
      22:	00 00       	nop
      24:	11 c1       	rjmp	.+546    	; 0x248 <__bad_interrupt>
      26:	00 00       	nop
      28:	0f c1       	rjmp	.+542    	; 0x248 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	0d c1       	rjmp	.+538    	; 0x248 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0b c1       	rjmp	.+534    	; 0x248 <__bad_interrupt>
      32:	00 00       	nop
      34:	09 c1       	rjmp	.+530    	; 0x248 <__bad_interrupt>
      36:	00 00       	nop
      38:	35 c2       	rjmp	.+1130   	; 0x4a4 <__vector_14>
      3a:	00 00       	nop
      3c:	05 c1       	rjmp	.+522    	; 0x248 <__bad_interrupt>
      3e:	00 00       	nop
      40:	03 c1       	rjmp	.+518    	; 0x248 <__bad_interrupt>
      42:	00 00       	nop
      44:	01 c1       	rjmp	.+514    	; 0x248 <__bad_interrupt>
      46:	00 00       	nop
      48:	ff c0       	rjmp	.+510    	; 0x248 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	fd c0       	rjmp	.+506    	; 0x248 <__bad_interrupt>
      4e:	00 00       	nop
      50:	fb c0       	rjmp	.+502    	; 0x248 <__bad_interrupt>
      52:	00 00       	nop
      54:	f9 c0       	rjmp	.+498    	; 0x248 <__bad_interrupt>
      56:	00 00       	nop
      58:	f7 c0       	rjmp	.+494    	; 0x248 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	f5 c0       	rjmp	.+490    	; 0x248 <__bad_interrupt>
      5e:	00 00       	nop
      60:	f3 c0       	rjmp	.+486    	; 0x248 <__bad_interrupt>
      62:	00 00       	nop
      64:	f1 c0       	rjmp	.+482    	; 0x248 <__bad_interrupt>
      66:	00 00       	nop
      68:	ef c0       	rjmp	.+478    	; 0x248 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	ed c0       	rjmp	.+474    	; 0x248 <__bad_interrupt>
      6e:	00 00       	nop
      70:	eb c0       	rjmp	.+470    	; 0x248 <__bad_interrupt>
      72:	00 00       	nop
      74:	e9 c0       	rjmp	.+466    	; 0x248 <__bad_interrupt>
      76:	00 00       	nop
      78:	e7 c0       	rjmp	.+462    	; 0x248 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	e5 c0       	rjmp	.+458    	; 0x248 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e3 c0       	rjmp	.+454    	; 0x248 <__bad_interrupt>
      82:	00 00       	nop
      84:	e1 c0       	rjmp	.+450    	; 0x248 <__bad_interrupt>
      86:	00 00       	nop
      88:	df c0       	rjmp	.+446    	; 0x248 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	dd c0       	rjmp	.+442    	; 0x248 <__bad_interrupt>
      8e:	00 00       	nop
      90:	db c0       	rjmp	.+438    	; 0x248 <__bad_interrupt>
      92:	00 00       	nop
      94:	d9 c0       	rjmp	.+434    	; 0x248 <__bad_interrupt>
      96:	00 00       	nop
      98:	d7 c0       	rjmp	.+430    	; 0x248 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	d5 c0       	rjmp	.+426    	; 0x248 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	d3 c0       	rjmp	.+422    	; 0x248 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	d1 c0       	rjmp	.+418    	; 0x248 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	cf c0       	rjmp	.+414    	; 0x248 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	cd c0       	rjmp	.+410    	; 0x248 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	cb c0       	rjmp	.+406    	; 0x248 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	c9 c0       	rjmp	.+402    	; 0x248 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	c7 c0       	rjmp	.+398    	; 0x248 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	c5 c0       	rjmp	.+394    	; 0x248 <__bad_interrupt>
      be:	00 00       	nop
      c0:	c3 c0       	rjmp	.+390    	; 0x248 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	c1 c0       	rjmp	.+386    	; 0x248 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	bf c0       	rjmp	.+382    	; 0x248 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	bd c0       	rjmp	.+378    	; 0x248 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	bb c0       	rjmp	.+374    	; 0x248 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	b9 c0       	rjmp	.+370    	; 0x248 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	b7 c0       	rjmp	.+366    	; 0x248 <__bad_interrupt>
      da:	00 00       	nop
      dc:	b5 c0       	rjmp	.+362    	; 0x248 <__bad_interrupt>
      de:	00 00       	nop
      e0:	b3 c0       	rjmp	.+358    	; 0x248 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	b1 c0       	rjmp	.+354    	; 0x248 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	af c0       	rjmp	.+350    	; 0x248 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	ad c0       	rjmp	.+346    	; 0x248 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	ab c0       	rjmp	.+342    	; 0x248 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	a9 c0       	rjmp	.+338    	; 0x248 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	a7 c0       	rjmp	.+334    	; 0x248 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	a5 c0       	rjmp	.+330    	; 0x248 <__bad_interrupt>
      fe:	00 00       	nop
     100:	a3 c0       	rjmp	.+326    	; 0x248 <__bad_interrupt>
     102:	00 00       	nop
     104:	a1 c0       	rjmp	.+322    	; 0x248 <__bad_interrupt>
     106:	00 00       	nop
     108:	9f c0       	rjmp	.+318    	; 0x248 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	9d c0       	rjmp	.+314    	; 0x248 <__bad_interrupt>
     10e:	00 00       	nop
     110:	9b c0       	rjmp	.+310    	; 0x248 <__bad_interrupt>
     112:	00 00       	nop
     114:	99 c0       	rjmp	.+306    	; 0x248 <__bad_interrupt>
     116:	00 00       	nop
     118:	97 c0       	rjmp	.+302    	; 0x248 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	95 c0       	rjmp	.+298    	; 0x248 <__bad_interrupt>
     11e:	00 00       	nop
     120:	93 c0       	rjmp	.+294    	; 0x248 <__bad_interrupt>
     122:	00 00       	nop
     124:	91 c0       	rjmp	.+290    	; 0x248 <__bad_interrupt>
     126:	00 00       	nop
     128:	8f c0       	rjmp	.+286    	; 0x248 <__bad_interrupt>
     12a:	00 00       	nop
     12c:	8d c0       	rjmp	.+282    	; 0x248 <__bad_interrupt>
     12e:	00 00       	nop
     130:	8b c0       	rjmp	.+278    	; 0x248 <__bad_interrupt>
     132:	00 00       	nop
     134:	89 c0       	rjmp	.+274    	; 0x248 <__bad_interrupt>
     136:	00 00       	nop
     138:	87 c0       	rjmp	.+270    	; 0x248 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	85 c0       	rjmp	.+266    	; 0x248 <__bad_interrupt>
     13e:	00 00       	nop
     140:	83 c0       	rjmp	.+262    	; 0x248 <__bad_interrupt>
     142:	00 00       	nop
     144:	81 c0       	rjmp	.+258    	; 0x248 <__bad_interrupt>
     146:	00 00       	nop
     148:	7f c0       	rjmp	.+254    	; 0x248 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	7d c0       	rjmp	.+250    	; 0x248 <__bad_interrupt>
     14e:	00 00       	nop
     150:	7b c0       	rjmp	.+246    	; 0x248 <__bad_interrupt>
     152:	00 00       	nop
     154:	79 c0       	rjmp	.+242    	; 0x248 <__bad_interrupt>
     156:	00 00       	nop
     158:	77 c0       	rjmp	.+238    	; 0x248 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	75 c0       	rjmp	.+234    	; 0x248 <__bad_interrupt>
     15e:	00 00       	nop
     160:	73 c0       	rjmp	.+230    	; 0x248 <__bad_interrupt>
     162:	00 00       	nop
     164:	71 c0       	rjmp	.+226    	; 0x248 <__bad_interrupt>
     166:	00 00       	nop
     168:	6f c0       	rjmp	.+222    	; 0x248 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	6d c0       	rjmp	.+218    	; 0x248 <__bad_interrupt>
     16e:	00 00       	nop
     170:	6b c0       	rjmp	.+214    	; 0x248 <__bad_interrupt>
     172:	00 00       	nop
     174:	69 c0       	rjmp	.+210    	; 0x248 <__bad_interrupt>
     176:	00 00       	nop
     178:	67 c0       	rjmp	.+206    	; 0x248 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	65 c0       	rjmp	.+202    	; 0x248 <__bad_interrupt>
     17e:	00 00       	nop
     180:	63 c0       	rjmp	.+198    	; 0x248 <__bad_interrupt>
     182:	00 00       	nop
     184:	61 c0       	rjmp	.+194    	; 0x248 <__bad_interrupt>
     186:	00 00       	nop
     188:	5f c0       	rjmp	.+190    	; 0x248 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	5d c0       	rjmp	.+186    	; 0x248 <__bad_interrupt>
     18e:	00 00       	nop
     190:	5b c0       	rjmp	.+182    	; 0x248 <__bad_interrupt>
     192:	00 00       	nop
     194:	59 c0       	rjmp	.+178    	; 0x248 <__bad_interrupt>
     196:	00 00       	nop
     198:	57 c0       	rjmp	.+174    	; 0x248 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	55 c0       	rjmp	.+170    	; 0x248 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	53 c0       	rjmp	.+166    	; 0x248 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	51 c0       	rjmp	.+162    	; 0x248 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	4f c0       	rjmp	.+158    	; 0x248 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	4d c0       	rjmp	.+154    	; 0x248 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	4b c0       	rjmp	.+150    	; 0x248 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	49 c0       	rjmp	.+146    	; 0x248 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	47 c0       	rjmp	.+142    	; 0x248 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	45 c0       	rjmp	.+138    	; 0x248 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	43 c0       	rjmp	.+134    	; 0x248 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	41 c0       	rjmp	.+130    	; 0x248 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	3f c0       	rjmp	.+126    	; 0x248 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	3d c0       	rjmp	.+122    	; 0x248 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	3b c0       	rjmp	.+118    	; 0x248 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	39 c0       	rjmp	.+114    	; 0x248 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	37 c0       	rjmp	.+110    	; 0x248 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	35 c0       	rjmp	.+106    	; 0x248 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	33 c0       	rjmp	.+102    	; 0x248 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	31 c0       	rjmp	.+98     	; 0x248 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	2f c0       	rjmp	.+94     	; 0x248 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	2d c0       	rjmp	.+90     	; 0x248 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	2b c0       	rjmp	.+86     	; 0x248 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	29 c0       	rjmp	.+82     	; 0x248 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	27 c0       	rjmp	.+78     	; 0x248 <__bad_interrupt>
	...

000001fc <__ctors_end>:
     1fc:	11 24       	eor	r1, r1
     1fe:	1f be       	out	0x3f, r1	; 63
     200:	cf ef       	ldi	r28, 0xFF	; 255
     202:	cd bf       	out	0x3d, r28	; 61
     204:	df e3       	ldi	r29, 0x3F	; 63
     206:	de bf       	out	0x3e, r29	; 62
     208:	00 e0       	ldi	r16, 0x00	; 0
     20a:	0c bf       	out	0x3c, r16	; 60
     20c:	18 be       	out	0x38, r1	; 56
     20e:	19 be       	out	0x39, r1	; 57
     210:	1a be       	out	0x3a, r1	; 58
     212:	1b be       	out	0x3b, r1	; 59

00000214 <__do_copy_data>:
     214:	10 e2       	ldi	r17, 0x20	; 32
     216:	a0 e0       	ldi	r26, 0x00	; 0
     218:	b0 e2       	ldi	r27, 0x20	; 32
     21a:	e4 e7       	ldi	r30, 0x74	; 116
     21c:	f9 e1       	ldi	r31, 0x19	; 25
     21e:	00 e0       	ldi	r16, 0x00	; 0
     220:	0b bf       	out	0x3b, r16	; 59
     222:	02 c0       	rjmp	.+4      	; 0x228 <__do_copy_data+0x14>
     224:	07 90       	elpm	r0, Z+
     226:	0d 92       	st	X+, r0
     228:	ae 31       	cpi	r26, 0x1E	; 30
     22a:	b1 07       	cpc	r27, r17
     22c:	d9 f7       	brne	.-10     	; 0x224 <__do_copy_data+0x10>
     22e:	1b be       	out	0x3b, r1	; 59

00000230 <__do_clear_bss>:
     230:	28 e3       	ldi	r18, 0x38	; 56
     232:	ae e1       	ldi	r26, 0x1E	; 30
     234:	b0 e2       	ldi	r27, 0x20	; 32
     236:	01 c0       	rjmp	.+2      	; 0x23a <.do_clear_bss_start>

00000238 <.do_clear_bss_loop>:
     238:	1d 92       	st	X+, r1

0000023a <.do_clear_bss_start>:
     23a:	a3 30       	cpi	r26, 0x03	; 3
     23c:	b2 07       	cpc	r27, r18
     23e:	e1 f7       	brne	.-8      	; 0x238 <.do_clear_bss_loop>
     240:	0e 94 5c 0c 	call	0x18b8	; 0x18b8 <main>
     244:	0c 94 b8 0c 	jmp	0x1970	; 0x1970 <_exit>

00000248 <__bad_interrupt>:
     248:	db ce       	rjmp	.-586    	; 0x0 <__vectors>

0000024a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     24a:	cf 93       	push	r28
     24c:	df 93       	push	r29
     24e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     250:	e7 d5       	rcall	.+3022   	; 0xe20 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     252:	40 91 1e 20 	lds	r20, 0x201E
     256:	50 91 1f 20 	lds	r21, 0x201F
     25a:	9e 01       	movw	r18, r28
     25c:	24 0f       	add	r18, r20
     25e:	35 1f       	adc	r19, r21
     260:	20 37       	cpi	r18, 0x70	; 112
     262:	87 e1       	ldi	r24, 0x17	; 23
     264:	38 07       	cpc	r19, r24
     266:	58 f4       	brcc	.+22     	; 0x27e <pvPortMalloc+0x34>
     268:	42 17       	cp	r20, r18
     26a:	53 07       	cpc	r21, r19
     26c:	58 f4       	brcc	.+22     	; 0x284 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     26e:	ea 01       	movw	r28, r20
     270:	c0 5e       	subi	r28, 0xE0	; 224
     272:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     274:	20 93 1e 20 	sts	0x201E, r18
     278:	30 93 1f 20 	sts	0x201F, r19
     27c:	05 c0       	rjmp	.+10     	; 0x288 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     27e:	c0 e0       	ldi	r28, 0x00	; 0
     280:	d0 e0       	ldi	r29, 0x00	; 0
     282:	02 c0       	rjmp	.+4      	; 0x288 <pvPortMalloc+0x3e>
     284:	c0 e0       	ldi	r28, 0x00	; 0
     286:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     288:	9c d6       	rcall	.+3384   	; 0xfc2 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     28a:	ce 01       	movw	r24, r28
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	08 95       	ret

00000292 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     292:	08 95       	ret

00000294 <pxPortInitialiseStack>:
    /* Should not get here. */
    return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler(void) {
     294:	31 e1       	ldi	r19, 0x11	; 17
     296:	fc 01       	movw	r30, r24
     298:	30 83       	st	Z, r19
     29a:	31 97       	sbiw	r30, 0x01	; 1
     29c:	22 e2       	ldi	r18, 0x22	; 34
     29e:	20 83       	st	Z, r18
     2a0:	31 97       	sbiw	r30, 0x01	; 1
     2a2:	a3 e3       	ldi	r26, 0x33	; 51
     2a4:	a0 83       	st	Z, r26
     2a6:	31 97       	sbiw	r30, 0x01	; 1
     2a8:	60 83       	st	Z, r22
     2aa:	31 97       	sbiw	r30, 0x01	; 1
     2ac:	70 83       	st	Z, r23
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	10 82       	st	Z, r1
     2b2:	31 97       	sbiw	r30, 0x01	; 1
     2b4:	10 82       	st	Z, r1
     2b6:	31 97       	sbiw	r30, 0x01	; 1
     2b8:	60 e8       	ldi	r22, 0x80	; 128
     2ba:	60 83       	st	Z, r22
     2bc:	31 97       	sbiw	r30, 0x01	; 1
     2be:	10 82       	st	Z, r1
     2c0:	31 97       	sbiw	r30, 0x01	; 1
     2c2:	62 e0       	ldi	r22, 0x02	; 2
     2c4:	60 83       	st	Z, r22
     2c6:	31 97       	sbiw	r30, 0x01	; 1
     2c8:	63 e0       	ldi	r22, 0x03	; 3
     2ca:	60 83       	st	Z, r22
     2cc:	31 97       	sbiw	r30, 0x01	; 1
     2ce:	64 e0       	ldi	r22, 0x04	; 4
     2d0:	60 83       	st	Z, r22
     2d2:	31 97       	sbiw	r30, 0x01	; 1
     2d4:	65 e0       	ldi	r22, 0x05	; 5
     2d6:	60 83       	st	Z, r22
     2d8:	31 97       	sbiw	r30, 0x01	; 1
     2da:	66 e0       	ldi	r22, 0x06	; 6
     2dc:	60 83       	st	Z, r22
     2de:	31 97       	sbiw	r30, 0x01	; 1
     2e0:	67 e0       	ldi	r22, 0x07	; 7
     2e2:	60 83       	st	Z, r22
     2e4:	31 97       	sbiw	r30, 0x01	; 1
     2e6:	68 e0       	ldi	r22, 0x08	; 8
     2e8:	60 83       	st	Z, r22
     2ea:	31 97       	sbiw	r30, 0x01	; 1
     2ec:	69 e0       	ldi	r22, 0x09	; 9
     2ee:	60 83       	st	Z, r22
     2f0:	31 97       	sbiw	r30, 0x01	; 1
     2f2:	60 e1       	ldi	r22, 0x10	; 16
     2f4:	60 83       	st	Z, r22
     2f6:	31 97       	sbiw	r30, 0x01	; 1
     2f8:	30 83       	st	Z, r19
     2fa:	31 97       	sbiw	r30, 0x01	; 1
     2fc:	32 e1       	ldi	r19, 0x12	; 18
     2fe:	30 83       	st	Z, r19
     300:	31 97       	sbiw	r30, 0x01	; 1
     302:	33 e1       	ldi	r19, 0x13	; 19
     304:	30 83       	st	Z, r19
     306:	31 97       	sbiw	r30, 0x01	; 1
     308:	34 e1       	ldi	r19, 0x14	; 20
     30a:	30 83       	st	Z, r19
     30c:	31 97       	sbiw	r30, 0x01	; 1
     30e:	35 e1       	ldi	r19, 0x15	; 21
     310:	30 83       	st	Z, r19
     312:	31 97       	sbiw	r30, 0x01	; 1
     314:	36 e1       	ldi	r19, 0x16	; 22
     316:	30 83       	st	Z, r19
     318:	31 97       	sbiw	r30, 0x01	; 1
     31a:	37 e1       	ldi	r19, 0x17	; 23
     31c:	30 83       	st	Z, r19
     31e:	31 97       	sbiw	r30, 0x01	; 1
     320:	38 e1       	ldi	r19, 0x18	; 24
     322:	30 83       	st	Z, r19
     324:	31 97       	sbiw	r30, 0x01	; 1
     326:	39 e1       	ldi	r19, 0x19	; 25
     328:	30 83       	st	Z, r19
     32a:	31 97       	sbiw	r30, 0x01	; 1
     32c:	30 e2       	ldi	r19, 0x20	; 32
     32e:	30 83       	st	Z, r19
     330:	31 97       	sbiw	r30, 0x01	; 1
     332:	31 e2       	ldi	r19, 0x21	; 33
     334:	30 83       	st	Z, r19
     336:	31 97       	sbiw	r30, 0x01	; 1
     338:	20 83       	st	Z, r18
     33a:	31 97       	sbiw	r30, 0x01	; 1
     33c:	23 e2       	ldi	r18, 0x23	; 35
     33e:	20 83       	st	Z, r18
     340:	31 97       	sbiw	r30, 0x01	; 1
     342:	40 83       	st	Z, r20
     344:	31 97       	sbiw	r30, 0x01	; 1
     346:	50 83       	st	Z, r21
     348:	31 97       	sbiw	r30, 0x01	; 1
     34a:	26 e2       	ldi	r18, 0x26	; 38
     34c:	20 83       	st	Z, r18
     34e:	31 97       	sbiw	r30, 0x01	; 1
     350:	27 e2       	ldi	r18, 0x27	; 39
     352:	20 83       	st	Z, r18
     354:	31 97       	sbiw	r30, 0x01	; 1
     356:	28 e2       	ldi	r18, 0x28	; 40
     358:	20 83       	st	Z, r18
     35a:	31 97       	sbiw	r30, 0x01	; 1
     35c:	29 e2       	ldi	r18, 0x29	; 41
     35e:	20 83       	st	Z, r18
     360:	31 97       	sbiw	r30, 0x01	; 1
     362:	20 e3       	ldi	r18, 0x30	; 48
     364:	20 83       	st	Z, r18
     366:	31 97       	sbiw	r30, 0x01	; 1
     368:	21 e3       	ldi	r18, 0x31	; 49
     36a:	20 83       	st	Z, r18
     36c:	87 97       	sbiw	r24, 0x27	; 39
     36e:	08 95       	ret

00000370 <xPortStartScheduler>:
     370:	65 e0       	ldi	r22, 0x05	; 5
     372:	80 e0       	ldi	r24, 0x00	; 0
     374:	98 e0       	ldi	r25, 0x08	; 8
     376:	0e 94 8d 0c 	call	0x191a	; 0x191a <TC0_ConfigClockSource>
     37a:	8e e1       	ldi	r24, 0x1E	; 30
     37c:	90 e0       	ldi	r25, 0x00	; 0
     37e:	e0 e0       	ldi	r30, 0x00	; 0
     380:	f8 e0       	ldi	r31, 0x08	; 8
     382:	86 a3       	std	Z+38, r24	; 0x26
     384:	97 a3       	std	Z+39, r25	; 0x27
     386:	61 e0       	ldi	r22, 0x01	; 1
     388:	80 e0       	ldi	r24, 0x00	; 0
     38a:	98 e0       	ldi	r25, 0x08	; 8
     38c:	0e 94 93 0c 	call	0x1926	; 0x1926 <TC0_SetOverflowIntLevel>
     390:	e0 ea       	ldi	r30, 0xA0	; 160
     392:	f0 e0       	ldi	r31, 0x00	; 0
     394:	82 81       	ldd	r24, Z+2	; 0x02
     396:	81 60       	ori	r24, 0x01	; 1
     398:	82 83       	std	Z+2, r24	; 0x02
     39a:	a0 91 e7 37 	lds	r26, 0x37E7
     39e:	b0 91 e8 37 	lds	r27, 0x37E8
     3a2:	cd 91       	ld	r28, X+
     3a4:	cd bf       	out	0x3d, r28	; 61
     3a6:	dd 91       	ld	r29, X+
     3a8:	de bf       	out	0x3e, r29	; 62
     3aa:	ff 91       	pop	r31
     3ac:	ef 91       	pop	r30
     3ae:	df 91       	pop	r29
     3b0:	cf 91       	pop	r28
     3b2:	bf 91       	pop	r27
     3b4:	af 91       	pop	r26
     3b6:	9f 91       	pop	r25
     3b8:	8f 91       	pop	r24
     3ba:	7f 91       	pop	r23
     3bc:	6f 91       	pop	r22
     3be:	5f 91       	pop	r21
     3c0:	4f 91       	pop	r20
     3c2:	3f 91       	pop	r19
     3c4:	2f 91       	pop	r18
     3c6:	1f 91       	pop	r17
     3c8:	0f 91       	pop	r16
     3ca:	ff 90       	pop	r15
     3cc:	ef 90       	pop	r14
     3ce:	df 90       	pop	r13
     3d0:	cf 90       	pop	r12
     3d2:	bf 90       	pop	r11
     3d4:	af 90       	pop	r10
     3d6:	9f 90       	pop	r9
     3d8:	8f 90       	pop	r8
     3da:	7f 90       	pop	r7
     3dc:	6f 90       	pop	r6
     3de:	5f 90       	pop	r5
     3e0:	4f 90       	pop	r4
     3e2:	3f 90       	pop	r3
     3e4:	2f 90       	pop	r2
     3e6:	1f 90       	pop	r1
     3e8:	0f 90       	pop	r0
     3ea:	0f be       	out	0x3f, r0	; 63
     3ec:	0f 90       	pop	r0
     3ee:	08 95       	ret
     3f0:	81 e0       	ldi	r24, 0x01	; 1
     3f2:	08 95       	ret

000003f4 <vPortYield>:
 * Manual context switch.  The first thing we do is save the registers so we
 * can use a naked attribute.
 */
void vPortYield(void) __attribute__ ( ( naked ) );
void vPortYield(void) {
    portSAVE_CONTEXT();
     3f4:	0f 92       	push	r0
     3f6:	0f b6       	in	r0, 0x3f	; 63
     3f8:	f8 94       	cli
     3fa:	0f 92       	push	r0
     3fc:	1f 92       	push	r1
     3fe:	11 24       	eor	r1, r1
     400:	2f 92       	push	r2
     402:	3f 92       	push	r3
     404:	4f 92       	push	r4
     406:	5f 92       	push	r5
     408:	6f 92       	push	r6
     40a:	7f 92       	push	r7
     40c:	8f 92       	push	r8
     40e:	9f 92       	push	r9
     410:	af 92       	push	r10
     412:	bf 92       	push	r11
     414:	cf 92       	push	r12
     416:	df 92       	push	r13
     418:	ef 92       	push	r14
     41a:	ff 92       	push	r15
     41c:	0f 93       	push	r16
     41e:	1f 93       	push	r17
     420:	2f 93       	push	r18
     422:	3f 93       	push	r19
     424:	4f 93       	push	r20
     426:	5f 93       	push	r21
     428:	6f 93       	push	r22
     42a:	7f 93       	push	r23
     42c:	8f 93       	push	r24
     42e:	9f 93       	push	r25
     430:	af 93       	push	r26
     432:	bf 93       	push	r27
     434:	cf 93       	push	r28
     436:	df 93       	push	r29
     438:	ef 93       	push	r30
     43a:	ff 93       	push	r31
     43c:	a0 91 e7 37 	lds	r26, 0x37E7
     440:	b0 91 e8 37 	lds	r27, 0x37E8
     444:	0d b6       	in	r0, 0x3d	; 61
     446:	0d 92       	st	X+, r0
     448:	0e b6       	in	r0, 0x3e	; 62
     44a:	0d 92       	st	X+, r0
    vTaskSwitchContext();
     44c:	5d d6       	rcall	.+3258   	; 0x1108 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
     44e:	a0 91 e7 37 	lds	r26, 0x37E7
     452:	b0 91 e8 37 	lds	r27, 0x37E8
     456:	cd 91       	ld	r28, X+
     458:	cd bf       	out	0x3d, r28	; 61
     45a:	dd 91       	ld	r29, X+
     45c:	de bf       	out	0x3e, r29	; 62
     45e:	ff 91       	pop	r31
     460:	ef 91       	pop	r30
     462:	df 91       	pop	r29
     464:	cf 91       	pop	r28
     466:	bf 91       	pop	r27
     468:	af 91       	pop	r26
     46a:	9f 91       	pop	r25
     46c:	8f 91       	pop	r24
     46e:	7f 91       	pop	r23
     470:	6f 91       	pop	r22
     472:	5f 91       	pop	r21
     474:	4f 91       	pop	r20
     476:	3f 91       	pop	r19
     478:	2f 91       	pop	r18
     47a:	1f 91       	pop	r17
     47c:	0f 91       	pop	r16
     47e:	ff 90       	pop	r15
     480:	ef 90       	pop	r14
     482:	df 90       	pop	r13
     484:	cf 90       	pop	r12
     486:	bf 90       	pop	r11
     488:	af 90       	pop	r10
     48a:	9f 90       	pop	r9
     48c:	8f 90       	pop	r8
     48e:	7f 90       	pop	r7
     490:	6f 90       	pop	r6
     492:	5f 90       	pop	r5
     494:	4f 90       	pop	r4
     496:	3f 90       	pop	r3
     498:	2f 90       	pop	r2
     49a:	1f 90       	pop	r1
     49c:	0f 90       	pop	r0
     49e:	0f be       	out	0x3f, r0	; 63
     4a0:	0f 90       	pop	r0

    asm volatile ( "ret" );
     4a2:	08 95       	ret

000004a4 <__vector_14>:
     * Context switch function used by the tick.  This must be identical to
     * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
     * difference from vPortYield() is the tick count is incremented as the
     * call comes from the tick ISR.
     */
    portSAVE_CONTEXT();
     4a4:	0f 92       	push	r0
     4a6:	0f b6       	in	r0, 0x3f	; 63
     4a8:	f8 94       	cli
     4aa:	0f 92       	push	r0
     4ac:	1f 92       	push	r1
     4ae:	11 24       	eor	r1, r1
     4b0:	2f 92       	push	r2
     4b2:	3f 92       	push	r3
     4b4:	4f 92       	push	r4
     4b6:	5f 92       	push	r5
     4b8:	6f 92       	push	r6
     4ba:	7f 92       	push	r7
     4bc:	8f 92       	push	r8
     4be:	9f 92       	push	r9
     4c0:	af 92       	push	r10
     4c2:	bf 92       	push	r11
     4c4:	cf 92       	push	r12
     4c6:	df 92       	push	r13
     4c8:	ef 92       	push	r14
     4ca:	ff 92       	push	r15
     4cc:	0f 93       	push	r16
     4ce:	1f 93       	push	r17
     4d0:	2f 93       	push	r18
     4d2:	3f 93       	push	r19
     4d4:	4f 93       	push	r20
     4d6:	5f 93       	push	r21
     4d8:	6f 93       	push	r22
     4da:	7f 93       	push	r23
     4dc:	8f 93       	push	r24
     4de:	9f 93       	push	r25
     4e0:	af 93       	push	r26
     4e2:	bf 93       	push	r27
     4e4:	cf 93       	push	r28
     4e6:	df 93       	push	r29
     4e8:	ef 93       	push	r30
     4ea:	ff 93       	push	r31
     4ec:	a0 91 e7 37 	lds	r26, 0x37E7
     4f0:	b0 91 e8 37 	lds	r27, 0x37E8
     4f4:	0d b6       	in	r0, 0x3d	; 61
     4f6:	0d 92       	st	X+, r0
     4f8:	0e b6       	in	r0, 0x3e	; 62
     4fa:	0d 92       	st	X+, r0
    vTaskIncrementTick();
     4fc:	a1 d4       	rcall	.+2370   	; 0xe40 <vTaskIncrementTick>
    vTaskSwitchContext();
     4fe:	04 d6       	rcall	.+3080   	; 0x1108 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
     500:	a0 91 e7 37 	lds	r26, 0x37E7
     504:	b0 91 e8 37 	lds	r27, 0x37E8
     508:	cd 91       	ld	r28, X+
     50a:	cd bf       	out	0x3d, r28	; 61
     50c:	dd 91       	ld	r29, X+
     50e:	de bf       	out	0x3e, r29	; 62
     510:	ff 91       	pop	r31
     512:	ef 91       	pop	r30
     514:	df 91       	pop	r29
     516:	cf 91       	pop	r28
     518:	bf 91       	pop	r27
     51a:	af 91       	pop	r26
     51c:	9f 91       	pop	r25
     51e:	8f 91       	pop	r24
     520:	7f 91       	pop	r23
     522:	6f 91       	pop	r22
     524:	5f 91       	pop	r21
     526:	4f 91       	pop	r20
     528:	3f 91       	pop	r19
     52a:	2f 91       	pop	r18
     52c:	1f 91       	pop	r17
     52e:	0f 91       	pop	r16
     530:	ff 90       	pop	r15
     532:	ef 90       	pop	r14
     534:	df 90       	pop	r13
     536:	cf 90       	pop	r12
     538:	bf 90       	pop	r11
     53a:	af 90       	pop	r10
     53c:	9f 90       	pop	r9
     53e:	8f 90       	pop	r8
     540:	7f 90       	pop	r7
     542:	6f 90       	pop	r6
     544:	5f 90       	pop	r5
     546:	4f 90       	pop	r4
     548:	3f 90       	pop	r3
     54a:	2f 90       	pop	r2
     54c:	1f 90       	pop	r1
     54e:	0f 90       	pop	r0
     550:	0f be       	out	0x3f, r0	; 63
     552:	0f 90       	pop	r0
    asm volatile ( "reti" );
     554:	18 95       	reti

00000556 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     556:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     558:	03 96       	adiw	r24, 0x03	; 3
     55a:	81 83       	std	Z+1, r24	; 0x01
     55c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     55e:	2f ef       	ldi	r18, 0xFF	; 255
     560:	3f ef       	ldi	r19, 0xFF	; 255
     562:	23 83       	std	Z+3, r18	; 0x03
     564:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     566:	85 83       	std	Z+5, r24	; 0x05
     568:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     56a:	87 83       	std	Z+7, r24	; 0x07
     56c:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     56e:	10 82       	st	Z, r1
     570:	08 95       	ret

00000572 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     572:	fc 01       	movw	r30, r24
     574:	10 86       	std	Z+8, r1	; 0x08
     576:	11 86       	std	Z+9, r1	; 0x09
     578:	08 95       	ret

0000057a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     57a:	cf 93       	push	r28
     57c:	df 93       	push	r29
     57e:	fc 01       	movw	r30, r24
     580:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     582:	21 81       	ldd	r18, Z+1	; 0x01
     584:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     586:	e9 01       	movw	r28, r18
     588:	8a 81       	ldd	r24, Y+2	; 0x02
     58a:	9b 81       	ldd	r25, Y+3	; 0x03
     58c:	12 96       	adiw	r26, 0x02	; 2
     58e:	8d 93       	st	X+, r24
     590:	9c 93       	st	X, r25
     592:	13 97       	sbiw	r26, 0x03	; 3
	pxNewListItem->pxPrevious = pxList->pxIndex;
     594:	81 81       	ldd	r24, Z+1	; 0x01
     596:	92 81       	ldd	r25, Z+2	; 0x02
     598:	14 96       	adiw	r26, 0x04	; 4
     59a:	8d 93       	st	X+, r24
     59c:	9c 93       	st	X, r25
     59e:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     5a0:	8a 81       	ldd	r24, Y+2	; 0x02
     5a2:	9b 81       	ldd	r25, Y+3	; 0x03
     5a4:	ec 01       	movw	r28, r24
     5a6:	6c 83       	std	Y+4, r22	; 0x04
     5a8:	7d 83       	std	Y+5, r23	; 0x05
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     5aa:	e9 01       	movw	r28, r18
     5ac:	6a 83       	std	Y+2, r22	; 0x02
     5ae:	7b 83       	std	Y+3, r23	; 0x03
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     5b0:	61 83       	std	Z+1, r22	; 0x01
     5b2:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5b4:	18 96       	adiw	r26, 0x08	; 8
     5b6:	ed 93       	st	X+, r30
     5b8:	fc 93       	st	X, r31
     5ba:	19 97       	sbiw	r26, 0x09	; 9

	( pxList->uxNumberOfItems )++;
     5bc:	80 81       	ld	r24, Z
     5be:	8f 5f       	subi	r24, 0xFF	; 255
     5c0:	80 83       	st	Z, r24
}
     5c2:	df 91       	pop	r29
     5c4:	cf 91       	pop	r28
     5c6:	08 95       	ret

000005c8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     5c8:	cf 93       	push	r28
     5ca:	df 93       	push	r29
     5cc:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     5ce:	48 81       	ld	r20, Y
     5d0:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5d2:	4f 3f       	cpi	r20, 0xFF	; 255
     5d4:	2f ef       	ldi	r18, 0xFF	; 255
     5d6:	52 07       	cpc	r21, r18
     5d8:	31 f4       	brne	.+12     	; 0x5e6 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5da:	dc 01       	movw	r26, r24
     5dc:	17 96       	adiw	r26, 0x07	; 7
     5de:	ed 91       	ld	r30, X+
     5e0:	fc 91       	ld	r31, X
     5e2:	18 97       	sbiw	r26, 0x08	; 8
     5e4:	17 c0       	rjmp	.+46     	; 0x614 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     5e6:	fc 01       	movw	r30, r24
     5e8:	33 96       	adiw	r30, 0x03	; 3
     5ea:	dc 01       	movw	r26, r24
     5ec:	15 96       	adiw	r26, 0x05	; 5
     5ee:	2d 91       	ld	r18, X+
     5f0:	3c 91       	ld	r19, X
     5f2:	16 97       	sbiw	r26, 0x06	; 6
     5f4:	d9 01       	movw	r26, r18
     5f6:	2d 91       	ld	r18, X+
     5f8:	3c 91       	ld	r19, X
     5fa:	42 17       	cp	r20, r18
     5fc:	53 07       	cpc	r21, r19
     5fe:	50 f0       	brcs	.+20     	; 0x614 <vListInsert+0x4c>
     600:	02 80       	ldd	r0, Z+2	; 0x02
     602:	f3 81       	ldd	r31, Z+3	; 0x03
     604:	e0 2d       	mov	r30, r0
     606:	a2 81       	ldd	r26, Z+2	; 0x02
     608:	b3 81       	ldd	r27, Z+3	; 0x03
     60a:	2d 91       	ld	r18, X+
     60c:	3c 91       	ld	r19, X
     60e:	42 17       	cp	r20, r18
     610:	53 07       	cpc	r21, r19
     612:	b0 f7       	brcc	.-20     	; 0x600 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     614:	a2 81       	ldd	r26, Z+2	; 0x02
     616:	b3 81       	ldd	r27, Z+3	; 0x03
     618:	aa 83       	std	Y+2, r26	; 0x02
     61a:	bb 83       	std	Y+3, r27	; 0x03
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     61c:	14 96       	adiw	r26, 0x04	; 4
     61e:	cd 93       	st	X+, r28
     620:	dc 93       	st	X, r29
     622:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxIterator;
     624:	ec 83       	std	Y+4, r30	; 0x04
     626:	fd 83       	std	Y+5, r31	; 0x05
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     628:	c2 83       	std	Z+2, r28	; 0x02
     62a:	d3 83       	std	Z+3, r29	; 0x03

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62c:	88 87       	std	Y+8, r24	; 0x08
     62e:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
     630:	fc 01       	movw	r30, r24
     632:	20 81       	ld	r18, Z
     634:	2f 5f       	subi	r18, 0xFF	; 255
     636:	20 83       	st	Z, r18
}
     638:	df 91       	pop	r29
     63a:	cf 91       	pop	r28
     63c:	08 95       	ret

0000063e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     63e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     640:	a2 81       	ldd	r26, Z+2	; 0x02
     642:	b3 81       	ldd	r27, Z+3	; 0x03
     644:	84 81       	ldd	r24, Z+4	; 0x04
     646:	95 81       	ldd	r25, Z+5	; 0x05
     648:	14 96       	adiw	r26, 0x04	; 4
     64a:	8d 93       	st	X+, r24
     64c:	9c 93       	st	X, r25
     64e:	15 97       	sbiw	r26, 0x05	; 5
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     650:	a4 81       	ldd	r26, Z+4	; 0x04
     652:	b5 81       	ldd	r27, Z+5	; 0x05
     654:	82 81       	ldd	r24, Z+2	; 0x02
     656:	93 81       	ldd	r25, Z+3	; 0x03
     658:	12 96       	adiw	r26, 0x02	; 2
     65a:	8d 93       	st	X+, r24
     65c:	9c 93       	st	X, r25
     65e:	13 97       	sbiw	r26, 0x03	; 3
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     660:	a0 85       	ldd	r26, Z+8	; 0x08
     662:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     664:	11 96       	adiw	r26, 0x01	; 1
     666:	8d 91       	ld	r24, X+
     668:	9c 91       	ld	r25, X
     66a:	12 97       	sbiw	r26, 0x02	; 2
     66c:	8e 17       	cp	r24, r30
     66e:	9f 07       	cpc	r25, r31
     670:	31 f4       	brne	.+12     	; 0x67e <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     672:	84 81       	ldd	r24, Z+4	; 0x04
     674:	95 81       	ldd	r25, Z+5	; 0x05
     676:	11 96       	adiw	r26, 0x01	; 1
     678:	8d 93       	st	X+, r24
     67a:	9c 93       	st	X, r25
     67c:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
     67e:	10 86       	std	Z+8, r1	; 0x08
     680:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
     682:	8c 91       	ld	r24, X
     684:	81 50       	subi	r24, 0x01	; 1
     686:	8c 93       	st	X, r24
     688:	08 95       	ret

0000068a <prvCopyDataToQueue>:

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );

	return xReturn;
}
     68a:	cf 93       	push	r28
     68c:	df 93       	push	r29
     68e:	ec 01       	movw	r28, r24
     690:	8c 8d       	ldd	r24, Y+28	; 0x1c
     692:	81 11       	cpse	r24, r1
     694:	0a c0       	rjmp	.+20     	; 0x6aa <prvCopyDataToQueue+0x20>
     696:	88 81       	ld	r24, Y
     698:	99 81       	ldd	r25, Y+1	; 0x01
     69a:	89 2b       	or	r24, r25
     69c:	d9 f5       	brne	.+118    	; 0x714 <prvCopyDataToQueue+0x8a>
     69e:	8a 81       	ldd	r24, Y+2	; 0x02
     6a0:	9b 81       	ldd	r25, Y+3	; 0x03
     6a2:	c7 d6       	rcall	.+3470   	; 0x1432 <vTaskPriorityDisinherit>
     6a4:	1a 82       	std	Y+2, r1	; 0x02
     6a6:	1b 82       	std	Y+3, r1	; 0x03
     6a8:	35 c0       	rjmp	.+106    	; 0x714 <prvCopyDataToQueue+0x8a>
     6aa:	41 11       	cpse	r20, r1
     6ac:	17 c0       	rjmp	.+46     	; 0x6dc <prvCopyDataToQueue+0x52>
     6ae:	48 2f       	mov	r20, r24
     6b0:	50 e0       	ldi	r21, 0x00	; 0
     6b2:	8c 81       	ldd	r24, Y+4	; 0x04
     6b4:	9d 81       	ldd	r25, Y+5	; 0x05
     6b6:	0e 94 99 0c 	call	0x1932	; 0x1932 <memcpy>
     6ba:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6bc:	8c 81       	ldd	r24, Y+4	; 0x04
     6be:	9d 81       	ldd	r25, Y+5	; 0x05
     6c0:	82 0f       	add	r24, r18
     6c2:	91 1d       	adc	r25, r1
     6c4:	8c 83       	std	Y+4, r24	; 0x04
     6c6:	9d 83       	std	Y+5, r25	; 0x05
     6c8:	2a 81       	ldd	r18, Y+2	; 0x02
     6ca:	3b 81       	ldd	r19, Y+3	; 0x03
     6cc:	82 17       	cp	r24, r18
     6ce:	93 07       	cpc	r25, r19
     6d0:	08 f1       	brcs	.+66     	; 0x714 <prvCopyDataToQueue+0x8a>
     6d2:	88 81       	ld	r24, Y
     6d4:	99 81       	ldd	r25, Y+1	; 0x01
     6d6:	8c 83       	std	Y+4, r24	; 0x04
     6d8:	9d 83       	std	Y+5, r25	; 0x05
     6da:	1c c0       	rjmp	.+56     	; 0x714 <prvCopyDataToQueue+0x8a>
     6dc:	48 2f       	mov	r20, r24
     6de:	50 e0       	ldi	r21, 0x00	; 0
     6e0:	8e 81       	ldd	r24, Y+6	; 0x06
     6e2:	9f 81       	ldd	r25, Y+7	; 0x07
     6e4:	0e 94 99 0c 	call	0x1932	; 0x1932 <memcpy>
     6e8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6ea:	30 e0       	ldi	r19, 0x00	; 0
     6ec:	31 95       	neg	r19
     6ee:	21 95       	neg	r18
     6f0:	31 09       	sbc	r19, r1
     6f2:	8e 81       	ldd	r24, Y+6	; 0x06
     6f4:	9f 81       	ldd	r25, Y+7	; 0x07
     6f6:	82 0f       	add	r24, r18
     6f8:	93 1f       	adc	r25, r19
     6fa:	8e 83       	std	Y+6, r24	; 0x06
     6fc:	9f 83       	std	Y+7, r25	; 0x07
     6fe:	48 81       	ld	r20, Y
     700:	59 81       	ldd	r21, Y+1	; 0x01
     702:	84 17       	cp	r24, r20
     704:	95 07       	cpc	r25, r21
     706:	30 f4       	brcc	.+12     	; 0x714 <prvCopyDataToQueue+0x8a>
     708:	8a 81       	ldd	r24, Y+2	; 0x02
     70a:	9b 81       	ldd	r25, Y+3	; 0x03
     70c:	28 0f       	add	r18, r24
     70e:	39 1f       	adc	r19, r25
     710:	2e 83       	std	Y+6, r18	; 0x06
     712:	3f 83       	std	Y+7, r19	; 0x07
     714:	8a 8d       	ldd	r24, Y+26	; 0x1a
     716:	8f 5f       	subi	r24, 0xFF	; 255
     718:	8a 8f       	std	Y+26, r24	; 0x1a
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	08 95       	ret

00000720 <prvCopyDataFromQueue>:
     720:	fc 01       	movw	r30, r24
     722:	cb 01       	movw	r24, r22
     724:	a0 81       	ld	r26, Z
     726:	b1 81       	ldd	r27, Z+1	; 0x01
     728:	10 97       	sbiw	r26, 0x00	; 0
     72a:	99 f0       	breq	.+38     	; 0x752 <prvCopyDataFromQueue+0x32>
     72c:	44 8d       	ldd	r20, Z+28	; 0x1c
     72e:	50 e0       	ldi	r21, 0x00	; 0
     730:	26 81       	ldd	r18, Z+6	; 0x06
     732:	37 81       	ldd	r19, Z+7	; 0x07
     734:	24 0f       	add	r18, r20
     736:	35 1f       	adc	r19, r21
     738:	26 83       	std	Z+6, r18	; 0x06
     73a:	37 83       	std	Z+7, r19	; 0x07
     73c:	62 81       	ldd	r22, Z+2	; 0x02
     73e:	73 81       	ldd	r23, Z+3	; 0x03
     740:	26 17       	cp	r18, r22
     742:	37 07       	cpc	r19, r23
     744:	10 f0       	brcs	.+4      	; 0x74a <prvCopyDataFromQueue+0x2a>
     746:	a6 83       	std	Z+6, r26	; 0x06
     748:	b7 83       	std	Z+7, r27	; 0x07
     74a:	66 81       	ldd	r22, Z+6	; 0x06
     74c:	77 81       	ldd	r23, Z+7	; 0x07
     74e:	0c 94 99 0c 	jmp	0x1932	; 0x1932 <memcpy>
     752:	08 95       	ret

00000754 <prvUnlockQueue>:
     754:	0f 93       	push	r16
     756:	1f 93       	push	r17
     758:	cf 93       	push	r28
     75a:	df 93       	push	r29
     75c:	ec 01       	movw	r28, r24
     75e:	0f b6       	in	r0, 0x3f	; 63
     760:	f8 94       	cli
     762:	0f 92       	push	r0
     764:	8e 8d       	ldd	r24, Y+30	; 0x1e
     766:	18 16       	cp	r1, r24
     768:	9c f4       	brge	.+38     	; 0x790 <prvUnlockQueue+0x3c>
     76a:	89 89       	ldd	r24, Y+17	; 0x11
     76c:	88 23       	and	r24, r24
     76e:	81 f0       	breq	.+32     	; 0x790 <prvUnlockQueue+0x3c>
     770:	8e 01       	movw	r16, r28
     772:	0f 5e       	subi	r16, 0xEF	; 239
     774:	1f 4f       	sbci	r17, 0xFF	; 255
     776:	03 c0       	rjmp	.+6      	; 0x77e <prvUnlockQueue+0x2a>
     778:	89 89       	ldd	r24, Y+17	; 0x11
     77a:	88 23       	and	r24, r24
     77c:	49 f0       	breq	.+18     	; 0x790 <prvUnlockQueue+0x3c>
     77e:	c8 01       	movw	r24, r16
     780:	62 d5       	rcall	.+2756   	; 0x1246 <xTaskRemoveFromEventList>
     782:	81 11       	cpse	r24, r1
     784:	ea d5       	rcall	.+3028   	; 0x135a <vTaskMissedYield>
     786:	8e 8d       	ldd	r24, Y+30	; 0x1e
     788:	81 50       	subi	r24, 0x01	; 1
     78a:	8e 8f       	std	Y+30, r24	; 0x1e
     78c:	18 16       	cp	r1, r24
     78e:	a4 f3       	brlt	.-24     	; 0x778 <prvUnlockQueue+0x24>
     790:	8f ef       	ldi	r24, 0xFF	; 255
     792:	8e 8f       	std	Y+30, r24	; 0x1e
     794:	0f 90       	pop	r0
     796:	0f be       	out	0x3f, r0	; 63
     798:	0f b6       	in	r0, 0x3f	; 63
     79a:	f8 94       	cli
     79c:	0f 92       	push	r0
     79e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     7a0:	18 16       	cp	r1, r24
     7a2:	9c f4       	brge	.+38     	; 0x7ca <prvUnlockQueue+0x76>
     7a4:	88 85       	ldd	r24, Y+8	; 0x08
     7a6:	88 23       	and	r24, r24
     7a8:	81 f0       	breq	.+32     	; 0x7ca <prvUnlockQueue+0x76>
     7aa:	8e 01       	movw	r16, r28
     7ac:	08 5f       	subi	r16, 0xF8	; 248
     7ae:	1f 4f       	sbci	r17, 0xFF	; 255
     7b0:	03 c0       	rjmp	.+6      	; 0x7b8 <prvUnlockQueue+0x64>
     7b2:	88 85       	ldd	r24, Y+8	; 0x08
     7b4:	88 23       	and	r24, r24
     7b6:	49 f0       	breq	.+18     	; 0x7ca <prvUnlockQueue+0x76>
     7b8:	c8 01       	movw	r24, r16
     7ba:	45 d5       	rcall	.+2698   	; 0x1246 <xTaskRemoveFromEventList>
     7bc:	81 11       	cpse	r24, r1
     7be:	cd d5       	rcall	.+2970   	; 0x135a <vTaskMissedYield>
     7c0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     7c2:	81 50       	subi	r24, 0x01	; 1
     7c4:	8d 8f       	std	Y+29, r24	; 0x1d
     7c6:	18 16       	cp	r1, r24
     7c8:	a4 f3       	brlt	.-24     	; 0x7b2 <prvUnlockQueue+0x5e>
     7ca:	8f ef       	ldi	r24, 0xFF	; 255
     7cc:	8d 8f       	std	Y+29, r24	; 0x1d
     7ce:	0f 90       	pop	r0
     7d0:	0f be       	out	0x3f, r0	; 63
     7d2:	df 91       	pop	r29
     7d4:	cf 91       	pop	r28
     7d6:	1f 91       	pop	r17
     7d8:	0f 91       	pop	r16
     7da:	08 95       	ret

000007dc <xQueueCreate>:
     7dc:	cf 92       	push	r12
     7de:	df 92       	push	r13
     7e0:	ef 92       	push	r14
     7e2:	ff 92       	push	r15
     7e4:	0f 93       	push	r16
     7e6:	1f 93       	push	r17
     7e8:	cf 93       	push	r28
     7ea:	df 93       	push	r29
     7ec:	d8 2e       	mov	r13, r24
     7ee:	c6 2e       	mov	r12, r22
     7f0:	88 23       	and	r24, r24
     7f2:	a1 f1       	breq	.+104    	; 0x85c <xQueueCreate+0x80>
     7f4:	8f e1       	ldi	r24, 0x1F	; 31
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	28 dd       	rcall	.-1456   	; 0x24a <pvPortMalloc>
     7fa:	ec 01       	movw	r28, r24
     7fc:	00 97       	sbiw	r24, 0x00	; 0
     7fe:	81 f1       	breq	.+96     	; 0x860 <xQueueCreate+0x84>
     800:	ec 2c       	mov	r14, r12
     802:	f1 2c       	mov	r15, r1
     804:	de 9c       	mul	r13, r14
     806:	80 01       	movw	r16, r0
     808:	df 9c       	mul	r13, r15
     80a:	10 0d       	add	r17, r0
     80c:	11 24       	eor	r1, r1
     80e:	c8 01       	movw	r24, r16
     810:	01 96       	adiw	r24, 0x01	; 1
     812:	1b dd       	rcall	.-1482   	; 0x24a <pvPortMalloc>
     814:	88 83       	st	Y, r24
     816:	99 83       	std	Y+1, r25	; 0x01
     818:	00 97       	sbiw	r24, 0x00	; 0
     81a:	d9 f0       	breq	.+54     	; 0x852 <xQueueCreate+0x76>
     81c:	ac 01       	movw	r20, r24
     81e:	40 0f       	add	r20, r16
     820:	51 1f       	adc	r21, r17
     822:	4a 83       	std	Y+2, r20	; 0x02
     824:	5b 83       	std	Y+3, r21	; 0x03
     826:	1a 8e       	std	Y+26, r1	; 0x1a
     828:	8c 83       	std	Y+4, r24	; 0x04
     82a:	9d 83       	std	Y+5, r25	; 0x05
     82c:	0e 19       	sub	r16, r14
     82e:	1f 09       	sbc	r17, r15
     830:	9c 01       	movw	r18, r24
     832:	20 0f       	add	r18, r16
     834:	31 1f       	adc	r19, r17
     836:	2e 83       	std	Y+6, r18	; 0x06
     838:	3f 83       	std	Y+7, r19	; 0x07
     83a:	db 8e       	std	Y+27, r13	; 0x1b
     83c:	cc 8e       	std	Y+28, r12	; 0x1c
     83e:	8f ef       	ldi	r24, 0xFF	; 255
     840:	8d 8f       	std	Y+29, r24	; 0x1d
     842:	8e 8f       	std	Y+30, r24	; 0x1e
     844:	ce 01       	movw	r24, r28
     846:	08 96       	adiw	r24, 0x08	; 8
     848:	86 de       	rcall	.-756    	; 0x556 <vListInitialise>
     84a:	ce 01       	movw	r24, r28
     84c:	41 96       	adiw	r24, 0x11	; 17
     84e:	83 de       	rcall	.-762    	; 0x556 <vListInitialise>
     850:	07 c0       	rjmp	.+14     	; 0x860 <xQueueCreate+0x84>
     852:	ce 01       	movw	r24, r28
     854:	1e dd       	rcall	.-1476   	; 0x292 <vPortFree>
     856:	c0 e0       	ldi	r28, 0x00	; 0
     858:	d0 e0       	ldi	r29, 0x00	; 0
     85a:	02 c0       	rjmp	.+4      	; 0x860 <xQueueCreate+0x84>
     85c:	c0 e0       	ldi	r28, 0x00	; 0
     85e:	d0 e0       	ldi	r29, 0x00	; 0
     860:	ce 01       	movw	r24, r28
     862:	df 91       	pop	r29
     864:	cf 91       	pop	r28
     866:	1f 91       	pop	r17
     868:	0f 91       	pop	r16
     86a:	ff 90       	pop	r15
     86c:	ef 90       	pop	r14
     86e:	df 90       	pop	r13
     870:	cf 90       	pop	r12
     872:	08 95       	ret

00000874 <xQueueGenericSend>:
     874:	af 92       	push	r10
     876:	bf 92       	push	r11
     878:	cf 92       	push	r12
     87a:	df 92       	push	r13
     87c:	ef 92       	push	r14
     87e:	ff 92       	push	r15
     880:	0f 93       	push	r16
     882:	1f 93       	push	r17
     884:	cf 93       	push	r28
     886:	df 93       	push	r29
     888:	cd b7       	in	r28, 0x3d	; 61
     88a:	de b7       	in	r29, 0x3e	; 62
     88c:	25 97       	sbiw	r28, 0x05	; 5
     88e:	cd bf       	out	0x3d, r28	; 61
     890:	de bf       	out	0x3e, r29	; 62
     892:	8c 01       	movw	r16, r24
     894:	6b 01       	movw	r12, r22
     896:	4c 83       	std	Y+4, r20	; 0x04
     898:	5d 83       	std	Y+5, r21	; 0x05
     89a:	a2 2e       	mov	r10, r18
     89c:	b1 2c       	mov	r11, r1
     89e:	7c 01       	movw	r14, r24
     8a0:	88 e0       	ldi	r24, 0x08	; 8
     8a2:	e8 0e       	add	r14, r24
     8a4:	f1 1c       	adc	r15, r1
     8a6:	0f b6       	in	r0, 0x3f	; 63
     8a8:	f8 94       	cli
     8aa:	0f 92       	push	r0
     8ac:	f8 01       	movw	r30, r16
     8ae:	92 8d       	ldd	r25, Z+26	; 0x1a
     8b0:	83 8d       	ldd	r24, Z+27	; 0x1b
     8b2:	98 17       	cp	r25, r24
     8b4:	90 f4       	brcc	.+36     	; 0x8da <xQueueGenericSend+0x66>
     8b6:	4a 2d       	mov	r20, r10
     8b8:	b6 01       	movw	r22, r12
     8ba:	c8 01       	movw	r24, r16
     8bc:	e6 de       	rcall	.-564    	; 0x68a <prvCopyDataToQueue>
     8be:	f8 01       	movw	r30, r16
     8c0:	81 89       	ldd	r24, Z+17	; 0x11
     8c2:	88 23       	and	r24, r24
     8c4:	31 f0       	breq	.+12     	; 0x8d2 <xQueueGenericSend+0x5e>
     8c6:	c8 01       	movw	r24, r16
     8c8:	41 96       	adiw	r24, 0x11	; 17
     8ca:	bd d4       	rcall	.+2426   	; 0x1246 <xTaskRemoveFromEventList>
     8cc:	81 30       	cpi	r24, 0x01	; 1
     8ce:	09 f4       	brne	.+2      	; 0x8d2 <xQueueGenericSend+0x5e>
     8d0:	91 dd       	rcall	.-1246   	; 0x3f4 <vPortYield>
     8d2:	0f 90       	pop	r0
     8d4:	0f be       	out	0x3f, r0	; 63
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	47 c0       	rjmp	.+142    	; 0x968 <xQueueGenericSend+0xf4>
     8da:	ec 81       	ldd	r30, Y+4	; 0x04
     8dc:	fd 81       	ldd	r31, Y+5	; 0x05
     8de:	ef 2b       	or	r30, r31
     8e0:	21 f4       	brne	.+8      	; 0x8ea <xQueueGenericSend+0x76>
     8e2:	0f 90       	pop	r0
     8e4:	0f be       	out	0x3f, r0	; 63
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	3f c0       	rjmp	.+126    	; 0x968 <xQueueGenericSend+0xf4>
     8ea:	b1 10       	cpse	r11, r1
     8ec:	05 c0       	rjmp	.+10     	; 0x8f8 <xQueueGenericSend+0x84>
     8ee:	ce 01       	movw	r24, r28
     8f0:	01 96       	adiw	r24, 0x01	; 1
     8f2:	ea d4       	rcall	.+2516   	; 0x12c8 <vTaskSetTimeOutState>
     8f4:	bb 24       	eor	r11, r11
     8f6:	b3 94       	inc	r11
     8f8:	0f 90       	pop	r0
     8fa:	0f be       	out	0x3f, r0	; 63
     8fc:	91 d2       	rcall	.+1314   	; 0xe20 <vTaskSuspendAll>
     8fe:	0f b6       	in	r0, 0x3f	; 63
     900:	f8 94       	cli
     902:	0f 92       	push	r0
     904:	f8 01       	movw	r30, r16
     906:	85 8d       	ldd	r24, Z+29	; 0x1d
     908:	8f 3f       	cpi	r24, 0xFF	; 255
     90a:	09 f4       	brne	.+2      	; 0x90e <xQueueGenericSend+0x9a>
     90c:	15 8e       	std	Z+29, r1	; 0x1d
     90e:	f8 01       	movw	r30, r16
     910:	86 8d       	ldd	r24, Z+30	; 0x1e
     912:	8f 3f       	cpi	r24, 0xFF	; 255
     914:	09 f4       	brne	.+2      	; 0x918 <xQueueGenericSend+0xa4>
     916:	16 8e       	std	Z+30, r1	; 0x1e
     918:	0f 90       	pop	r0
     91a:	0f be       	out	0x3f, r0	; 63
     91c:	be 01       	movw	r22, r28
     91e:	6c 5f       	subi	r22, 0xFC	; 252
     920:	7f 4f       	sbci	r23, 0xFF	; 255
     922:	ce 01       	movw	r24, r28
     924:	01 96       	adiw	r24, 0x01	; 1
     926:	db d4       	rcall	.+2486   	; 0x12de <xTaskCheckForTimeOut>
     928:	81 11       	cpse	r24, r1
     92a:	1a c0       	rjmp	.+52     	; 0x960 <xQueueGenericSend+0xec>
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	0f 92       	push	r0
     932:	f8 01       	movw	r30, r16
     934:	92 8d       	ldd	r25, Z+26	; 0x1a
     936:	0f 90       	pop	r0
     938:	0f be       	out	0x3f, r0	; 63
     93a:	f8 01       	movw	r30, r16
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	98 13       	cpse	r25, r24
     940:	0b c0       	rjmp	.+22     	; 0x958 <xQueueGenericSend+0xe4>
     942:	6c 81       	ldd	r22, Y+4	; 0x04
     944:	7d 81       	ldd	r23, Y+5	; 0x05
     946:	c7 01       	movw	r24, r14
     948:	3c d4       	rcall	.+2168   	; 0x11c2 <vTaskPlaceOnEventList>
     94a:	c8 01       	movw	r24, r16
     94c:	03 df       	rcall	.-506    	; 0x754 <prvUnlockQueue>
     94e:	39 d3       	rcall	.+1650   	; 0xfc2 <xTaskResumeAll>
     950:	81 11       	cpse	r24, r1
     952:	a9 cf       	rjmp	.-174    	; 0x8a6 <xQueueGenericSend+0x32>
     954:	4f dd       	rcall	.-1378   	; 0x3f4 <vPortYield>
     956:	a7 cf       	rjmp	.-178    	; 0x8a6 <xQueueGenericSend+0x32>
     958:	c8 01       	movw	r24, r16
     95a:	fc de       	rcall	.-520    	; 0x754 <prvUnlockQueue>
     95c:	32 d3       	rcall	.+1636   	; 0xfc2 <xTaskResumeAll>
     95e:	a3 cf       	rjmp	.-186    	; 0x8a6 <xQueueGenericSend+0x32>
     960:	c8 01       	movw	r24, r16
     962:	f8 de       	rcall	.-528    	; 0x754 <prvUnlockQueue>
     964:	2e d3       	rcall	.+1628   	; 0xfc2 <xTaskResumeAll>
     966:	80 e0       	ldi	r24, 0x00	; 0
     968:	25 96       	adiw	r28, 0x05	; 5
     96a:	cd bf       	out	0x3d, r28	; 61
     96c:	de bf       	out	0x3e, r29	; 62
     96e:	df 91       	pop	r29
     970:	cf 91       	pop	r28
     972:	1f 91       	pop	r17
     974:	0f 91       	pop	r16
     976:	ff 90       	pop	r15
     978:	ef 90       	pop	r14
     97a:	df 90       	pop	r13
     97c:	cf 90       	pop	r12
     97e:	bf 90       	pop	r11
     980:	af 90       	pop	r10
     982:	08 95       	ret

00000984 <xQueueGenericSendFromISR>:
     984:	0f 93       	push	r16
     986:	1f 93       	push	r17
     988:	cf 93       	push	r28
     98a:	df 93       	push	r29
     98c:	ec 01       	movw	r28, r24
     98e:	8a 01       	movw	r16, r20
     990:	9a 8d       	ldd	r25, Y+26	; 0x1a
     992:	8b 8d       	ldd	r24, Y+27	; 0x1b
     994:	98 17       	cp	r25, r24
     996:	b0 f4       	brcc	.+44     	; 0x9c4 <xQueueGenericSendFromISR+0x40>
     998:	42 2f       	mov	r20, r18
     99a:	ce 01       	movw	r24, r28
     99c:	76 de       	rcall	.-788    	; 0x68a <prvCopyDataToQueue>
     99e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     9a0:	8f 3f       	cpi	r24, 0xFF	; 255
     9a2:	61 f4       	brne	.+24     	; 0x9bc <xQueueGenericSendFromISR+0x38>
     9a4:	89 89       	ldd	r24, Y+17	; 0x11
     9a6:	88 23       	and	r24, r24
     9a8:	79 f0       	breq	.+30     	; 0x9c8 <xQueueGenericSendFromISR+0x44>
     9aa:	ce 01       	movw	r24, r28
     9ac:	41 96       	adiw	r24, 0x11	; 17
     9ae:	4b d4       	rcall	.+2198   	; 0x1246 <xTaskRemoveFromEventList>
     9b0:	88 23       	and	r24, r24
     9b2:	61 f0       	breq	.+24     	; 0x9cc <xQueueGenericSendFromISR+0x48>
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	f8 01       	movw	r30, r16
     9b8:	80 83       	st	Z, r24
     9ba:	09 c0       	rjmp	.+18     	; 0x9ce <xQueueGenericSendFromISR+0x4a>
     9bc:	8f 5f       	subi	r24, 0xFF	; 255
     9be:	8e 8f       	std	Y+30, r24	; 0x1e
     9c0:	81 e0       	ldi	r24, 0x01	; 1
     9c2:	05 c0       	rjmp	.+10     	; 0x9ce <xQueueGenericSendFromISR+0x4a>
     9c4:	80 e0       	ldi	r24, 0x00	; 0
     9c6:	03 c0       	rjmp	.+6      	; 0x9ce <xQueueGenericSendFromISR+0x4a>
     9c8:	81 e0       	ldi	r24, 0x01	; 1
     9ca:	01 c0       	rjmp	.+2      	; 0x9ce <xQueueGenericSendFromISR+0x4a>
     9cc:	81 e0       	ldi	r24, 0x01	; 1
     9ce:	df 91       	pop	r29
     9d0:	cf 91       	pop	r28
     9d2:	1f 91       	pop	r17
     9d4:	0f 91       	pop	r16
     9d6:	08 95       	ret

000009d8 <xQueueGenericReceive>:
     9d8:	af 92       	push	r10
     9da:	bf 92       	push	r11
     9dc:	cf 92       	push	r12
     9de:	df 92       	push	r13
     9e0:	ef 92       	push	r14
     9e2:	ff 92       	push	r15
     9e4:	0f 93       	push	r16
     9e6:	1f 93       	push	r17
     9e8:	cf 93       	push	r28
     9ea:	df 93       	push	r29
     9ec:	cd b7       	in	r28, 0x3d	; 61
     9ee:	de b7       	in	r29, 0x3e	; 62
     9f0:	25 97       	sbiw	r28, 0x05	; 5
     9f2:	cd bf       	out	0x3d, r28	; 61
     9f4:	de bf       	out	0x3e, r29	; 62
     9f6:	8c 01       	movw	r16, r24
     9f8:	6b 01       	movw	r12, r22
     9fa:	4c 83       	std	Y+4, r20	; 0x04
     9fc:	5d 83       	std	Y+5, r21	; 0x05
     9fe:	b2 2e       	mov	r11, r18
     a00:	a1 2c       	mov	r10, r1
     a02:	7c 01       	movw	r14, r24
     a04:	81 e1       	ldi	r24, 0x11	; 17
     a06:	e8 0e       	add	r14, r24
     a08:	f1 1c       	adc	r15, r1
     a0a:	0f b6       	in	r0, 0x3f	; 63
     a0c:	f8 94       	cli
     a0e:	0f 92       	push	r0
     a10:	f8 01       	movw	r30, r16
     a12:	82 8d       	ldd	r24, Z+26	; 0x1a
     a14:	88 23       	and	r24, r24
     a16:	69 f1       	breq	.+90     	; 0xa72 <xQueueGenericReceive+0x9a>
     a18:	e6 80       	ldd	r14, Z+6	; 0x06
     a1a:	f7 80       	ldd	r15, Z+7	; 0x07
     a1c:	b6 01       	movw	r22, r12
     a1e:	c8 01       	movw	r24, r16
     a20:	7f de       	rcall	.-770    	; 0x720 <prvCopyDataFromQueue>
     a22:	b1 10       	cpse	r11, r1
     a24:	17 c0       	rjmp	.+46     	; 0xa54 <xQueueGenericReceive+0x7c>
     a26:	f8 01       	movw	r30, r16
     a28:	82 8d       	ldd	r24, Z+26	; 0x1a
     a2a:	81 50       	subi	r24, 0x01	; 1
     a2c:	82 8f       	std	Z+26, r24	; 0x1a
     a2e:	80 81       	ld	r24, Z
     a30:	91 81       	ldd	r25, Z+1	; 0x01
     a32:	89 2b       	or	r24, r25
     a34:	21 f4       	brne	.+8      	; 0xa3e <xQueueGenericReceive+0x66>
     a36:	95 d4       	rcall	.+2346   	; 0x1362 <xTaskGetCurrentTaskHandle>
     a38:	f8 01       	movw	r30, r16
     a3a:	82 83       	std	Z+2, r24	; 0x02
     a3c:	93 83       	std	Z+3, r25	; 0x03
     a3e:	f8 01       	movw	r30, r16
     a40:	80 85       	ldd	r24, Z+8	; 0x08
     a42:	88 23       	and	r24, r24
     a44:	91 f0       	breq	.+36     	; 0xa6a <xQueueGenericReceive+0x92>
     a46:	c8 01       	movw	r24, r16
     a48:	08 96       	adiw	r24, 0x08	; 8
     a4a:	fd d3       	rcall	.+2042   	; 0x1246 <xTaskRemoveFromEventList>
     a4c:	81 30       	cpi	r24, 0x01	; 1
     a4e:	69 f4       	brne	.+26     	; 0xa6a <xQueueGenericReceive+0x92>
     a50:	d1 dc       	rcall	.-1630   	; 0x3f4 <vPortYield>
     a52:	0b c0       	rjmp	.+22     	; 0xa6a <xQueueGenericReceive+0x92>
     a54:	f8 01       	movw	r30, r16
     a56:	e6 82       	std	Z+6, r14	; 0x06
     a58:	f7 82       	std	Z+7, r15	; 0x07
     a5a:	81 89       	ldd	r24, Z+17	; 0x11
     a5c:	88 23       	and	r24, r24
     a5e:	29 f0       	breq	.+10     	; 0xa6a <xQueueGenericReceive+0x92>
     a60:	c8 01       	movw	r24, r16
     a62:	41 96       	adiw	r24, 0x11	; 17
     a64:	f0 d3       	rcall	.+2016   	; 0x1246 <xTaskRemoveFromEventList>
     a66:	81 11       	cpse	r24, r1
     a68:	c5 dc       	rcall	.-1654   	; 0x3f4 <vPortYield>
     a6a:	0f 90       	pop	r0
     a6c:	0f be       	out	0x3f, r0	; 63
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	53 c0       	rjmp	.+166    	; 0xb18 <xQueueGenericReceive+0x140>
     a72:	4c 81       	ldd	r20, Y+4	; 0x04
     a74:	5d 81       	ldd	r21, Y+5	; 0x05
     a76:	45 2b       	or	r20, r21
     a78:	21 f4       	brne	.+8      	; 0xa82 <xQueueGenericReceive+0xaa>
     a7a:	0f 90       	pop	r0
     a7c:	0f be       	out	0x3f, r0	; 63
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	4b c0       	rjmp	.+150    	; 0xb18 <xQueueGenericReceive+0x140>
     a82:	a1 10       	cpse	r10, r1
     a84:	05 c0       	rjmp	.+10     	; 0xa90 <xQueueGenericReceive+0xb8>
     a86:	ce 01       	movw	r24, r28
     a88:	01 96       	adiw	r24, 0x01	; 1
     a8a:	1e d4       	rcall	.+2108   	; 0x12c8 <vTaskSetTimeOutState>
     a8c:	aa 24       	eor	r10, r10
     a8e:	a3 94       	inc	r10
     a90:	0f 90       	pop	r0
     a92:	0f be       	out	0x3f, r0	; 63
     a94:	c5 d1       	rcall	.+906    	; 0xe20 <vTaskSuspendAll>
     a96:	0f b6       	in	r0, 0x3f	; 63
     a98:	f8 94       	cli
     a9a:	0f 92       	push	r0
     a9c:	f8 01       	movw	r30, r16
     a9e:	85 8d       	ldd	r24, Z+29	; 0x1d
     aa0:	8f 3f       	cpi	r24, 0xFF	; 255
     aa2:	09 f4       	brne	.+2      	; 0xaa6 <xQueueGenericReceive+0xce>
     aa4:	15 8e       	std	Z+29, r1	; 0x1d
     aa6:	f8 01       	movw	r30, r16
     aa8:	86 8d       	ldd	r24, Z+30	; 0x1e
     aaa:	8f 3f       	cpi	r24, 0xFF	; 255
     aac:	09 f4       	brne	.+2      	; 0xab0 <xQueueGenericReceive+0xd8>
     aae:	16 8e       	std	Z+30, r1	; 0x1e
     ab0:	0f 90       	pop	r0
     ab2:	0f be       	out	0x3f, r0	; 63
     ab4:	be 01       	movw	r22, r28
     ab6:	6c 5f       	subi	r22, 0xFC	; 252
     ab8:	7f 4f       	sbci	r23, 0xFF	; 255
     aba:	ce 01       	movw	r24, r28
     abc:	01 96       	adiw	r24, 0x01	; 1
     abe:	0f d4       	rcall	.+2078   	; 0x12de <xTaskCheckForTimeOut>
     ac0:	81 11       	cpse	r24, r1
     ac2:	26 c0       	rjmp	.+76     	; 0xb10 <xQueueGenericReceive+0x138>
     ac4:	0f b6       	in	r0, 0x3f	; 63
     ac6:	f8 94       	cli
     ac8:	0f 92       	push	r0
     aca:	f8 01       	movw	r30, r16
     acc:	82 8d       	ldd	r24, Z+26	; 0x1a
     ace:	0f 90       	pop	r0
     ad0:	0f be       	out	0x3f, r0	; 63
     ad2:	81 11       	cpse	r24, r1
     ad4:	19 c0       	rjmp	.+50     	; 0xb08 <xQueueGenericReceive+0x130>
     ad6:	f8 01       	movw	r30, r16
     ad8:	80 81       	ld	r24, Z
     ada:	91 81       	ldd	r25, Z+1	; 0x01
     adc:	89 2b       	or	r24, r25
     ade:	49 f4       	brne	.+18     	; 0xaf2 <xQueueGenericReceive+0x11a>
     ae0:	0f b6       	in	r0, 0x3f	; 63
     ae2:	f8 94       	cli
     ae4:	0f 92       	push	r0
     ae6:	f8 01       	movw	r30, r16
     ae8:	82 81       	ldd	r24, Z+2	; 0x02
     aea:	93 81       	ldd	r25, Z+3	; 0x03
     aec:	4d d4       	rcall	.+2202   	; 0x1388 <vTaskPriorityInherit>
     aee:	0f 90       	pop	r0
     af0:	0f be       	out	0x3f, r0	; 63
     af2:	6c 81       	ldd	r22, Y+4	; 0x04
     af4:	7d 81       	ldd	r23, Y+5	; 0x05
     af6:	c7 01       	movw	r24, r14
     af8:	64 d3       	rcall	.+1736   	; 0x11c2 <vTaskPlaceOnEventList>
     afa:	c8 01       	movw	r24, r16
     afc:	2b de       	rcall	.-938    	; 0x754 <prvUnlockQueue>
     afe:	61 d2       	rcall	.+1218   	; 0xfc2 <xTaskResumeAll>
     b00:	81 11       	cpse	r24, r1
     b02:	83 cf       	rjmp	.-250    	; 0xa0a <xQueueGenericReceive+0x32>
     b04:	77 dc       	rcall	.-1810   	; 0x3f4 <vPortYield>
     b06:	81 cf       	rjmp	.-254    	; 0xa0a <xQueueGenericReceive+0x32>
     b08:	c8 01       	movw	r24, r16
     b0a:	24 de       	rcall	.-952    	; 0x754 <prvUnlockQueue>
     b0c:	5a d2       	rcall	.+1204   	; 0xfc2 <xTaskResumeAll>
     b0e:	7d cf       	rjmp	.-262    	; 0xa0a <xQueueGenericReceive+0x32>
     b10:	c8 01       	movw	r24, r16
     b12:	20 de       	rcall	.-960    	; 0x754 <prvUnlockQueue>
     b14:	56 d2       	rcall	.+1196   	; 0xfc2 <xTaskResumeAll>
     b16:	80 e0       	ldi	r24, 0x00	; 0
     b18:	25 96       	adiw	r28, 0x05	; 5
     b1a:	cd bf       	out	0x3d, r28	; 61
     b1c:	de bf       	out	0x3e, r29	; 62
     b1e:	df 91       	pop	r29
     b20:	cf 91       	pop	r28
     b22:	1f 91       	pop	r17
     b24:	0f 91       	pop	r16
     b26:	ff 90       	pop	r15
     b28:	ef 90       	pop	r14
     b2a:	df 90       	pop	r13
     b2c:	cf 90       	pop	r12
     b2e:	bf 90       	pop	r11
     b30:	af 90       	pop	r10
     b32:	08 95       	ret

00000b34 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
     b38:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
     b3a:	0f b6       	in	r0, 0x3f	; 63
     b3c:	f8 94       	cli
     b3e:	0f 92       	push	r0
     b40:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b42:	8f 3f       	cpi	r24, 0xFF	; 255
     b44:	09 f4       	brne	.+2      	; 0xb48 <vQueueWaitForMessageRestricted+0x14>
     b46:	1d 8e       	std	Y+29, r1	; 0x1d
     b48:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b4a:	8f 3f       	cpi	r24, 0xFF	; 255
     b4c:	09 f4       	brne	.+2      	; 0xb50 <vQueueWaitForMessageRestricted+0x1c>
     b4e:	1e 8e       	std	Y+30, r1	; 0x1e
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
     b54:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b56:	81 11       	cpse	r24, r1
     b58:	03 c0       	rjmp	.+6      	; 0xb60 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b5a:	ce 01       	movw	r24, r28
     b5c:	41 96       	adiw	r24, 0x11	; 17
     b5e:	59 d3       	rcall	.+1714   	; 0x1212 <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
     b60:	ce 01       	movw	r24, r28
     b62:	f8 dd       	rcall	.-1040   	; 0x754 <prvUnlockQueue>
	}
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	08 95       	ret

00000b6a <prvIdleTask>:
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
     b6a:	c3 ec       	ldi	r28, 0xC3	; 195
     b6c:	d7 e3       	ldi	r29, 0x37	; 55
     b6e:	88 81       	ld	r24, Y
     b70:	82 30       	cpi	r24, 0x02	; 2
     b72:	e8 f3       	brcs	.-6      	; 0xb6e <prvIdleTask+0x4>
     b74:	3f dc       	rcall	.-1922   	; 0x3f4 <vPortYield>
     b76:	fb cf       	rjmp	.-10     	; 0xb6e <prvIdleTask+0x4>

00000b78 <prvAddCurrentTaskToDelayedList>:
     b78:	cf 93       	push	r28
     b7a:	df 93       	push	r29
     b7c:	ec 01       	movw	r28, r24
     b7e:	e0 91 e7 37 	lds	r30, 0x37E7
     b82:	f0 91 e8 37 	lds	r31, 0x37E8
     b86:	82 83       	std	Z+2, r24	; 0x02
     b88:	93 83       	std	Z+3, r25	; 0x03
     b8a:	80 91 98 37 	lds	r24, 0x3798
     b8e:	90 91 99 37 	lds	r25, 0x3799
     b92:	c8 17       	cp	r28, r24
     b94:	d9 07       	cpc	r29, r25
     b96:	60 f4       	brcc	.+24     	; 0xbb0 <prvAddCurrentTaskToDelayedList+0x38>
     b98:	60 91 e7 37 	lds	r22, 0x37E7
     b9c:	70 91 e8 37 	lds	r23, 0x37E8
     ba0:	80 91 ad 37 	lds	r24, 0x37AD
     ba4:	90 91 ae 37 	lds	r25, 0x37AE
     ba8:	6e 5f       	subi	r22, 0xFE	; 254
     baa:	7f 4f       	sbci	r23, 0xFF	; 255
     bac:	0d dd       	rcall	.-1510   	; 0x5c8 <vListInsert>
     bae:	16 c0       	rjmp	.+44     	; 0xbdc <prvAddCurrentTaskToDelayedList+0x64>
     bb0:	60 91 e7 37 	lds	r22, 0x37E7
     bb4:	70 91 e8 37 	lds	r23, 0x37E8
     bb8:	80 91 af 37 	lds	r24, 0x37AF
     bbc:	90 91 b0 37 	lds	r25, 0x37B0
     bc0:	6e 5f       	subi	r22, 0xFE	; 254
     bc2:	7f 4f       	sbci	r23, 0xFF	; 255
     bc4:	01 dd       	rcall	.-1534   	; 0x5c8 <vListInsert>
     bc6:	80 91 00 20 	lds	r24, 0x2000
     bca:	90 91 01 20 	lds	r25, 0x2001
     bce:	c8 17       	cp	r28, r24
     bd0:	d9 07       	cpc	r29, r25
     bd2:	20 f4       	brcc	.+8      	; 0xbdc <prvAddCurrentTaskToDelayedList+0x64>
     bd4:	c0 93 00 20 	sts	0x2000, r28
     bd8:	d0 93 01 20 	sts	0x2001, r29
     bdc:	df 91       	pop	r29
     bde:	cf 91       	pop	r28
     be0:	08 95       	ret

00000be2 <xTaskGenericCreate>:
     be2:	4f 92       	push	r4
     be4:	5f 92       	push	r5
     be6:	6f 92       	push	r6
     be8:	7f 92       	push	r7
     bea:	8f 92       	push	r8
     bec:	9f 92       	push	r9
     bee:	af 92       	push	r10
     bf0:	bf 92       	push	r11
     bf2:	cf 92       	push	r12
     bf4:	df 92       	push	r13
     bf6:	ef 92       	push	r14
     bf8:	ff 92       	push	r15
     bfa:	0f 93       	push	r16
     bfc:	1f 93       	push	r17
     bfe:	cf 93       	push	r28
     c00:	df 93       	push	r29
     c02:	4c 01       	movw	r8, r24
     c04:	3b 01       	movw	r6, r22
     c06:	5a 01       	movw	r10, r20
     c08:	29 01       	movw	r4, r18
     c0a:	82 e2       	ldi	r24, 0x22	; 34
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	1d db       	rcall	.-2502   	; 0x24a <pvPortMalloc>
     c10:	ec 01       	movw	r28, r24
     c12:	00 97       	sbiw	r24, 0x00	; 0
     c14:	09 f4       	brne	.+2      	; 0xc18 <xTaskGenericCreate+0x36>
     c16:	c6 c0       	rjmp	.+396    	; 0xda4 <xTaskGenericCreate+0x1c2>
     c18:	c1 14       	cp	r12, r1
     c1a:	d1 04       	cpc	r13, r1
     c1c:	09 f0       	breq	.+2      	; 0xc20 <xTaskGenericCreate+0x3e>
     c1e:	be c0       	rjmp	.+380    	; 0xd9c <xTaskGenericCreate+0x1ba>
     c20:	c5 01       	movw	r24, r10
     c22:	13 db       	rcall	.-2522   	; 0x24a <pvPortMalloc>
     c24:	8f 8b       	std	Y+23, r24	; 0x17
     c26:	98 8f       	std	Y+24, r25	; 0x18
     c28:	00 97       	sbiw	r24, 0x00	; 0
     c2a:	19 f4       	brne	.+6      	; 0xc32 <xTaskGenericCreate+0x50>
     c2c:	ce 01       	movw	r24, r28
     c2e:	31 db       	rcall	.-2462   	; 0x292 <vPortFree>
     c30:	b9 c0       	rjmp	.+370    	; 0xda4 <xTaskGenericCreate+0x1c2>
     c32:	a5 01       	movw	r20, r10
     c34:	65 ea       	ldi	r22, 0xA5	; 165
     c36:	70 e0       	ldi	r23, 0x00	; 0
     c38:	85 d6       	rcall	.+3338   	; 0x1944 <memset>
     c3a:	81 e0       	ldi	r24, 0x01	; 1
     c3c:	a8 1a       	sub	r10, r24
     c3e:	b1 08       	sbc	r11, r1
     c40:	8f 89       	ldd	r24, Y+23	; 0x17
     c42:	98 8d       	ldd	r25, Y+24	; 0x18
     c44:	a8 0e       	add	r10, r24
     c46:	b9 1e       	adc	r11, r25
     c48:	48 e0       	ldi	r20, 0x08	; 8
     c4a:	50 e0       	ldi	r21, 0x00	; 0
     c4c:	b3 01       	movw	r22, r6
     c4e:	ce 01       	movw	r24, r28
     c50:	49 96       	adiw	r24, 0x19	; 25
     c52:	7f d6       	rcall	.+3326   	; 0x1952 <strncpy>
     c54:	18 a2       	std	Y+32, r1	; 0x20
     c56:	10 2f       	mov	r17, r16
     c58:	04 30       	cpi	r16, 0x04	; 4
     c5a:	08 f0       	brcs	.+2      	; 0xc5e <xTaskGenericCreate+0x7c>
     c5c:	13 e0       	ldi	r17, 0x03	; 3
     c5e:	1e 8b       	std	Y+22, r17	; 0x16
     c60:	19 a3       	std	Y+33, r17	; 0x21
     c62:	6e 01       	movw	r12, r28
     c64:	e2 e0       	ldi	r30, 0x02	; 2
     c66:	ce 0e       	add	r12, r30
     c68:	d1 1c       	adc	r13, r1
     c6a:	c6 01       	movw	r24, r12
     c6c:	82 dc       	rcall	.-1788   	; 0x572 <vListInitialiseItem>
     c6e:	ce 01       	movw	r24, r28
     c70:	0c 96       	adiw	r24, 0x0c	; 12
     c72:	7f dc       	rcall	.-1794   	; 0x572 <vListInitialiseItem>
     c74:	c8 87       	std	Y+8, r28	; 0x08
     c76:	d9 87       	std	Y+9, r29	; 0x09
     c78:	84 e0       	ldi	r24, 0x04	; 4
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	81 1b       	sub	r24, r17
     c7e:	91 09       	sbc	r25, r1
     c80:	8c 87       	std	Y+12, r24	; 0x0c
     c82:	9d 87       	std	Y+13, r25	; 0x0d
     c84:	ca 8b       	std	Y+18, r28	; 0x12
     c86:	db 8b       	std	Y+19, r29	; 0x13
     c88:	a2 01       	movw	r20, r4
     c8a:	b4 01       	movw	r22, r8
     c8c:	c5 01       	movw	r24, r10
     c8e:	02 db       	rcall	.-2556   	; 0x294 <pxPortInitialiseStack>
     c90:	88 83       	st	Y, r24
     c92:	99 83       	std	Y+1, r25	; 0x01
     c94:	e1 14       	cp	r14, r1
     c96:	f1 04       	cpc	r15, r1
     c98:	19 f0       	breq	.+6      	; 0xca0 <xTaskGenericCreate+0xbe>
     c9a:	f7 01       	movw	r30, r14
     c9c:	c0 83       	st	Z, r28
     c9e:	d1 83       	std	Z+1, r29	; 0x01
     ca0:	0f b6       	in	r0, 0x3f	; 63
     ca2:	f8 94       	cli
     ca4:	0f 92       	push	r0
     ca6:	80 91 9a 37 	lds	r24, 0x379A
     caa:	8f 5f       	subi	r24, 0xFF	; 255
     cac:	80 93 9a 37 	sts	0x379A, r24
     cb0:	80 91 e7 37 	lds	r24, 0x37E7
     cb4:	90 91 e8 37 	lds	r25, 0x37E8
     cb8:	89 2b       	or	r24, r25
     cba:	69 f5       	brne	.+90     	; 0xd16 <xTaskGenericCreate+0x134>
     cbc:	c0 93 e7 37 	sts	0x37E7, r28
     cc0:	d0 93 e8 37 	sts	0x37E8, r29
     cc4:	80 91 9a 37 	lds	r24, 0x379A
     cc8:	81 30       	cpi	r24, 0x01	; 1
     cca:	a1 f5       	brne	.+104    	; 0xd34 <xTaskGenericCreate+0x152>
     ccc:	83 ec       	ldi	r24, 0xC3	; 195
     cce:	97 e3       	ldi	r25, 0x37	; 55
     cd0:	42 dc       	rcall	.-1916   	; 0x556 <vListInitialise>
     cd2:	8c ec       	ldi	r24, 0xCC	; 204
     cd4:	97 e3       	ldi	r25, 0x37	; 55
     cd6:	3f dc       	rcall	.-1922   	; 0x556 <vListInitialise>
     cd8:	85 ed       	ldi	r24, 0xD5	; 213
     cda:	97 e3       	ldi	r25, 0x37	; 55
     cdc:	3c dc       	rcall	.-1928   	; 0x556 <vListInitialise>
     cde:	8e ed       	ldi	r24, 0xDE	; 222
     ce0:	97 e3       	ldi	r25, 0x37	; 55
     ce2:	39 dc       	rcall	.-1934   	; 0x556 <vListInitialise>
     ce4:	8a eb       	ldi	r24, 0xBA	; 186
     ce6:	97 e3       	ldi	r25, 0x37	; 55
     ce8:	36 dc       	rcall	.-1940   	; 0x556 <vListInitialise>
     cea:	81 eb       	ldi	r24, 0xB1	; 177
     cec:	97 e3       	ldi	r25, 0x37	; 55
     cee:	33 dc       	rcall	.-1946   	; 0x556 <vListInitialise>
     cf0:	84 ea       	ldi	r24, 0xA4	; 164
     cf2:	97 e3       	ldi	r25, 0x37	; 55
     cf4:	30 dc       	rcall	.-1952   	; 0x556 <vListInitialise>
     cf6:	8b e9       	ldi	r24, 0x9B	; 155
     cf8:	97 e3       	ldi	r25, 0x37	; 55
     cfa:	2d dc       	rcall	.-1958   	; 0x556 <vListInitialise>
     cfc:	8a eb       	ldi	r24, 0xBA	; 186
     cfe:	97 e3       	ldi	r25, 0x37	; 55
     d00:	80 93 af 37 	sts	0x37AF, r24
     d04:	90 93 b0 37 	sts	0x37B0, r25
     d08:	81 eb       	ldi	r24, 0xB1	; 177
     d0a:	97 e3       	ldi	r25, 0x37	; 55
     d0c:	80 93 ad 37 	sts	0x37AD, r24
     d10:	90 93 ae 37 	sts	0x37AE, r25
     d14:	0f c0       	rjmp	.+30     	; 0xd34 <xTaskGenericCreate+0x152>
     d16:	80 91 95 37 	lds	r24, 0x3795
     d1a:	81 11       	cpse	r24, r1
     d1c:	0b c0       	rjmp	.+22     	; 0xd34 <xTaskGenericCreate+0x152>
     d1e:	e0 91 e7 37 	lds	r30, 0x37E7
     d22:	f0 91 e8 37 	lds	r31, 0x37E8
     d26:	86 89       	ldd	r24, Z+22	; 0x16
     d28:	08 17       	cp	r16, r24
     d2a:	20 f0       	brcs	.+8      	; 0xd34 <xTaskGenericCreate+0x152>
     d2c:	c0 93 e7 37 	sts	0x37E7, r28
     d30:	d0 93 e8 37 	sts	0x37E8, r29
     d34:	8e 89       	ldd	r24, Y+22	; 0x16
     d36:	90 91 97 37 	lds	r25, 0x3797
     d3a:	98 17       	cp	r25, r24
     d3c:	10 f4       	brcc	.+4      	; 0xd42 <xTaskGenericCreate+0x160>
     d3e:	80 93 97 37 	sts	0x3797, r24
     d42:	90 91 90 37 	lds	r25, 0x3790
     d46:	9f 5f       	subi	r25, 0xFF	; 255
     d48:	90 93 90 37 	sts	0x3790, r25
     d4c:	90 91 96 37 	lds	r25, 0x3796
     d50:	98 17       	cp	r25, r24
     d52:	10 f4       	brcc	.+4      	; 0xd58 <xTaskGenericCreate+0x176>
     d54:	80 93 96 37 	sts	0x3796, r24
     d58:	90 e0       	ldi	r25, 0x00	; 0
     d5a:	9c 01       	movw	r18, r24
     d5c:	22 0f       	add	r18, r18
     d5e:	33 1f       	adc	r19, r19
     d60:	22 0f       	add	r18, r18
     d62:	33 1f       	adc	r19, r19
     d64:	22 0f       	add	r18, r18
     d66:	33 1f       	adc	r19, r19
     d68:	82 0f       	add	r24, r18
     d6a:	93 1f       	adc	r25, r19
     d6c:	b6 01       	movw	r22, r12
     d6e:	8d 53       	subi	r24, 0x3D	; 61
     d70:	98 4c       	sbci	r25, 0xC8	; 200
     d72:	03 dc       	rcall	.-2042   	; 0x57a <vListInsertEnd>
     d74:	0f 90       	pop	r0
     d76:	0f be       	out	0x3f, r0	; 63
     d78:	80 91 95 37 	lds	r24, 0x3795
     d7c:	88 23       	and	r24, r24
     d7e:	51 f0       	breq	.+20     	; 0xd94 <xTaskGenericCreate+0x1b2>
     d80:	e0 91 e7 37 	lds	r30, 0x37E7
     d84:	f0 91 e8 37 	lds	r31, 0x37E8
     d88:	86 89       	ldd	r24, Z+22	; 0x16
     d8a:	80 17       	cp	r24, r16
     d8c:	28 f4       	brcc	.+10     	; 0xd98 <xTaskGenericCreate+0x1b6>
     d8e:	32 db       	rcall	.-2460   	; 0x3f4 <vPortYield>
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	09 c0       	rjmp	.+18     	; 0xda6 <xTaskGenericCreate+0x1c4>
     d94:	81 e0       	ldi	r24, 0x01	; 1
     d96:	07 c0       	rjmp	.+14     	; 0xda6 <xTaskGenericCreate+0x1c4>
     d98:	81 e0       	ldi	r24, 0x01	; 1
     d9a:	05 c0       	rjmp	.+10     	; 0xda6 <xTaskGenericCreate+0x1c4>
     d9c:	cf 8a       	std	Y+23, r12	; 0x17
     d9e:	d8 8e       	std	Y+24, r13	; 0x18
     da0:	c6 01       	movw	r24, r12
     da2:	47 cf       	rjmp	.-370    	; 0xc32 <xTaskGenericCreate+0x50>
     da4:	8f ef       	ldi	r24, 0xFF	; 255
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	1f 91       	pop	r17
     dac:	0f 91       	pop	r16
     dae:	ff 90       	pop	r15
     db0:	ef 90       	pop	r14
     db2:	df 90       	pop	r13
     db4:	cf 90       	pop	r12
     db6:	bf 90       	pop	r11
     db8:	af 90       	pop	r10
     dba:	9f 90       	pop	r9
     dbc:	8f 90       	pop	r8
     dbe:	7f 90       	pop	r7
     dc0:	6f 90       	pop	r6
     dc2:	5f 90       	pop	r5
     dc4:	4f 90       	pop	r4
     dc6:	08 95       	ret

00000dc8 <vTaskStartScheduler>:
     dc8:	af 92       	push	r10
     dca:	bf 92       	push	r11
     dcc:	cf 92       	push	r12
     dce:	df 92       	push	r13
     dd0:	ef 92       	push	r14
     dd2:	ff 92       	push	r15
     dd4:	0f 93       	push	r16
     dd6:	a1 2c       	mov	r10, r1
     dd8:	b1 2c       	mov	r11, r1
     dda:	c1 2c       	mov	r12, r1
     ddc:	d1 2c       	mov	r13, r1
     dde:	e1 2c       	mov	r14, r1
     de0:	f1 2c       	mov	r15, r1
     de2:	00 e0       	ldi	r16, 0x00	; 0
     de4:	20 e0       	ldi	r18, 0x00	; 0
     de6:	30 e0       	ldi	r19, 0x00	; 0
     de8:	46 e9       	ldi	r20, 0x96	; 150
     dea:	50 e0       	ldi	r21, 0x00	; 0
     dec:	62 e0       	ldi	r22, 0x02	; 2
     dee:	70 e2       	ldi	r23, 0x20	; 32
     df0:	85 eb       	ldi	r24, 0xB5	; 181
     df2:	95 e0       	ldi	r25, 0x05	; 5
     df4:	f6 de       	rcall	.-532    	; 0xbe2 <xTaskGenericCreate>
     df6:	81 30       	cpi	r24, 0x01	; 1
     df8:	59 f4       	brne	.+22     	; 0xe10 <vTaskStartScheduler+0x48>
     dfa:	9e d3       	rcall	.+1852   	; 0x1538 <xTimerCreateTimerTask>
     dfc:	81 30       	cpi	r24, 0x01	; 1
     dfe:	41 f4       	brne	.+16     	; 0xe10 <vTaskStartScheduler+0x48>
     e00:	f8 94       	cli
     e02:	80 93 95 37 	sts	0x3795, r24
     e06:	10 92 98 37 	sts	0x3798, r1
     e0a:	10 92 99 37 	sts	0x3799, r1
     e0e:	b0 da       	rcall	.-2720   	; 0x370 <xPortStartScheduler>
     e10:	0f 91       	pop	r16
     e12:	ff 90       	pop	r15
     e14:	ef 90       	pop	r14
     e16:	df 90       	pop	r13
     e18:	cf 90       	pop	r12
     e1a:	bf 90       	pop	r11
     e1c:	af 90       	pop	r10
     e1e:	08 95       	ret

00000e20 <vTaskSuspendAll>:
     e20:	80 91 94 37 	lds	r24, 0x3794
     e24:	8f 5f       	subi	r24, 0xFF	; 255
     e26:	80 93 94 37 	sts	0x3794, r24
     e2a:	08 95       	ret

00000e2c <xTaskGetTickCount>:
     e2c:	0f b6       	in	r0, 0x3f	; 63
     e2e:	f8 94       	cli
     e30:	0f 92       	push	r0
     e32:	80 91 98 37 	lds	r24, 0x3798
     e36:	90 91 99 37 	lds	r25, 0x3799
     e3a:	0f 90       	pop	r0
     e3c:	0f be       	out	0x3f, r0	; 63
     e3e:	08 95       	ret

00000e40 <vTaskIncrementTick>:
     e40:	0f 93       	push	r16
     e42:	1f 93       	push	r17
     e44:	cf 93       	push	r28
     e46:	df 93       	push	r29
     e48:	80 91 94 37 	lds	r24, 0x3794
     e4c:	81 11       	cpse	r24, r1
     e4e:	af c0       	rjmp	.+350    	; 0xfae <vTaskIncrementTick+0x16e>
     e50:	80 91 98 37 	lds	r24, 0x3798
     e54:	90 91 99 37 	lds	r25, 0x3799
     e58:	01 96       	adiw	r24, 0x01	; 1
     e5a:	80 93 98 37 	sts	0x3798, r24
     e5e:	90 93 99 37 	sts	0x3799, r25
     e62:	80 91 98 37 	lds	r24, 0x3798
     e66:	90 91 99 37 	lds	r25, 0x3799
     e6a:	89 2b       	or	r24, r25
     e6c:	99 f5       	brne	.+102    	; 0xed4 <vTaskIncrementTick+0x94>
     e6e:	80 91 af 37 	lds	r24, 0x37AF
     e72:	90 91 b0 37 	lds	r25, 0x37B0
     e76:	20 91 ad 37 	lds	r18, 0x37AD
     e7a:	30 91 ae 37 	lds	r19, 0x37AE
     e7e:	20 93 af 37 	sts	0x37AF, r18
     e82:	30 93 b0 37 	sts	0x37B0, r19
     e86:	80 93 ad 37 	sts	0x37AD, r24
     e8a:	90 93 ae 37 	sts	0x37AE, r25
     e8e:	80 91 91 37 	lds	r24, 0x3791
     e92:	8f 5f       	subi	r24, 0xFF	; 255
     e94:	80 93 91 37 	sts	0x3791, r24
     e98:	e0 91 af 37 	lds	r30, 0x37AF
     e9c:	f0 91 b0 37 	lds	r31, 0x37B0
     ea0:	80 81       	ld	r24, Z
     ea2:	81 11       	cpse	r24, r1
     ea4:	07 c0       	rjmp	.+14     	; 0xeb4 <vTaskIncrementTick+0x74>
     ea6:	8f ef       	ldi	r24, 0xFF	; 255
     ea8:	9f ef       	ldi	r25, 0xFF	; 255
     eaa:	80 93 00 20 	sts	0x2000, r24
     eae:	90 93 01 20 	sts	0x2001, r25
     eb2:	10 c0       	rjmp	.+32     	; 0xed4 <vTaskIncrementTick+0x94>
     eb4:	e0 91 af 37 	lds	r30, 0x37AF
     eb8:	f0 91 b0 37 	lds	r31, 0x37B0
     ebc:	05 80       	ldd	r0, Z+5	; 0x05
     ebe:	f6 81       	ldd	r31, Z+6	; 0x06
     ec0:	e0 2d       	mov	r30, r0
     ec2:	06 80       	ldd	r0, Z+6	; 0x06
     ec4:	f7 81       	ldd	r31, Z+7	; 0x07
     ec6:	e0 2d       	mov	r30, r0
     ec8:	82 81       	ldd	r24, Z+2	; 0x02
     eca:	93 81       	ldd	r25, Z+3	; 0x03
     ecc:	80 93 00 20 	sts	0x2000, r24
     ed0:	90 93 01 20 	sts	0x2001, r25
     ed4:	20 91 98 37 	lds	r18, 0x3798
     ed8:	30 91 99 37 	lds	r19, 0x3799
     edc:	80 91 00 20 	lds	r24, 0x2000
     ee0:	90 91 01 20 	lds	r25, 0x2001
     ee4:	28 17       	cp	r18, r24
     ee6:	39 07       	cpc	r19, r25
     ee8:	08 f4       	brcc	.+2      	; 0xeec <vTaskIncrementTick+0xac>
     eea:	66 c0       	rjmp	.+204    	; 0xfb8 <vTaskIncrementTick+0x178>
     eec:	e0 91 af 37 	lds	r30, 0x37AF
     ef0:	f0 91 b0 37 	lds	r31, 0x37B0
     ef4:	80 81       	ld	r24, Z
     ef6:	88 23       	and	r24, r24
     ef8:	99 f0       	breq	.+38     	; 0xf20 <vTaskIncrementTick+0xe0>
     efa:	e0 91 af 37 	lds	r30, 0x37AF
     efe:	f0 91 b0 37 	lds	r31, 0x37B0
     f02:	05 80       	ldd	r0, Z+5	; 0x05
     f04:	f6 81       	ldd	r31, Z+6	; 0x06
     f06:	e0 2d       	mov	r30, r0
     f08:	c6 81       	ldd	r28, Z+6	; 0x06
     f0a:	d7 81       	ldd	r29, Z+7	; 0x07
     f0c:	8a 81       	ldd	r24, Y+2	; 0x02
     f0e:	9b 81       	ldd	r25, Y+3	; 0x03
     f10:	20 91 98 37 	lds	r18, 0x3798
     f14:	30 91 99 37 	lds	r19, 0x3799
     f18:	28 17       	cp	r18, r24
     f1a:	39 07       	cpc	r19, r25
     f1c:	f8 f4       	brcc	.+62     	; 0xf5c <vTaskIncrementTick+0x11c>
     f1e:	19 c0       	rjmp	.+50     	; 0xf52 <vTaskIncrementTick+0x112>
     f20:	8f ef       	ldi	r24, 0xFF	; 255
     f22:	9f ef       	ldi	r25, 0xFF	; 255
     f24:	80 93 00 20 	sts	0x2000, r24
     f28:	90 93 01 20 	sts	0x2001, r25
     f2c:	45 c0       	rjmp	.+138    	; 0xfb8 <vTaskIncrementTick+0x178>
     f2e:	e0 91 af 37 	lds	r30, 0x37AF
     f32:	f0 91 b0 37 	lds	r31, 0x37B0
     f36:	05 80       	ldd	r0, Z+5	; 0x05
     f38:	f6 81       	ldd	r31, Z+6	; 0x06
     f3a:	e0 2d       	mov	r30, r0
     f3c:	c6 81       	ldd	r28, Z+6	; 0x06
     f3e:	d7 81       	ldd	r29, Z+7	; 0x07
     f40:	8a 81       	ldd	r24, Y+2	; 0x02
     f42:	9b 81       	ldd	r25, Y+3	; 0x03
     f44:	20 91 98 37 	lds	r18, 0x3798
     f48:	30 91 99 37 	lds	r19, 0x3799
     f4c:	28 17       	cp	r18, r24
     f4e:	39 07       	cpc	r19, r25
     f50:	28 f4       	brcc	.+10     	; 0xf5c <vTaskIncrementTick+0x11c>
     f52:	80 93 00 20 	sts	0x2000, r24
     f56:	90 93 01 20 	sts	0x2001, r25
     f5a:	2e c0       	rjmp	.+92     	; 0xfb8 <vTaskIncrementTick+0x178>
     f5c:	8e 01       	movw	r16, r28
     f5e:	0e 5f       	subi	r16, 0xFE	; 254
     f60:	1f 4f       	sbci	r17, 0xFF	; 255
     f62:	c8 01       	movw	r24, r16
     f64:	6c db       	rcall	.-2344   	; 0x63e <vListRemove>
     f66:	8c 89       	ldd	r24, Y+20	; 0x14
     f68:	9d 89       	ldd	r25, Y+21	; 0x15
     f6a:	89 2b       	or	r24, r25
     f6c:	19 f0       	breq	.+6      	; 0xf74 <vTaskIncrementTick+0x134>
     f6e:	ce 01       	movw	r24, r28
     f70:	0c 96       	adiw	r24, 0x0c	; 12
     f72:	65 db       	rcall	.-2358   	; 0x63e <vListRemove>
     f74:	8e 89       	ldd	r24, Y+22	; 0x16
     f76:	90 91 96 37 	lds	r25, 0x3796
     f7a:	98 17       	cp	r25, r24
     f7c:	10 f4       	brcc	.+4      	; 0xf82 <vTaskIncrementTick+0x142>
     f7e:	80 93 96 37 	sts	0x3796, r24
     f82:	90 e0       	ldi	r25, 0x00	; 0
     f84:	9c 01       	movw	r18, r24
     f86:	22 0f       	add	r18, r18
     f88:	33 1f       	adc	r19, r19
     f8a:	22 0f       	add	r18, r18
     f8c:	33 1f       	adc	r19, r19
     f8e:	22 0f       	add	r18, r18
     f90:	33 1f       	adc	r19, r19
     f92:	82 0f       	add	r24, r18
     f94:	93 1f       	adc	r25, r19
     f96:	b8 01       	movw	r22, r16
     f98:	8d 53       	subi	r24, 0x3D	; 61
     f9a:	98 4c       	sbci	r25, 0xC8	; 200
     f9c:	ee da       	rcall	.-2596   	; 0x57a <vListInsertEnd>
     f9e:	e0 91 af 37 	lds	r30, 0x37AF
     fa2:	f0 91 b0 37 	lds	r31, 0x37B0
     fa6:	80 81       	ld	r24, Z
     fa8:	81 11       	cpse	r24, r1
     faa:	c1 cf       	rjmp	.-126    	; 0xf2e <vTaskIncrementTick+0xee>
     fac:	b9 cf       	rjmp	.-142    	; 0xf20 <vTaskIncrementTick+0xe0>
     fae:	80 91 93 37 	lds	r24, 0x3793
     fb2:	8f 5f       	subi	r24, 0xFF	; 255
     fb4:	80 93 93 37 	sts	0x3793, r24
     fb8:	df 91       	pop	r29
     fba:	cf 91       	pop	r28
     fbc:	1f 91       	pop	r17
     fbe:	0f 91       	pop	r16
     fc0:	08 95       	ret

00000fc2 <xTaskResumeAll>:
     fc2:	bf 92       	push	r11
     fc4:	cf 92       	push	r12
     fc6:	df 92       	push	r13
     fc8:	ef 92       	push	r14
     fca:	ff 92       	push	r15
     fcc:	0f 93       	push	r16
     fce:	1f 93       	push	r17
     fd0:	cf 93       	push	r28
     fd2:	df 93       	push	r29
     fd4:	0f b6       	in	r0, 0x3f	; 63
     fd6:	f8 94       	cli
     fd8:	0f 92       	push	r0
     fda:	80 91 94 37 	lds	r24, 0x3794
     fde:	81 50       	subi	r24, 0x01	; 1
     fe0:	80 93 94 37 	sts	0x3794, r24
     fe4:	80 91 94 37 	lds	r24, 0x3794
     fe8:	81 11       	cpse	r24, r1
     fea:	62 c0       	rjmp	.+196    	; 0x10b0 <xTaskResumeAll+0xee>
     fec:	80 91 9a 37 	lds	r24, 0x379A
     ff0:	88 23       	and	r24, r24
     ff2:	09 f4       	brne	.+2      	; 0xff6 <xTaskResumeAll+0x34>
     ff4:	5f c0       	rjmp	.+190    	; 0x10b4 <xTaskResumeAll+0xf2>
     ff6:	b1 2c       	mov	r11, r1
     ff8:	0f 2e       	mov	r0, r31
     ffa:	f4 ea       	ldi	r31, 0xA4	; 164
     ffc:	ef 2e       	mov	r14, r31
     ffe:	f7 e3       	ldi	r31, 0x37	; 55
    1000:	ff 2e       	mov	r15, r31
    1002:	f0 2d       	mov	r31, r0
    1004:	0f 2e       	mov	r0, r31
    1006:	f9 ea       	ldi	r31, 0xA9	; 169
    1008:	cf 2e       	mov	r12, r31
    100a:	f7 e3       	ldi	r31, 0x37	; 55
    100c:	df 2e       	mov	r13, r31
    100e:	f0 2d       	mov	r31, r0
    1010:	2c c0       	rjmp	.+88     	; 0x106a <xTaskResumeAll+0xa8>
    1012:	d6 01       	movw	r26, r12
    1014:	ed 91       	ld	r30, X+
    1016:	fc 91       	ld	r31, X
    1018:	c6 81       	ldd	r28, Z+6	; 0x06
    101a:	d7 81       	ldd	r29, Z+7	; 0x07
    101c:	ce 01       	movw	r24, r28
    101e:	0c 96       	adiw	r24, 0x0c	; 12
    1020:	0e db       	rcall	.-2532   	; 0x63e <vListRemove>
    1022:	8e 01       	movw	r16, r28
    1024:	0e 5f       	subi	r16, 0xFE	; 254
    1026:	1f 4f       	sbci	r17, 0xFF	; 255
    1028:	c8 01       	movw	r24, r16
    102a:	09 db       	rcall	.-2542   	; 0x63e <vListRemove>
    102c:	8e 89       	ldd	r24, Y+22	; 0x16
    102e:	90 91 96 37 	lds	r25, 0x3796
    1032:	98 17       	cp	r25, r24
    1034:	10 f4       	brcc	.+4      	; 0x103a <xTaskResumeAll+0x78>
    1036:	80 93 96 37 	sts	0x3796, r24
    103a:	90 e0       	ldi	r25, 0x00	; 0
    103c:	9c 01       	movw	r18, r24
    103e:	22 0f       	add	r18, r18
    1040:	33 1f       	adc	r19, r19
    1042:	22 0f       	add	r18, r18
    1044:	33 1f       	adc	r19, r19
    1046:	22 0f       	add	r18, r18
    1048:	33 1f       	adc	r19, r19
    104a:	82 0f       	add	r24, r18
    104c:	93 1f       	adc	r25, r19
    104e:	b8 01       	movw	r22, r16
    1050:	8d 53       	subi	r24, 0x3D	; 61
    1052:	98 4c       	sbci	r25, 0xC8	; 200
    1054:	92 da       	rcall	.-2780   	; 0x57a <vListInsertEnd>
    1056:	e0 91 e7 37 	lds	r30, 0x37E7
    105a:	f0 91 e8 37 	lds	r31, 0x37E8
    105e:	9e 89       	ldd	r25, Y+22	; 0x16
    1060:	86 89       	ldd	r24, Z+22	; 0x16
    1062:	98 17       	cp	r25, r24
    1064:	10 f0       	brcs	.+4      	; 0x106a <xTaskResumeAll+0xa8>
    1066:	bb 24       	eor	r11, r11
    1068:	b3 94       	inc	r11
    106a:	f7 01       	movw	r30, r14
    106c:	80 81       	ld	r24, Z
    106e:	81 11       	cpse	r24, r1
    1070:	d0 cf       	rjmp	.-96     	; 0x1012 <xTaskResumeAll+0x50>
    1072:	80 91 93 37 	lds	r24, 0x3793
    1076:	88 23       	and	r24, r24
    1078:	79 f0       	breq	.+30     	; 0x1098 <xTaskResumeAll+0xd6>
    107a:	80 91 93 37 	lds	r24, 0x3793
    107e:	88 23       	and	r24, r24
    1080:	91 f0       	breq	.+36     	; 0x10a6 <xTaskResumeAll+0xe4>
    1082:	de de       	rcall	.-580    	; 0xe40 <vTaskIncrementTick>
    1084:	80 91 93 37 	lds	r24, 0x3793
    1088:	81 50       	subi	r24, 0x01	; 1
    108a:	80 93 93 37 	sts	0x3793, r24
    108e:	80 91 93 37 	lds	r24, 0x3793
    1092:	81 11       	cpse	r24, r1
    1094:	f6 cf       	rjmp	.-20     	; 0x1082 <xTaskResumeAll+0xc0>
    1096:	07 c0       	rjmp	.+14     	; 0x10a6 <xTaskResumeAll+0xe4>
    1098:	f1 e0       	ldi	r31, 0x01	; 1
    109a:	bf 16       	cp	r11, r31
    109c:	21 f0       	breq	.+8      	; 0x10a6 <xTaskResumeAll+0xe4>
    109e:	80 91 92 37 	lds	r24, 0x3792
    10a2:	81 30       	cpi	r24, 0x01	; 1
    10a4:	49 f4       	brne	.+18     	; 0x10b8 <xTaskResumeAll+0xf6>
    10a6:	10 92 92 37 	sts	0x3792, r1
    10aa:	a4 d9       	rcall	.-3256   	; 0x3f4 <vPortYield>
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	05 c0       	rjmp	.+10     	; 0x10ba <xTaskResumeAll+0xf8>
    10b0:	80 e0       	ldi	r24, 0x00	; 0
    10b2:	03 c0       	rjmp	.+6      	; 0x10ba <xTaskResumeAll+0xf8>
    10b4:	80 e0       	ldi	r24, 0x00	; 0
    10b6:	01 c0       	rjmp	.+2      	; 0x10ba <xTaskResumeAll+0xf8>
    10b8:	80 e0       	ldi	r24, 0x00	; 0
    10ba:	0f 90       	pop	r0
    10bc:	0f be       	out	0x3f, r0	; 63
    10be:	df 91       	pop	r29
    10c0:	cf 91       	pop	r28
    10c2:	1f 91       	pop	r17
    10c4:	0f 91       	pop	r16
    10c6:	ff 90       	pop	r15
    10c8:	ef 90       	pop	r14
    10ca:	df 90       	pop	r13
    10cc:	cf 90       	pop	r12
    10ce:	bf 90       	pop	r11
    10d0:	08 95       	ret

000010d2 <vTaskDelay>:
    10d2:	cf 93       	push	r28
    10d4:	df 93       	push	r29
    10d6:	ec 01       	movw	r28, r24
    10d8:	00 97       	sbiw	r24, 0x00	; 0
    10da:	91 f0       	breq	.+36     	; 0x1100 <vTaskDelay+0x2e>
    10dc:	a1 de       	rcall	.-702    	; 0xe20 <vTaskSuspendAll>
    10de:	80 91 98 37 	lds	r24, 0x3798
    10e2:	90 91 99 37 	lds	r25, 0x3799
    10e6:	c8 0f       	add	r28, r24
    10e8:	d9 1f       	adc	r29, r25
    10ea:	80 91 e7 37 	lds	r24, 0x37E7
    10ee:	90 91 e8 37 	lds	r25, 0x37E8
    10f2:	02 96       	adiw	r24, 0x02	; 2
    10f4:	a4 da       	rcall	.-2744   	; 0x63e <vListRemove>
    10f6:	ce 01       	movw	r24, r28
    10f8:	3f dd       	rcall	.-1410   	; 0xb78 <prvAddCurrentTaskToDelayedList>
    10fa:	63 df       	rcall	.-314    	; 0xfc2 <xTaskResumeAll>
    10fc:	81 11       	cpse	r24, r1
    10fe:	01 c0       	rjmp	.+2      	; 0x1102 <vTaskDelay+0x30>
    1100:	79 d9       	rcall	.-3342   	; 0x3f4 <vPortYield>
    1102:	df 91       	pop	r29
    1104:	cf 91       	pop	r28
    1106:	08 95       	ret

00001108 <vTaskSwitchContext>:
    1108:	80 91 94 37 	lds	r24, 0x3794
    110c:	81 11       	cpse	r24, r1
    110e:	13 c0       	rjmp	.+38     	; 0x1136 <vTaskSwitchContext+0x2e>
    1110:	80 91 96 37 	lds	r24, 0x3796
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	fc 01       	movw	r30, r24
    1118:	ee 0f       	add	r30, r30
    111a:	ff 1f       	adc	r31, r31
    111c:	ee 0f       	add	r30, r30
    111e:	ff 1f       	adc	r31, r31
    1120:	ee 0f       	add	r30, r30
    1122:	ff 1f       	adc	r31, r31
    1124:	8e 0f       	add	r24, r30
    1126:	9f 1f       	adc	r25, r31
    1128:	fc 01       	movw	r30, r24
    112a:	ed 53       	subi	r30, 0x3D	; 61
    112c:	f8 4c       	sbci	r31, 0xC8	; 200
    112e:	80 81       	ld	r24, Z
    1130:	88 23       	and	r24, r24
    1132:	29 f0       	breq	.+10     	; 0x113e <vTaskSwitchContext+0x36>
    1134:	1b c0       	rjmp	.+54     	; 0x116c <vTaskSwitchContext+0x64>
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	80 93 92 37 	sts	0x3792, r24
    113c:	08 95       	ret
    113e:	80 91 96 37 	lds	r24, 0x3796
    1142:	81 50       	subi	r24, 0x01	; 1
    1144:	80 93 96 37 	sts	0x3796, r24
    1148:	80 91 96 37 	lds	r24, 0x3796
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	fc 01       	movw	r30, r24
    1150:	ee 0f       	add	r30, r30
    1152:	ff 1f       	adc	r31, r31
    1154:	ee 0f       	add	r30, r30
    1156:	ff 1f       	adc	r31, r31
    1158:	ee 0f       	add	r30, r30
    115a:	ff 1f       	adc	r31, r31
    115c:	8e 0f       	add	r24, r30
    115e:	9f 1f       	adc	r25, r31
    1160:	fc 01       	movw	r30, r24
    1162:	ed 53       	subi	r30, 0x3D	; 61
    1164:	f8 4c       	sbci	r31, 0xC8	; 200
    1166:	80 81       	ld	r24, Z
    1168:	88 23       	and	r24, r24
    116a:	49 f3       	breq	.-46     	; 0x113e <vTaskSwitchContext+0x36>
    116c:	e0 91 96 37 	lds	r30, 0x3796
    1170:	f0 e0       	ldi	r31, 0x00	; 0
    1172:	cf 01       	movw	r24, r30
    1174:	88 0f       	add	r24, r24
    1176:	99 1f       	adc	r25, r25
    1178:	88 0f       	add	r24, r24
    117a:	99 1f       	adc	r25, r25
    117c:	88 0f       	add	r24, r24
    117e:	99 1f       	adc	r25, r25
    1180:	e8 0f       	add	r30, r24
    1182:	f9 1f       	adc	r31, r25
    1184:	ed 53       	subi	r30, 0x3D	; 61
    1186:	f8 4c       	sbci	r31, 0xC8	; 200
    1188:	a1 81       	ldd	r26, Z+1	; 0x01
    118a:	b2 81       	ldd	r27, Z+2	; 0x02
    118c:	12 96       	adiw	r26, 0x02	; 2
    118e:	0d 90       	ld	r0, X+
    1190:	bc 91       	ld	r27, X
    1192:	a0 2d       	mov	r26, r0
    1194:	a1 83       	std	Z+1, r26	; 0x01
    1196:	b2 83       	std	Z+2, r27	; 0x02
    1198:	cf 01       	movw	r24, r30
    119a:	03 96       	adiw	r24, 0x03	; 3
    119c:	a8 17       	cp	r26, r24
    119e:	b9 07       	cpc	r27, r25
    11a0:	31 f4       	brne	.+12     	; 0x11ae <vTaskSwitchContext+0xa6>
    11a2:	12 96       	adiw	r26, 0x02	; 2
    11a4:	8d 91       	ld	r24, X+
    11a6:	9c 91       	ld	r25, X
    11a8:	13 97       	sbiw	r26, 0x03	; 3
    11aa:	81 83       	std	Z+1, r24	; 0x01
    11ac:	92 83       	std	Z+2, r25	; 0x02
    11ae:	01 80       	ldd	r0, Z+1	; 0x01
    11b0:	f2 81       	ldd	r31, Z+2	; 0x02
    11b2:	e0 2d       	mov	r30, r0
    11b4:	86 81       	ldd	r24, Z+6	; 0x06
    11b6:	97 81       	ldd	r25, Z+7	; 0x07
    11b8:	80 93 e7 37 	sts	0x37E7, r24
    11bc:	90 93 e8 37 	sts	0x37E8, r25
    11c0:	08 95       	ret

000011c2 <vTaskPlaceOnEventList>:
    11c2:	cf 93       	push	r28
    11c4:	df 93       	push	r29
    11c6:	eb 01       	movw	r28, r22
    11c8:	60 91 e7 37 	lds	r22, 0x37E7
    11cc:	70 91 e8 37 	lds	r23, 0x37E8
    11d0:	64 5f       	subi	r22, 0xF4	; 244
    11d2:	7f 4f       	sbci	r23, 0xFF	; 255
    11d4:	f9 d9       	rcall	.-3086   	; 0x5c8 <vListInsert>
    11d6:	80 91 e7 37 	lds	r24, 0x37E7
    11da:	90 91 e8 37 	lds	r25, 0x37E8
    11de:	02 96       	adiw	r24, 0x02	; 2
    11e0:	2e da       	rcall	.-2980   	; 0x63e <vListRemove>
    11e2:	cf 3f       	cpi	r28, 0xFF	; 255
    11e4:	8f ef       	ldi	r24, 0xFF	; 255
    11e6:	d8 07       	cpc	r29, r24
    11e8:	51 f4       	brne	.+20     	; 0x11fe <vTaskPlaceOnEventList+0x3c>
    11ea:	60 91 e7 37 	lds	r22, 0x37E7
    11ee:	70 91 e8 37 	lds	r23, 0x37E8
    11f2:	6e 5f       	subi	r22, 0xFE	; 254
    11f4:	7f 4f       	sbci	r23, 0xFF	; 255
    11f6:	8b e9       	ldi	r24, 0x9B	; 155
    11f8:	97 e3       	ldi	r25, 0x37	; 55
    11fa:	bf d9       	rcall	.-3202   	; 0x57a <vListInsertEnd>
    11fc:	07 c0       	rjmp	.+14     	; 0x120c <vTaskPlaceOnEventList+0x4a>
    11fe:	80 91 98 37 	lds	r24, 0x3798
    1202:	90 91 99 37 	lds	r25, 0x3799
    1206:	8c 0f       	add	r24, r28
    1208:	9d 1f       	adc	r25, r29
    120a:	b6 dc       	rcall	.-1684   	; 0xb78 <prvAddCurrentTaskToDelayedList>
    120c:	df 91       	pop	r29
    120e:	cf 91       	pop	r28
    1210:	08 95       	ret

00001212 <vTaskPlaceOnEventListRestricted>:
    1212:	cf 93       	push	r28
    1214:	df 93       	push	r29
    1216:	eb 01       	movw	r28, r22
    1218:	60 91 e7 37 	lds	r22, 0x37E7
    121c:	70 91 e8 37 	lds	r23, 0x37E8
    1220:	64 5f       	subi	r22, 0xF4	; 244
    1222:	7f 4f       	sbci	r23, 0xFF	; 255
    1224:	aa d9       	rcall	.-3244   	; 0x57a <vListInsertEnd>
    1226:	80 91 e7 37 	lds	r24, 0x37E7
    122a:	90 91 e8 37 	lds	r25, 0x37E8
    122e:	02 96       	adiw	r24, 0x02	; 2
    1230:	06 da       	rcall	.-3060   	; 0x63e <vListRemove>
    1232:	80 91 98 37 	lds	r24, 0x3798
    1236:	90 91 99 37 	lds	r25, 0x3799
    123a:	8c 0f       	add	r24, r28
    123c:	9d 1f       	adc	r25, r29
    123e:	9c dc       	rcall	.-1736   	; 0xb78 <prvAddCurrentTaskToDelayedList>
    1240:	df 91       	pop	r29
    1242:	cf 91       	pop	r28
    1244:	08 95       	ret

00001246 <xTaskRemoveFromEventList>:
    1246:	0f 93       	push	r16
    1248:	1f 93       	push	r17
    124a:	cf 93       	push	r28
    124c:	df 93       	push	r29
    124e:	dc 01       	movw	r26, r24
    1250:	15 96       	adiw	r26, 0x05	; 5
    1252:	ed 91       	ld	r30, X+
    1254:	fc 91       	ld	r31, X
    1256:	16 97       	sbiw	r26, 0x06	; 6
    1258:	c6 81       	ldd	r28, Z+6	; 0x06
    125a:	d7 81       	ldd	r29, Z+7	; 0x07
    125c:	8e 01       	movw	r16, r28
    125e:	04 5f       	subi	r16, 0xF4	; 244
    1260:	1f 4f       	sbci	r17, 0xFF	; 255
    1262:	c8 01       	movw	r24, r16
    1264:	ec d9       	rcall	.-3112   	; 0x63e <vListRemove>
    1266:	80 91 94 37 	lds	r24, 0x3794
    126a:	81 11       	cpse	r24, r1
    126c:	1a c0       	rjmp	.+52     	; 0x12a2 <xTaskRemoveFromEventList+0x5c>
    126e:	0a 50       	subi	r16, 0x0A	; 10
    1270:	11 09       	sbc	r17, r1
    1272:	c8 01       	movw	r24, r16
    1274:	e4 d9       	rcall	.-3128   	; 0x63e <vListRemove>
    1276:	8e 89       	ldd	r24, Y+22	; 0x16
    1278:	90 91 96 37 	lds	r25, 0x3796
    127c:	98 17       	cp	r25, r24
    127e:	10 f4       	brcc	.+4      	; 0x1284 <xTaskRemoveFromEventList+0x3e>
    1280:	80 93 96 37 	sts	0x3796, r24
    1284:	90 e0       	ldi	r25, 0x00	; 0
    1286:	9c 01       	movw	r18, r24
    1288:	22 0f       	add	r18, r18
    128a:	33 1f       	adc	r19, r19
    128c:	22 0f       	add	r18, r18
    128e:	33 1f       	adc	r19, r19
    1290:	22 0f       	add	r18, r18
    1292:	33 1f       	adc	r19, r19
    1294:	82 0f       	add	r24, r18
    1296:	93 1f       	adc	r25, r19
    1298:	b8 01       	movw	r22, r16
    129a:	8d 53       	subi	r24, 0x3D	; 61
    129c:	98 4c       	sbci	r25, 0xC8	; 200
    129e:	6d d9       	rcall	.-3366   	; 0x57a <vListInsertEnd>
    12a0:	04 c0       	rjmp	.+8      	; 0x12aa <xTaskRemoveFromEventList+0x64>
    12a2:	b8 01       	movw	r22, r16
    12a4:	84 ea       	ldi	r24, 0xA4	; 164
    12a6:	97 e3       	ldi	r25, 0x37	; 55
    12a8:	68 d9       	rcall	.-3376   	; 0x57a <vListInsertEnd>
    12aa:	e0 91 e7 37 	lds	r30, 0x37E7
    12ae:	f0 91 e8 37 	lds	r31, 0x37E8
    12b2:	81 e0       	ldi	r24, 0x01	; 1
    12b4:	2e 89       	ldd	r18, Y+22	; 0x16
    12b6:	96 89       	ldd	r25, Z+22	; 0x16
    12b8:	29 17       	cp	r18, r25
    12ba:	08 f4       	brcc	.+2      	; 0x12be <xTaskRemoveFromEventList+0x78>
    12bc:	80 e0       	ldi	r24, 0x00	; 0
    12be:	df 91       	pop	r29
    12c0:	cf 91       	pop	r28
    12c2:	1f 91       	pop	r17
    12c4:	0f 91       	pop	r16
    12c6:	08 95       	ret

000012c8 <vTaskSetTimeOutState>:
    12c8:	20 91 91 37 	lds	r18, 0x3791
    12cc:	fc 01       	movw	r30, r24
    12ce:	20 83       	st	Z, r18
    12d0:	20 91 98 37 	lds	r18, 0x3798
    12d4:	30 91 99 37 	lds	r19, 0x3799
    12d8:	21 83       	std	Z+1, r18	; 0x01
    12da:	32 83       	std	Z+2, r19	; 0x02
    12dc:	08 95       	ret

000012de <xTaskCheckForTimeOut>:
    12de:	0f b6       	in	r0, 0x3f	; 63
    12e0:	f8 94       	cli
    12e2:	0f 92       	push	r0
    12e4:	db 01       	movw	r26, r22
    12e6:	2d 91       	ld	r18, X+
    12e8:	3c 91       	ld	r19, X
    12ea:	2f 3f       	cpi	r18, 0xFF	; 255
    12ec:	bf ef       	ldi	r27, 0xFF	; 255
    12ee:	3b 07       	cpc	r19, r27
    12f0:	61 f1       	breq	.+88     	; 0x134a <xTaskCheckForTimeOut+0x6c>
    12f2:	40 91 91 37 	lds	r20, 0x3791
    12f6:	fc 01       	movw	r30, r24
    12f8:	50 81       	ld	r21, Z
    12fa:	54 17       	cp	r21, r20
    12fc:	51 f0       	breq	.+20     	; 0x1312 <xTaskCheckForTimeOut+0x34>
    12fe:	40 91 98 37 	lds	r20, 0x3798
    1302:	50 91 99 37 	lds	r21, 0x3799
    1306:	01 80       	ldd	r0, Z+1	; 0x01
    1308:	f2 81       	ldd	r31, Z+2	; 0x02
    130a:	e0 2d       	mov	r30, r0
    130c:	4e 17       	cp	r20, r30
    130e:	5f 07       	cpc	r21, r31
    1310:	f0 f4       	brcc	.+60     	; 0x134e <xTaskCheckForTimeOut+0x70>
    1312:	e0 91 98 37 	lds	r30, 0x3798
    1316:	f0 91 99 37 	lds	r31, 0x3799
    131a:	dc 01       	movw	r26, r24
    131c:	11 96       	adiw	r26, 0x01	; 1
    131e:	4d 91       	ld	r20, X+
    1320:	5c 91       	ld	r21, X
    1322:	12 97       	sbiw	r26, 0x02	; 2
    1324:	e4 1b       	sub	r30, r20
    1326:	f5 0b       	sbc	r31, r21
    1328:	e2 17       	cp	r30, r18
    132a:	f3 07       	cpc	r31, r19
    132c:	90 f4       	brcc	.+36     	; 0x1352 <xTaskCheckForTimeOut+0x74>
    132e:	e0 91 98 37 	lds	r30, 0x3798
    1332:	f0 91 99 37 	lds	r31, 0x3799
    1336:	4e 1b       	sub	r20, r30
    1338:	5f 0b       	sbc	r21, r31
    133a:	24 0f       	add	r18, r20
    133c:	35 1f       	adc	r19, r21
    133e:	fb 01       	movw	r30, r22
    1340:	20 83       	st	Z, r18
    1342:	31 83       	std	Z+1, r19	; 0x01
    1344:	c1 df       	rcall	.-126    	; 0x12c8 <vTaskSetTimeOutState>
    1346:	80 e0       	ldi	r24, 0x00	; 0
    1348:	05 c0       	rjmp	.+10     	; 0x1354 <xTaskCheckForTimeOut+0x76>
    134a:	80 e0       	ldi	r24, 0x00	; 0
    134c:	03 c0       	rjmp	.+6      	; 0x1354 <xTaskCheckForTimeOut+0x76>
    134e:	81 e0       	ldi	r24, 0x01	; 1
    1350:	01 c0       	rjmp	.+2      	; 0x1354 <xTaskCheckForTimeOut+0x76>
    1352:	81 e0       	ldi	r24, 0x01	; 1
    1354:	0f 90       	pop	r0
    1356:	0f be       	out	0x3f, r0	; 63
    1358:	08 95       	ret

0000135a <vTaskMissedYield>:
    135a:	81 e0       	ldi	r24, 0x01	; 1
    135c:	80 93 92 37 	sts	0x3792, r24
    1360:	08 95       	ret

00001362 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    1362:	80 91 e7 37 	lds	r24, 0x37E7
    1366:	90 91 e8 37 	lds	r25, 0x37E8

		return xReturn;
	}
    136a:	08 95       	ret

0000136c <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
    136c:	80 91 95 37 	lds	r24, 0x3795
    1370:	88 23       	and	r24, r24
    1372:	31 f0       	breq	.+12     	; 0x1380 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1374:	80 91 94 37 	lds	r24, 0x3794
    1378:	81 11       	cpse	r24, r1
    137a:	04 c0       	rjmp	.+8      	; 0x1384 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
    137c:	81 e0       	ldi	r24, 0x01	; 1
    137e:	08 95       	ret
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    1380:	80 e0       	ldi	r24, 0x00	; 0
    1382:	08 95       	ret
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    1384:	82 e0       	ldi	r24, 0x02	; 2
			}
		}

		return xReturn;
	}
    1386:	08 95       	ret

00001388 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    1388:	0f 93       	push	r16
    138a:	1f 93       	push	r17
    138c:	cf 93       	push	r28
    138e:	df 93       	push	r29
    1390:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1392:	8e 89       	ldd	r24, Y+22	; 0x16
    1394:	e0 91 e7 37 	lds	r30, 0x37E7
    1398:	f0 91 e8 37 	lds	r31, 0x37E8
    139c:	96 89       	ldd	r25, Z+22	; 0x16
    139e:	89 17       	cp	r24, r25
    13a0:	08 f0       	brcs	.+2      	; 0x13a4 <vTaskPriorityInherit+0x1c>
    13a2:	42 c0       	rjmp	.+132    	; 0x1428 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    13a4:	e0 91 e7 37 	lds	r30, 0x37E7
    13a8:	f0 91 e8 37 	lds	r31, 0x37E8
    13ac:	96 89       	ldd	r25, Z+22	; 0x16
    13ae:	24 e0       	ldi	r18, 0x04	; 4
    13b0:	30 e0       	ldi	r19, 0x00	; 0
    13b2:	29 1b       	sub	r18, r25
    13b4:	31 09       	sbc	r19, r1
    13b6:	2c 87       	std	Y+12, r18	; 0x0c
    13b8:	3d 87       	std	Y+13, r19	; 0x0d

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	9c 01       	movw	r18, r24
    13be:	22 0f       	add	r18, r18
    13c0:	33 1f       	adc	r19, r19
    13c2:	22 0f       	add	r18, r18
    13c4:	33 1f       	adc	r19, r19
    13c6:	22 0f       	add	r18, r18
    13c8:	33 1f       	adc	r19, r19
    13ca:	82 0f       	add	r24, r18
    13cc:	93 1f       	adc	r25, r19
    13ce:	8d 53       	subi	r24, 0x3D	; 61
    13d0:	98 4c       	sbci	r25, 0xC8	; 200
    13d2:	2a 85       	ldd	r18, Y+10	; 0x0a
    13d4:	3b 85       	ldd	r19, Y+11	; 0x0b
    13d6:	28 17       	cp	r18, r24
    13d8:	39 07       	cpc	r19, r25
    13da:	01 f5       	brne	.+64     	; 0x141c <vTaskPriorityInherit+0x94>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    13dc:	8e 01       	movw	r16, r28
    13de:	0e 5f       	subi	r16, 0xFE	; 254
    13e0:	1f 4f       	sbci	r17, 0xFF	; 255
    13e2:	c8 01       	movw	r24, r16
    13e4:	2c d9       	rcall	.-3496   	; 0x63e <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    13e6:	e0 91 e7 37 	lds	r30, 0x37E7
    13ea:	f0 91 e8 37 	lds	r31, 0x37E8
    13ee:	86 89       	ldd	r24, Z+22	; 0x16
    13f0:	8e 8b       	std	Y+22, r24	; 0x16
				prvAddTaskToReadyQueue( pxTCB );
    13f2:	90 91 96 37 	lds	r25, 0x3796
    13f6:	98 17       	cp	r25, r24
    13f8:	10 f4       	brcc	.+4      	; 0x13fe <vTaskPriorityInherit+0x76>
    13fa:	80 93 96 37 	sts	0x3796, r24
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	9c 01       	movw	r18, r24
    1402:	22 0f       	add	r18, r18
    1404:	33 1f       	adc	r19, r19
    1406:	22 0f       	add	r18, r18
    1408:	33 1f       	adc	r19, r19
    140a:	22 0f       	add	r18, r18
    140c:	33 1f       	adc	r19, r19
    140e:	82 0f       	add	r24, r18
    1410:	93 1f       	adc	r25, r19
    1412:	b8 01       	movw	r22, r16
    1414:	8d 53       	subi	r24, 0x3D	; 61
    1416:	98 4c       	sbci	r25, 0xC8	; 200
    1418:	b0 d8       	rcall	.-3744   	; 0x57a <vListInsertEnd>
    141a:	06 c0       	rjmp	.+12     	; 0x1428 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    141c:	e0 91 e7 37 	lds	r30, 0x37E7
    1420:	f0 91 e8 37 	lds	r31, 0x37E8
    1424:	86 89       	ldd	r24, Z+22	; 0x16
    1426:	8e 8b       	std	Y+22, r24	; 0x16
			}
		}
	}
    1428:	df 91       	pop	r29
    142a:	cf 91       	pop	r28
    142c:	1f 91       	pop	r17
    142e:	0f 91       	pop	r16
    1430:	08 95       	ret

00001432 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    1432:	0f 93       	push	r16
    1434:	1f 93       	push	r17
    1436:	cf 93       	push	r28
    1438:	df 93       	push	r29
    143a:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    143c:	00 97       	sbiw	r24, 0x00	; 0
    143e:	29 f1       	breq	.+74     	; 0x148a <vTaskPriorityDisinherit+0x58>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1440:	9e 89       	ldd	r25, Y+22	; 0x16
    1442:	89 a1       	ldd	r24, Y+33	; 0x21
    1444:	98 17       	cp	r25, r24
    1446:	09 f1       	breq	.+66     	; 0x148a <vTaskPriorityDisinherit+0x58>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    1448:	8e 01       	movw	r16, r28
    144a:	0e 5f       	subi	r16, 0xFE	; 254
    144c:	1f 4f       	sbci	r17, 0xFF	; 255
    144e:	c8 01       	movw	r24, r16
    1450:	f6 d8       	rcall	.-3604   	; 0x63e <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    1452:	89 a1       	ldd	r24, Y+33	; 0x21
    1454:	8e 8b       	std	Y+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    1456:	24 e0       	ldi	r18, 0x04	; 4
    1458:	30 e0       	ldi	r19, 0x00	; 0
    145a:	28 1b       	sub	r18, r24
    145c:	31 09       	sbc	r19, r1
    145e:	2c 87       	std	Y+12, r18	; 0x0c
    1460:	3d 87       	std	Y+13, r19	; 0x0d
				prvAddTaskToReadyQueue( pxTCB );
    1462:	90 91 96 37 	lds	r25, 0x3796
    1466:	98 17       	cp	r25, r24
    1468:	10 f4       	brcc	.+4      	; 0x146e <vTaskPriorityDisinherit+0x3c>
    146a:	80 93 96 37 	sts	0x3796, r24
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	9c 01       	movw	r18, r24
    1472:	22 0f       	add	r18, r18
    1474:	33 1f       	adc	r19, r19
    1476:	22 0f       	add	r18, r18
    1478:	33 1f       	adc	r19, r19
    147a:	22 0f       	add	r18, r18
    147c:	33 1f       	adc	r19, r19
    147e:	82 0f       	add	r24, r18
    1480:	93 1f       	adc	r25, r19
    1482:	b8 01       	movw	r22, r16
    1484:	8d 53       	subi	r24, 0x3D	; 61
    1486:	98 4c       	sbci	r25, 0xC8	; 200
    1488:	78 d8       	rcall	.-3856   	; 0x57a <vListInsertEnd>
			}
		}
	}
    148a:	df 91       	pop	r29
    148c:	cf 91       	pop	r28
    148e:	1f 91       	pop	r17
    1490:	0f 91       	pop	r16
    1492:	08 95       	ret

00001494 <prvInsertTimerInActiveList>:
			traceTIMER_CREATE_FAILED();
		}
	}
	
	return ( xTimerHandle ) pxNewTimer;
}
    1494:	fc 01       	movw	r30, r24
    1496:	62 83       	std	Z+2, r22	; 0x02
    1498:	73 83       	std	Z+3, r23	; 0x03
    149a:	80 87       	std	Z+8, r24	; 0x08
    149c:	91 87       	std	Z+9, r25	; 0x09
    149e:	46 17       	cp	r20, r22
    14a0:	57 07       	cpc	r21, r23
    14a2:	88 f0       	brcs	.+34     	; 0x14c6 <prvInsertTimerInActiveList+0x32>
    14a4:	42 1b       	sub	r20, r18
    14a6:	53 0b       	sbc	r21, r19
    14a8:	84 85       	ldd	r24, Z+12	; 0x0c
    14aa:	95 85       	ldd	r25, Z+13	; 0x0d
    14ac:	48 17       	cp	r20, r24
    14ae:	59 07       	cpc	r21, r25
    14b0:	d0 f4       	brcc	.+52     	; 0x14e6 <prvInsertTimerInActiveList+0x52>
    14b2:	bf 01       	movw	r22, r30
    14b4:	6e 5f       	subi	r22, 0xFE	; 254
    14b6:	7f 4f       	sbci	r23, 0xFF	; 255
    14b8:	80 91 ed 37 	lds	r24, 0x37ED
    14bc:	90 91 ee 37 	lds	r25, 0x37EE
    14c0:	83 d8       	rcall	.-3834   	; 0x5c8 <vListInsert>
    14c2:	80 e0       	ldi	r24, 0x00	; 0
    14c4:	08 95       	ret
    14c6:	42 17       	cp	r20, r18
    14c8:	53 07       	cpc	r21, r19
    14ca:	18 f4       	brcc	.+6      	; 0x14d2 <prvInsertTimerInActiveList+0x3e>
    14cc:	62 17       	cp	r22, r18
    14ce:	73 07       	cpc	r23, r19
    14d0:	60 f4       	brcc	.+24     	; 0x14ea <prvInsertTimerInActiveList+0x56>
    14d2:	bf 01       	movw	r22, r30
    14d4:	6e 5f       	subi	r22, 0xFE	; 254
    14d6:	7f 4f       	sbci	r23, 0xFF	; 255
    14d8:	80 91 ef 37 	lds	r24, 0x37EF
    14dc:	90 91 f0 37 	lds	r25, 0x37F0
    14e0:	73 d8       	rcall	.-3866   	; 0x5c8 <vListInsert>
    14e2:	80 e0       	ldi	r24, 0x00	; 0
    14e4:	08 95       	ret
    14e6:	81 e0       	ldi	r24, 0x01	; 1
    14e8:	08 95       	ret
    14ea:	81 e0       	ldi	r24, 0x01	; 1
    14ec:	08 95       	ret

000014ee <prvCheckForValidListAndQueue>:
    14ee:	0f b6       	in	r0, 0x3f	; 63
    14f0:	f8 94       	cli
    14f2:	0f 92       	push	r0
    14f4:	80 91 eb 37 	lds	r24, 0x37EB
    14f8:	90 91 ec 37 	lds	r25, 0x37EC
    14fc:	89 2b       	or	r24, r25
    14fe:	c9 f4       	brne	.+50     	; 0x1532 <prvCheckForValidListAndQueue+0x44>
    1500:	8a ef       	ldi	r24, 0xFA	; 250
    1502:	97 e3       	ldi	r25, 0x37	; 55
    1504:	28 d8       	rcall	.-4016   	; 0x556 <vListInitialise>
    1506:	81 ef       	ldi	r24, 0xF1	; 241
    1508:	97 e3       	ldi	r25, 0x37	; 55
    150a:	25 d8       	rcall	.-4022   	; 0x556 <vListInitialise>
    150c:	8a ef       	ldi	r24, 0xFA	; 250
    150e:	97 e3       	ldi	r25, 0x37	; 55
    1510:	80 93 ef 37 	sts	0x37EF, r24
    1514:	90 93 f0 37 	sts	0x37F0, r25
    1518:	81 ef       	ldi	r24, 0xF1	; 241
    151a:	97 e3       	ldi	r25, 0x37	; 55
    151c:	80 93 ed 37 	sts	0x37ED, r24
    1520:	90 93 ee 37 	sts	0x37EE, r25
    1524:	65 e0       	ldi	r22, 0x05	; 5
    1526:	80 e1       	ldi	r24, 0x10	; 16
    1528:	59 d9       	rcall	.-3406   	; 0x7dc <xQueueCreate>
    152a:	80 93 eb 37 	sts	0x37EB, r24
    152e:	90 93 ec 37 	sts	0x37EC, r25
    1532:	0f 90       	pop	r0
    1534:	0f be       	out	0x3f, r0	; 63
    1536:	08 95       	ret

00001538 <xTimerCreateTimerTask>:
    1538:	af 92       	push	r10
    153a:	bf 92       	push	r11
    153c:	cf 92       	push	r12
    153e:	df 92       	push	r13
    1540:	ef 92       	push	r14
    1542:	ff 92       	push	r15
    1544:	0f 93       	push	r16
    1546:	d3 df       	rcall	.-90     	; 0x14ee <prvCheckForValidListAndQueue>
    1548:	80 91 eb 37 	lds	r24, 0x37EB
    154c:	90 91 ec 37 	lds	r25, 0x37EC
    1550:	89 2b       	or	r24, r25
    1552:	89 f0       	breq	.+34     	; 0x1576 <xTimerCreateTimerTask+0x3e>
    1554:	a1 2c       	mov	r10, r1
    1556:	b1 2c       	mov	r11, r1
    1558:	c1 2c       	mov	r12, r1
    155a:	d1 2c       	mov	r13, r1
    155c:	e1 2c       	mov	r14, r1
    155e:	f1 2c       	mov	r15, r1
    1560:	01 e0       	ldi	r16, 0x01	; 1
    1562:	20 e0       	ldi	r18, 0x00	; 0
    1564:	30 e0       	ldi	r19, 0x00	; 0
    1566:	46 e9       	ldi	r20, 0x96	; 150
    1568:	50 e0       	ldi	r21, 0x00	; 0
    156a:	67 e0       	ldi	r22, 0x07	; 7
    156c:	70 e2       	ldi	r23, 0x20	; 32
    156e:	86 e7       	ldi	r24, 0x76	; 118
    1570:	9b e0       	ldi	r25, 0x0B	; 11
    1572:	37 db       	rcall	.-2450   	; 0xbe2 <xTaskGenericCreate>
    1574:	01 c0       	rjmp	.+2      	; 0x1578 <xTimerCreateTimerTask+0x40>
    1576:	80 e0       	ldi	r24, 0x00	; 0
    1578:	0f 91       	pop	r16
    157a:	ff 90       	pop	r15
    157c:	ef 90       	pop	r14
    157e:	df 90       	pop	r13
    1580:	cf 90       	pop	r12
    1582:	bf 90       	pop	r11
    1584:	af 90       	pop	r10
    1586:	08 95       	ret

00001588 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
    1588:	0f 93       	push	r16
    158a:	1f 93       	push	r17
    158c:	cf 93       	push	r28
    158e:	df 93       	push	r29
    1590:	cd b7       	in	r28, 0x3d	; 61
    1592:	de b7       	in	r29, 0x3e	; 62
    1594:	25 97       	sbiw	r28, 0x05	; 5
    1596:	cd bf       	out	0x3d, r28	; 61
    1598:	de bf       	out	0x3e, r29	; 62
    159a:	d9 01       	movw	r26, r18
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    159c:	e0 91 eb 37 	lds	r30, 0x37EB
    15a0:	f0 91 ec 37 	lds	r31, 0x37EC
    15a4:	30 97       	sbiw	r30, 0x00	; 0
    15a6:	49 f1       	breq	.+82     	; 0x15fa <xTimerGenericCommand+0x72>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    15a8:	69 83       	std	Y+1, r22	; 0x01
		xMessage.xMessageValue = xOptionalValue;
    15aa:	4a 83       	std	Y+2, r20	; 0x02
    15ac:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.pxTimer = ( xTIMER * ) xTimer;
    15ae:	8c 83       	std	Y+4, r24	; 0x04
    15b0:	9d 83       	std	Y+5, r25	; 0x05

		if( pxHigherPriorityTaskWoken == NULL )
    15b2:	10 97       	sbiw	r26, 0x00	; 0
    15b4:	d1 f4       	brne	.+52     	; 0x15ea <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    15b6:	da de       	rcall	.-588    	; 0x136c <xTaskGetSchedulerState>
    15b8:	81 30       	cpi	r24, 0x01	; 1
    15ba:	59 f4       	brne	.+22     	; 0x15d2 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
    15bc:	20 e0       	ldi	r18, 0x00	; 0
    15be:	a8 01       	movw	r20, r16
    15c0:	be 01       	movw	r22, r28
    15c2:	6f 5f       	subi	r22, 0xFF	; 255
    15c4:	7f 4f       	sbci	r23, 0xFF	; 255
    15c6:	80 91 eb 37 	lds	r24, 0x37EB
    15ca:	90 91 ec 37 	lds	r25, 0x37EC
    15ce:	52 d9       	rcall	.-3420   	; 0x874 <xQueueGenericSend>
    15d0:	15 c0       	rjmp	.+42     	; 0x15fc <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    15d2:	20 e0       	ldi	r18, 0x00	; 0
    15d4:	40 e0       	ldi	r20, 0x00	; 0
    15d6:	50 e0       	ldi	r21, 0x00	; 0
    15d8:	be 01       	movw	r22, r28
    15da:	6f 5f       	subi	r22, 0xFF	; 255
    15dc:	7f 4f       	sbci	r23, 0xFF	; 255
    15de:	80 91 eb 37 	lds	r24, 0x37EB
    15e2:	90 91 ec 37 	lds	r25, 0x37EC
    15e6:	46 d9       	rcall	.-3444   	; 0x874 <xQueueGenericSend>
    15e8:	09 c0       	rjmp	.+18     	; 0x15fc <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    15ea:	20 e0       	ldi	r18, 0x00	; 0
    15ec:	ad 01       	movw	r20, r26
    15ee:	be 01       	movw	r22, r28
    15f0:	6f 5f       	subi	r22, 0xFF	; 255
    15f2:	7f 4f       	sbci	r23, 0xFF	; 255
    15f4:	cf 01       	movw	r24, r30
    15f6:	c6 d9       	rcall	.-3188   	; 0x984 <xQueueGenericSendFromISR>
    15f8:	01 c0       	rjmp	.+2      	; 0x15fc <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
portBASE_TYPE xReturn = pdFAIL;
    15fa:	80 e0       	ldi	r24, 0x00	; 0
		
		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}
	
	return xReturn;
}
    15fc:	25 96       	adiw	r28, 0x05	; 5
    15fe:	cd bf       	out	0x3d, r28	; 61
    1600:	de bf       	out	0x3e, r29	; 62
    1602:	df 91       	pop	r29
    1604:	cf 91       	pop	r28
    1606:	1f 91       	pop	r17
    1608:	0f 91       	pop	r16
    160a:	08 95       	ret

0000160c <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
    160c:	af 92       	push	r10
    160e:	bf 92       	push	r11
    1610:	cf 92       	push	r12
    1612:	df 92       	push	r13
    1614:	ef 92       	push	r14
    1616:	ff 92       	push	r15
    1618:	0f 93       	push	r16
    161a:	1f 93       	push	r17
    161c:	cf 93       	push	r28
    161e:	df 93       	push	r29
    1620:	5c 01       	movw	r10, r24
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
    1622:	04 dc       	rcall	.-2040   	; 0xe2c <xTaskGetTickCount>
    1624:	6c 01       	movw	r12, r24
	
	if( xTimeNow < xLastTime )
    1626:	80 91 e9 37 	lds	r24, 0x37E9
    162a:	90 91 ea 37 	lds	r25, 0x37EA
    162e:	c8 16       	cp	r12, r24
    1630:	d9 06       	cpc	r13, r25
    1632:	08 f0       	brcs	.+2      	; 0x1636 <prvSampleTimeNow+0x2a>
    1634:	49 c0       	rjmp	.+146    	; 0x16c8 <prvSampleTimeNow+0xbc>
    1636:	31 c0       	rjmp	.+98     	; 0x169a <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1638:	a5 81       	ldd	r26, Z+5	; 0x05
    163a:	b6 81       	ldd	r27, Z+6	; 0x06
    163c:	ed 90       	ld	r14, X+
    163e:	fc 90       	ld	r15, X

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1640:	05 80       	ldd	r0, Z+5	; 0x05
    1642:	f6 81       	ldd	r31, Z+6	; 0x06
    1644:	e0 2d       	mov	r30, r0
    1646:	c6 81       	ldd	r28, Z+6	; 0x06
    1648:	d7 81       	ldd	r29, Z+7	; 0x07
		vListRemove( &( pxTimer->xTimerListItem ) );
    164a:	8e 01       	movw	r16, r28
    164c:	0e 5f       	subi	r16, 0xFE	; 254
    164e:	1f 4f       	sbci	r17, 0xFF	; 255
    1650:	c8 01       	movw	r24, r16
    1652:	0e 94 1f 03 	call	0x63e	; 0x63e <vListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    1656:	e9 89       	ldd	r30, Y+17	; 0x11
    1658:	fa 89       	ldd	r31, Y+18	; 0x12
    165a:	ce 01       	movw	r24, r28
    165c:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    165e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1660:	81 30       	cpi	r24, 0x01	; 1
    1662:	d9 f4       	brne	.+54     	; 0x169a <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1664:	8c 85       	ldd	r24, Y+12	; 0x0c
    1666:	9d 85       	ldd	r25, Y+13	; 0x0d
    1668:	8e 0d       	add	r24, r14
    166a:	9f 1d       	adc	r25, r15
			if( xReloadTime > xNextExpireTime )
    166c:	e8 16       	cp	r14, r24
    166e:	f9 06       	cpc	r15, r25
    1670:	60 f4       	brcc	.+24     	; 0x168a <prvSampleTimeNow+0x7e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1672:	8a 83       	std	Y+2, r24	; 0x02
    1674:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1676:	c8 87       	std	Y+8, r28	; 0x08
    1678:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    167a:	b8 01       	movw	r22, r16
    167c:	80 91 ef 37 	lds	r24, 0x37EF
    1680:	90 91 f0 37 	lds	r25, 0x37F0
    1684:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsert>
    1688:	08 c0       	rjmp	.+16     	; 0x169a <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    168a:	00 e0       	ldi	r16, 0x00	; 0
    168c:	10 e0       	ldi	r17, 0x00	; 0
    168e:	20 e0       	ldi	r18, 0x00	; 0
    1690:	30 e0       	ldi	r19, 0x00	; 0
    1692:	a7 01       	movw	r20, r14
    1694:	60 e0       	ldi	r22, 0x00	; 0
    1696:	ce 01       	movw	r24, r28
    1698:	77 df       	rcall	.-274    	; 0x1588 <xTimerGenericCommand>
	
	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    169a:	e0 91 ef 37 	lds	r30, 0x37EF
    169e:	f0 91 f0 37 	lds	r31, 0x37F0
    16a2:	80 81       	ld	r24, Z
    16a4:	81 11       	cpse	r24, r1
    16a6:	c8 cf       	rjmp	.-112    	; 0x1638 <prvSampleTimeNow+0x2c>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    16a8:	80 91 ed 37 	lds	r24, 0x37ED
    16ac:	90 91 ee 37 	lds	r25, 0x37EE
    16b0:	80 93 ef 37 	sts	0x37EF, r24
    16b4:	90 93 f0 37 	sts	0x37F0, r25
	pxOverflowTimerList = pxTemp;
    16b8:	e0 93 ed 37 	sts	0x37ED, r30
    16bc:	f0 93 ee 37 	sts	0x37EE, r31
	xTimeNow = xTaskGetTickCount();
	
	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists( xLastTime );
		*pxTimerListsWereSwitched = pdTRUE;
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	f5 01       	movw	r30, r10
    16c4:	80 83       	st	Z, r24
    16c6:	02 c0       	rjmp	.+4      	; 0x16cc <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    16c8:	f5 01       	movw	r30, r10
    16ca:	10 82       	st	Z, r1
	}
	
	xLastTime = xTimeNow;
    16cc:	c0 92 e9 37 	sts	0x37E9, r12
    16d0:	d0 92 ea 37 	sts	0x37EA, r13
	
	return xTimeNow;
}
    16d4:	c6 01       	movw	r24, r12
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	1f 91       	pop	r17
    16dc:	0f 91       	pop	r16
    16de:	ff 90       	pop	r15
    16e0:	ef 90       	pop	r14
    16e2:	df 90       	pop	r13
    16e4:	cf 90       	pop	r12
    16e6:	bf 90       	pop	r11
    16e8:	af 90       	pop	r10
    16ea:	08 95       	ret

000016ec <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    16ec:	cf 93       	push	r28
    16ee:	df 93       	push	r29
    16f0:	00 d0       	rcall	.+0      	; 0x16f2 <prvTimerTask+0x6>
    16f2:	00 d0       	rcall	.+0      	; 0x16f4 <prvTimerTask+0x8>
    16f4:	cd b7       	in	r28, 0x3d	; 61
    16f6:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    16f8:	ce 01       	movw	r24, r28
    16fa:	01 96       	adiw	r24, 0x01	; 1
    16fc:	5c 01       	movw	r10, r24

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    16fe:	88 2e       	mov	r8, r24
    1700:	9b 2c       	mov	r9, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1702:	e0 91 ef 37 	lds	r30, 0x37EF
    1706:	f0 91 f0 37 	lds	r31, 0x37F0
    170a:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    170c:	88 23       	and	r24, r24
    170e:	09 f4       	brne	.+2      	; 0x1712 <prvTimerTask+0x26>
    1710:	b0 c0       	rjmp	.+352    	; 0x1872 <prvTimerTask+0x186>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1712:	05 80       	ldd	r0, Z+5	; 0x05
    1714:	f6 81       	ldd	r31, Z+6	; 0x06
    1716:	e0 2d       	mov	r30, r0
    1718:	e0 80       	ld	r14, Z
    171a:	f1 80       	ldd	r15, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    171c:	81 db       	rcall	.-2302   	; 0xe20 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    171e:	c5 01       	movw	r24, r10
    1720:	75 df       	rcall	.-278    	; 0x160c <prvSampleTimeNow>
    1722:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1724:	89 81       	ldd	r24, Y+1	; 0x01
    1726:	81 11       	cpse	r24, r1
    1728:	43 c0       	rjmp	.+134    	; 0x17b0 <prvTimerTask+0xc4>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    172a:	0e 15       	cp	r16, r14
    172c:	1f 05       	cpc	r17, r15
    172e:	90 f1       	brcs	.+100    	; 0x1794 <prvTimerTask+0xa8>
			{
				xTaskResumeAll();
    1730:	48 dc       	rcall	.-1904   	; 0xfc2 <xTaskResumeAll>
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1732:	e0 91 ef 37 	lds	r30, 0x37EF
    1736:	f0 91 f0 37 	lds	r31, 0x37F0
    173a:	05 80       	ldd	r0, Z+5	; 0x05
    173c:	f6 81       	ldd	r31, Z+6	; 0x06
    173e:	e0 2d       	mov	r30, r0
    1740:	c6 80       	ldd	r12, Z+6	; 0x06
    1742:	d7 80       	ldd	r13, Z+7	; 0x07
	vListRemove( &( pxTimer->xTimerListItem ) );
    1744:	c6 01       	movw	r24, r12
    1746:	02 96       	adiw	r24, 0x02	; 2
    1748:	0e 94 1f 03 	call	0x63e	; 0x63e <vListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    174c:	d6 01       	movw	r26, r12
    174e:	1e 96       	adiw	r26, 0x0e	; 14
    1750:	8c 91       	ld	r24, X
    1752:	1e 97       	sbiw	r26, 0x0e	; 14
    1754:	81 30       	cpi	r24, 0x01	; 1
    1756:	a1 f4       	brne	.+40     	; 0x1780 <prvTimerTask+0x94>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    1758:	1c 96       	adiw	r26, 0x0c	; 12
    175a:	6d 91       	ld	r22, X+
    175c:	7c 91       	ld	r23, X
    175e:	1d 97       	sbiw	r26, 0x0d	; 13
    1760:	6e 0d       	add	r22, r14
    1762:	7f 1d       	adc	r23, r15
    1764:	97 01       	movw	r18, r14
    1766:	a8 01       	movw	r20, r16
    1768:	c6 01       	movw	r24, r12
    176a:	94 de       	rcall	.-728    	; 0x1494 <prvInsertTimerInActiveList>
    176c:	81 30       	cpi	r24, 0x01	; 1
    176e:	41 f4       	brne	.+16     	; 0x1780 <prvTimerTask+0x94>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    1770:	00 e0       	ldi	r16, 0x00	; 0
    1772:	10 e0       	ldi	r17, 0x00	; 0
    1774:	20 e0       	ldi	r18, 0x00	; 0
    1776:	30 e0       	ldi	r19, 0x00	; 0
    1778:	a7 01       	movw	r20, r14
    177a:	60 e0       	ldi	r22, 0x00	; 0
    177c:	c6 01       	movw	r24, r12
    177e:	04 df       	rcall	.-504    	; 0x1588 <xTimerGenericCommand>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    1780:	d6 01       	movw	r26, r12
    1782:	51 96       	adiw	r26, 0x11	; 17
    1784:	ed 91       	ld	r30, X+
    1786:	fc 91       	ld	r31, X
    1788:	52 97       	sbiw	r26, 0x12	; 18
    178a:	c6 01       	movw	r24, r12
    178c:	19 95       	eicall
    178e:	11 c0       	rjmp	.+34     	; 0x17b2 <prvTimerTask+0xc6>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
    1790:	e1 2c       	mov	r14, r1
    1792:	f1 2c       	mov	r15, r1
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    1794:	b7 01       	movw	r22, r14
    1796:	60 1b       	sub	r22, r16
    1798:	71 0b       	sbc	r23, r17
    179a:	80 91 eb 37 	lds	r24, 0x37EB
    179e:	90 91 ec 37 	lds	r25, 0x37EC
    17a2:	c8 d9       	rcall	.-3184   	; 0xb34 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    17a4:	0e dc       	rcall	.-2020   	; 0xfc2 <xTaskResumeAll>
    17a6:	81 11       	cpse	r24, r1
    17a8:	04 c0       	rjmp	.+8      	; 0x17b2 <prvTimerTask+0xc6>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
    17aa:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vPortYield>
    17ae:	01 c0       	rjmp	.+2      	; 0x17b2 <prvTimerTask+0xc6>
				}
			}
		}
		else
		{
			xTaskResumeAll();
    17b0:	08 dc       	rcall	.-2032   	; 0xfc2 <xTaskResumeAll>
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    17b2:	ce 01       	movw	r24, r28
    17b4:	06 96       	adiw	r24, 0x06	; 6
    17b6:	2a df       	rcall	.-428    	; 0x160c <prvSampleTimeNow>
    17b8:	6c 01       	movw	r12, r24
    17ba:	4e c0       	rjmp	.+156    	; 0x1858 <prvTimerTask+0x16c>

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
    17bc:	ec 80       	ldd	r14, Y+4	; 0x04
    17be:	fd 80       	ldd	r15, Y+5	; 0x05

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
    17c0:	e1 14       	cp	r14, r1
    17c2:	f1 04       	cpc	r15, r1
    17c4:	59 f0       	breq	.+22     	; 0x17dc <prvTimerTask+0xf0>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    17c6:	d7 01       	movw	r26, r14
    17c8:	1a 96       	adiw	r26, 0x0a	; 10
    17ca:	ed 91       	ld	r30, X+
    17cc:	fc 91       	ld	r31, X
    17ce:	1b 97       	sbiw	r26, 0x0b	; 11
    17d0:	ef 2b       	or	r30, r31
    17d2:	21 f0       	breq	.+8      	; 0x17dc <prvTimerTask+0xf0>
			{
				/* The timer is in a list, remove it. */
				vListRemove( &( pxTimer->xTimerListItem ) );
    17d4:	c7 01       	movw	r24, r14
    17d6:	02 96       	adiw	r24, 0x02	; 2
    17d8:	0e 94 1f 03 	call	0x63e	; 0x63e <vListRemove>
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
		
		switch( xMessage.xMessageID )
    17dc:	89 81       	ldd	r24, Y+1	; 0x01
    17de:	82 30       	cpi	r24, 0x02	; 2
    17e0:	49 f1       	breq	.+82     	; 0x1834 <prvTimerTask+0x148>
    17e2:	83 30       	cpi	r24, 0x03	; 3
    17e4:	b1 f1       	breq	.+108    	; 0x1852 <prvTimerTask+0x166>
    17e6:	81 11       	cpse	r24, r1
    17e8:	37 c0       	rjmp	.+110    	; 0x1858 <prvTimerTask+0x16c>
		{
			case tmrCOMMAND_START :	
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
    17ea:	2a 81       	ldd	r18, Y+2	; 0x02
    17ec:	3b 81       	ldd	r19, Y+3	; 0x03
    17ee:	f7 01       	movw	r30, r14
    17f0:	64 85       	ldd	r22, Z+12	; 0x0c
    17f2:	75 85       	ldd	r23, Z+13	; 0x0d
    17f4:	62 0f       	add	r22, r18
    17f6:	73 1f       	adc	r23, r19
    17f8:	a6 01       	movw	r20, r12
    17fa:	c7 01       	movw	r24, r14
    17fc:	4b de       	rcall	.-874    	; 0x1494 <prvInsertTimerInActiveList>
    17fe:	81 30       	cpi	r24, 0x01	; 1
    1800:	59 f5       	brne	.+86     	; 0x1858 <prvTimerTask+0x16c>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    1802:	d7 01       	movw	r26, r14
    1804:	51 96       	adiw	r26, 0x11	; 17
    1806:	ed 91       	ld	r30, X+
    1808:	fc 91       	ld	r31, X
    180a:	52 97       	sbiw	r26, 0x12	; 18
    180c:	c7 01       	movw	r24, r14
    180e:	19 95       	eicall

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    1810:	f7 01       	movw	r30, r14
    1812:	86 85       	ldd	r24, Z+14	; 0x0e
    1814:	81 30       	cpi	r24, 0x01	; 1
    1816:	01 f5       	brne	.+64     	; 0x1858 <prvTimerTask+0x16c>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1818:	44 85       	ldd	r20, Z+12	; 0x0c
    181a:	55 85       	ldd	r21, Z+13	; 0x0d
    181c:	8a 81       	ldd	r24, Y+2	; 0x02
    181e:	9b 81       	ldd	r25, Y+3	; 0x03
    1820:	48 0f       	add	r20, r24
    1822:	59 1f       	adc	r21, r25
    1824:	00 e0       	ldi	r16, 0x00	; 0
    1826:	10 e0       	ldi	r17, 0x00	; 0
    1828:	20 e0       	ldi	r18, 0x00	; 0
    182a:	30 e0       	ldi	r19, 0x00	; 0
    182c:	60 e0       	ldi	r22, 0x00	; 0
    182e:	c7 01       	movw	r24, r14
    1830:	ab de       	rcall	.-682    	; 0x1588 <xTimerGenericCommand>
    1832:	12 c0       	rjmp	.+36     	; 0x1858 <prvTimerTask+0x16c>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
    1834:	2a 81       	ldd	r18, Y+2	; 0x02
    1836:	3b 81       	ldd	r19, Y+3	; 0x03
    1838:	d7 01       	movw	r26, r14
    183a:	1c 96       	adiw	r26, 0x0c	; 12
    183c:	2d 93       	st	X+, r18
    183e:	3c 93       	st	X, r19
    1840:	1d 97       	sbiw	r26, 0x0d	; 13
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1842:	b6 01       	movw	r22, r12
    1844:	62 0f       	add	r22, r18
    1846:	73 1f       	adc	r23, r19
    1848:	96 01       	movw	r18, r12
    184a:	a6 01       	movw	r20, r12
    184c:	c7 01       	movw	r24, r14
    184e:	22 de       	rcall	.-956    	; 0x1494 <prvInsertTimerInActiveList>
    1850:	03 c0       	rjmp	.+6      	; 0x1858 <prvTimerTask+0x16c>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
    1852:	c7 01       	movw	r24, r14
    1854:	0e 94 49 01 	call	0x292	; 0x292 <vPortFree>

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    1858:	20 e0       	ldi	r18, 0x00	; 0
    185a:	40 e0       	ldi	r20, 0x00	; 0
    185c:	50 e0       	ldi	r21, 0x00	; 0
    185e:	68 2d       	mov	r22, r8
    1860:	79 2d       	mov	r23, r9
    1862:	80 91 eb 37 	lds	r24, 0x37EB
    1866:	90 91 ec 37 	lds	r25, 0x37EC
    186a:	b6 d8       	rcall	.-3732   	; 0x9d8 <xQueueGenericReceive>
    186c:	81 11       	cpse	r24, r1
    186e:	a6 cf       	rjmp	.-180    	; 0x17bc <prvTimerTask+0xd0>
    1870:	48 cf       	rjmp	.-368    	; 0x1702 <prvTimerTask+0x16>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    1872:	d6 da       	rcall	.-2644   	; 0xe20 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1874:	c5 01       	movw	r24, r10
    1876:	ca de       	rcall	.-620    	; 0x160c <prvSampleTimeNow>
    1878:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    187a:	89 81       	ldd	r24, Y+1	; 0x01
    187c:	88 23       	and	r24, r24
    187e:	09 f4       	brne	.+2      	; 0x1882 <prvTimerTask+0x196>
    1880:	87 cf       	rjmp	.-242    	; 0x1790 <prvTimerTask+0xa4>
    1882:	96 cf       	rjmp	.-212    	; 0x17b0 <prvTimerTask+0xc4>

00001884 <blink1>:
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1884:	c0 e0       	ldi	r28, 0x00	; 0
    1886:	d6 e0       	ldi	r29, 0x06	; 6
    1888:	10 e1       	ldi	r17, 0x10	; 16
    188a:	01 2f       	mov	r16, r17
    188c:	0d 83       	std	Y+5, r16	; 0x05
void blink1(void *p) {
	
	while (1) {
		
        ioport_set_pin_level(RED, true);
		vTaskDelay(1000);
    188e:	88 ee       	ldi	r24, 0xE8	; 232
    1890:	93 e0       	ldi	r25, 0x03	; 3
    1892:	1f dc       	rcall	.-1986   	; 0x10d2 <vTaskDelay>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    1894:	1e 83       	std	Y+6, r17	; 0x06
        ioport_set_pin_level(RED, false);
        vTaskDelay(1000);
    1896:	88 ee       	ldi	r24, 0xE8	; 232
    1898:	93 e0       	ldi	r25, 0x03	; 3
    189a:	1b dc       	rcall	.-1994   	; 0x10d2 <vTaskDelay>
    189c:	f7 cf       	rjmp	.-18     	; 0x188c <blink1+0x8>

0000189e <blink2>:
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    189e:	c0 e0       	ldi	r28, 0x00	; 0
    18a0:	d6 e0       	ldi	r29, 0x06	; 6
    18a2:	11 e0       	ldi	r17, 0x01	; 1
    18a4:	01 2f       	mov	r16, r17
    18a6:	0d 83       	std	Y+5, r16	; 0x05
void blink2(void *p) {
	
	while (1) {
		
		ioport_set_pin_level(YELLOW, true);
		vTaskDelay(100);
    18a8:	84 e6       	ldi	r24, 0x64	; 100
    18aa:	90 e0       	ldi	r25, 0x00	; 0
    18ac:	12 dc       	rcall	.-2012   	; 0x10d2 <vTaskDelay>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    18ae:	1e 83       	std	Y+6, r17	; 0x06
		ioport_set_pin_level(YELLOW, false);
		vTaskDelay(100);
    18b0:	84 e6       	ldi	r24, 0x64	; 100
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	0e dc       	rcall	.-2020   	; 0x10d2 <vTaskDelay>
    18b6:	f7 cf       	rjmp	.-18     	; 0x18a6 <blink2+0x8>

000018b8 <main>:
	}
}

int main(void)
{	
    18b8:	af 92       	push	r10
    18ba:	bf 92       	push	r11
    18bc:	cf 92       	push	r12
    18be:	df 92       	push	r13
    18c0:	ef 92       	push	r14
    18c2:	ff 92       	push	r15
    18c4:	0f 93       	push	r16
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    18c6:	e0 e0       	ldi	r30, 0x00	; 0
    18c8:	f6 e0       	ldi	r31, 0x06	; 6
    18ca:	80 e1       	ldi	r24, 0x10	; 16
    18cc:	81 83       	std	Z+1, r24	; 0x01
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	81 83       	std	Z+1, r24	; 0x01
	ioport_init();
	ioport_set_pin_dir(RED, IOPORT_DIR_OUTPUT);
	ioport_set_pin_dir(YELLOW, IOPORT_DIR_OUTPUT);
			
	// start tasks
	xTaskCreate(blink1, (signed char*) "blink1", 1024, NULL, 1, NULL);
    18d2:	a1 2c       	mov	r10, r1
    18d4:	b1 2c       	mov	r11, r1
    18d6:	c1 2c       	mov	r12, r1
    18d8:	d1 2c       	mov	r13, r1
    18da:	e1 2c       	mov	r14, r1
    18dc:	f1 2c       	mov	r15, r1
    18de:	01 e0       	ldi	r16, 0x01	; 1
    18e0:	20 e0       	ldi	r18, 0x00	; 0
    18e2:	30 e0       	ldi	r19, 0x00	; 0
    18e4:	40 e0       	ldi	r20, 0x00	; 0
    18e6:	54 e0       	ldi	r21, 0x04	; 4
    18e8:	6f e0       	ldi	r22, 0x0F	; 15
    18ea:	70 e2       	ldi	r23, 0x20	; 32
    18ec:	82 e4       	ldi	r24, 0x42	; 66
    18ee:	9c e0       	ldi	r25, 0x0C	; 12
    18f0:	78 d9       	rcall	.-3344   	; 0xbe2 <xTaskGenericCreate>
	xTaskCreate(blink2, (signed char*) "blink2", 1024, NULL, 1, NULL);
    18f2:	20 e0       	ldi	r18, 0x00	; 0
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	40 e0       	ldi	r20, 0x00	; 0
    18f8:	54 e0       	ldi	r21, 0x04	; 4
    18fa:	66 e1       	ldi	r22, 0x16	; 22
    18fc:	70 e2       	ldi	r23, 0x20	; 32
    18fe:	8f e4       	ldi	r24, 0x4F	; 79
    1900:	9c e0       	ldi	r25, 0x0C	; 12
    1902:	6f d9       	rcall	.-3362   	; 0xbe2 <xTaskGenericCreate>
	
	vTaskStartScheduler();
    1904:	61 da       	rcall	.-2878   	; 0xdc8 <vTaskStartScheduler>
	
	return 0;
    1906:	80 e0       	ldi	r24, 0x00	; 0
    1908:	90 e0       	ldi	r25, 0x00	; 0
    190a:	0f 91       	pop	r16
    190c:	ff 90       	pop	r15
    190e:	ef 90       	pop	r14
    1910:	df 90       	pop	r13
    1912:	cf 90       	pop	r12
    1914:	bf 90       	pop	r11
    1916:	af 90       	pop	r10
    1918:	08 95       	ret

0000191a <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
    191a:	fc 01       	movw	r30, r24
    191c:	20 81       	ld	r18, Z
    191e:	20 7f       	andi	r18, 0xF0	; 240
    1920:	62 2b       	or	r22, r18
    1922:	60 83       	st	Z, r22
    1924:	08 95       	ret

00001926 <TC0_SetOverflowIntLevel>:
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    1926:	fc 01       	movw	r30, r24
    1928:	26 81       	ldd	r18, Z+6	; 0x06
    192a:	2c 7f       	andi	r18, 0xFC	; 252
    192c:	62 2b       	or	r22, r18
    192e:	66 83       	std	Z+6, r22	; 0x06
    1930:	08 95       	ret

00001932 <memcpy>:
    1932:	fb 01       	movw	r30, r22
    1934:	dc 01       	movw	r26, r24
    1936:	02 c0       	rjmp	.+4      	; 0x193c <memcpy+0xa>
    1938:	01 90       	ld	r0, Z+
    193a:	0d 92       	st	X+, r0
    193c:	41 50       	subi	r20, 0x01	; 1
    193e:	50 40       	sbci	r21, 0x00	; 0
    1940:	d8 f7       	brcc	.-10     	; 0x1938 <memcpy+0x6>
    1942:	08 95       	ret

00001944 <memset>:
    1944:	dc 01       	movw	r26, r24
    1946:	01 c0       	rjmp	.+2      	; 0x194a <memset+0x6>
    1948:	6d 93       	st	X+, r22
    194a:	41 50       	subi	r20, 0x01	; 1
    194c:	50 40       	sbci	r21, 0x00	; 0
    194e:	e0 f7       	brcc	.-8      	; 0x1948 <memset+0x4>
    1950:	08 95       	ret

00001952 <strncpy>:
    1952:	fb 01       	movw	r30, r22
    1954:	dc 01       	movw	r26, r24
    1956:	41 50       	subi	r20, 0x01	; 1
    1958:	50 40       	sbci	r21, 0x00	; 0
    195a:	48 f0       	brcs	.+18     	; 0x196e <strncpy+0x1c>
    195c:	01 90       	ld	r0, Z+
    195e:	0d 92       	st	X+, r0
    1960:	00 20       	and	r0, r0
    1962:	c9 f7       	brne	.-14     	; 0x1956 <strncpy+0x4>
    1964:	01 c0       	rjmp	.+2      	; 0x1968 <strncpy+0x16>
    1966:	1d 92       	st	X+, r1
    1968:	41 50       	subi	r20, 0x01	; 1
    196a:	50 40       	sbci	r21, 0x00	; 0
    196c:	e0 f7       	brcc	.-8      	; 0x1966 <strncpy+0x14>
    196e:	08 95       	ret

00001970 <_exit>:
    1970:	f8 94       	cli

00001972 <__stop_program>:
    1972:	ff cf       	rjmp	.-2      	; 0x1972 <__stop_program>
