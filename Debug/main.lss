
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000020c0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000032  00802000  000020c0  00002154  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000017ed  00802032  00802032  00002186  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002186  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000610  00000000  00000000  000021b8  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00009867  00000000  00000000  000027c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001e8e  00000000  00000000  0000c02f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003dc6  00000000  00000000  0000debd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000013a4  00000000  00000000  00011c84  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000036cf  00000000  00000000  00013028  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00005b9a  00000000  00000000  000166f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000005a8  00000000  00000000  0001c298  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	fd c0       	rjmp	.+506    	; 0x1fc <__ctors_end>
       2:	00 00       	nop
       4:	21 c1       	rjmp	.+578    	; 0x248 <__bad_interrupt>
       6:	00 00       	nop
       8:	1f c1       	rjmp	.+574    	; 0x248 <__bad_interrupt>
       a:	00 00       	nop
       c:	1d c1       	rjmp	.+570    	; 0x248 <__bad_interrupt>
       e:	00 00       	nop
      10:	1b c1       	rjmp	.+566    	; 0x248 <__bad_interrupt>
      12:	00 00       	nop
      14:	19 c1       	rjmp	.+562    	; 0x248 <__bad_interrupt>
      16:	00 00       	nop
      18:	17 c1       	rjmp	.+558    	; 0x248 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	15 c1       	rjmp	.+554    	; 0x248 <__bad_interrupt>
      1e:	00 00       	nop
      20:	13 c1       	rjmp	.+550    	; 0x248 <__bad_interrupt>
      22:	00 00       	nop
      24:	11 c1       	rjmp	.+546    	; 0x248 <__bad_interrupt>
      26:	00 00       	nop
      28:	0f c1       	rjmp	.+542    	; 0x248 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	0d c1       	rjmp	.+538    	; 0x248 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0b c1       	rjmp	.+534    	; 0x248 <__bad_interrupt>
      32:	00 00       	nop
      34:	09 c1       	rjmp	.+530    	; 0x248 <__bad_interrupt>
      36:	00 00       	nop
      38:	35 c2       	rjmp	.+1130   	; 0x4a4 <__vector_14>
      3a:	00 00       	nop
      3c:	05 c1       	rjmp	.+522    	; 0x248 <__bad_interrupt>
      3e:	00 00       	nop
      40:	03 c1       	rjmp	.+518    	; 0x248 <__bad_interrupt>
      42:	00 00       	nop
      44:	01 c1       	rjmp	.+514    	; 0x248 <__bad_interrupt>
      46:	00 00       	nop
      48:	ff c0       	rjmp	.+510    	; 0x248 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	fd c0       	rjmp	.+506    	; 0x248 <__bad_interrupt>
      4e:	00 00       	nop
      50:	fb c0       	rjmp	.+502    	; 0x248 <__bad_interrupt>
      52:	00 00       	nop
      54:	f9 c0       	rjmp	.+498    	; 0x248 <__bad_interrupt>
      56:	00 00       	nop
      58:	f7 c0       	rjmp	.+494    	; 0x248 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	f5 c0       	rjmp	.+490    	; 0x248 <__bad_interrupt>
      5e:	00 00       	nop
      60:	f3 c0       	rjmp	.+486    	; 0x248 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 10 0d 	jmp	0x1a20	; 0x1a20 <__vector_25>
      68:	0c 94 18 0e 	jmp	0x1c30	; 0x1c30 <__vector_26>
      6c:	ed c0       	rjmp	.+474    	; 0x248 <__bad_interrupt>
      6e:	00 00       	nop
      70:	eb c0       	rjmp	.+470    	; 0x248 <__bad_interrupt>
      72:	00 00       	nop
      74:	e9 c0       	rjmp	.+466    	; 0x248 <__bad_interrupt>
      76:	00 00       	nop
      78:	e7 c0       	rjmp	.+462    	; 0x248 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	e5 c0       	rjmp	.+458    	; 0x248 <__bad_interrupt>
      7e:	00 00       	nop
      80:	e3 c0       	rjmp	.+454    	; 0x248 <__bad_interrupt>
      82:	00 00       	nop
      84:	e1 c0       	rjmp	.+450    	; 0x248 <__bad_interrupt>
      86:	00 00       	nop
      88:	df c0       	rjmp	.+446    	; 0x248 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	dd c0       	rjmp	.+442    	; 0x248 <__bad_interrupt>
      8e:	00 00       	nop
      90:	db c0       	rjmp	.+438    	; 0x248 <__bad_interrupt>
      92:	00 00       	nop
      94:	d9 c0       	rjmp	.+434    	; 0x248 <__bad_interrupt>
      96:	00 00       	nop
      98:	d7 c0       	rjmp	.+430    	; 0x248 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	d5 c0       	rjmp	.+426    	; 0x248 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	d3 c0       	rjmp	.+422    	; 0x248 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	d1 c0       	rjmp	.+418    	; 0x248 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	cf c0       	rjmp	.+414    	; 0x248 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	cd c0       	rjmp	.+410    	; 0x248 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	cb c0       	rjmp	.+406    	; 0x248 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	c9 c0       	rjmp	.+402    	; 0x248 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	c7 c0       	rjmp	.+398    	; 0x248 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	c5 c0       	rjmp	.+394    	; 0x248 <__bad_interrupt>
      be:	00 00       	nop
      c0:	c3 c0       	rjmp	.+390    	; 0x248 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	c1 c0       	rjmp	.+386    	; 0x248 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	bf c0       	rjmp	.+382    	; 0x248 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	bd c0       	rjmp	.+378    	; 0x248 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	bb c0       	rjmp	.+374    	; 0x248 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	b9 c0       	rjmp	.+370    	; 0x248 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	b7 c0       	rjmp	.+366    	; 0x248 <__bad_interrupt>
      da:	00 00       	nop
      dc:	b5 c0       	rjmp	.+362    	; 0x248 <__bad_interrupt>
      de:	00 00       	nop
      e0:	b3 c0       	rjmp	.+358    	; 0x248 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	b1 c0       	rjmp	.+354    	; 0x248 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	0c 94 c0 0d 	jmp	0x1b80	; 0x1b80 <__vector_58>
      ec:	0c 94 de 0e 	jmp	0x1dbc	; 0x1dbc <__vector_59>
      f0:	ab c0       	rjmp	.+342    	; 0x248 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	a9 c0       	rjmp	.+338    	; 0x248 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	a7 c0       	rjmp	.+334    	; 0x248 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	a5 c0       	rjmp	.+330    	; 0x248 <__bad_interrupt>
      fe:	00 00       	nop
     100:	a3 c0       	rjmp	.+326    	; 0x248 <__bad_interrupt>
     102:	00 00       	nop
     104:	a1 c0       	rjmp	.+322    	; 0x248 <__bad_interrupt>
     106:	00 00       	nop
     108:	9f c0       	rjmp	.+318    	; 0x248 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	9d c0       	rjmp	.+314    	; 0x248 <__bad_interrupt>
     10e:	00 00       	nop
     110:	9b c0       	rjmp	.+310    	; 0x248 <__bad_interrupt>
     112:	00 00       	nop
     114:	99 c0       	rjmp	.+306    	; 0x248 <__bad_interrupt>
     116:	00 00       	nop
     118:	97 c0       	rjmp	.+302    	; 0x248 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	95 c0       	rjmp	.+298    	; 0x248 <__bad_interrupt>
     11e:	00 00       	nop
     120:	93 c0       	rjmp	.+294    	; 0x248 <__bad_interrupt>
     122:	00 00       	nop
     124:	91 c0       	rjmp	.+290    	; 0x248 <__bad_interrupt>
     126:	00 00       	nop
     128:	8f c0       	rjmp	.+286    	; 0x248 <__bad_interrupt>
     12a:	00 00       	nop
     12c:	8d c0       	rjmp	.+282    	; 0x248 <__bad_interrupt>
     12e:	00 00       	nop
     130:	8b c0       	rjmp	.+278    	; 0x248 <__bad_interrupt>
     132:	00 00       	nop
     134:	89 c0       	rjmp	.+274    	; 0x248 <__bad_interrupt>
     136:	00 00       	nop
     138:	87 c0       	rjmp	.+270    	; 0x248 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	85 c0       	rjmp	.+266    	; 0x248 <__bad_interrupt>
     13e:	00 00       	nop
     140:	83 c0       	rjmp	.+262    	; 0x248 <__bad_interrupt>
     142:	00 00       	nop
     144:	81 c0       	rjmp	.+258    	; 0x248 <__bad_interrupt>
     146:	00 00       	nop
     148:	7f c0       	rjmp	.+254    	; 0x248 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	7d c0       	rjmp	.+250    	; 0x248 <__bad_interrupt>
     14e:	00 00       	nop
     150:	7b c0       	rjmp	.+246    	; 0x248 <__bad_interrupt>
     152:	00 00       	nop
     154:	79 c0       	rjmp	.+242    	; 0x248 <__bad_interrupt>
     156:	00 00       	nop
     158:	77 c0       	rjmp	.+238    	; 0x248 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	75 c0       	rjmp	.+234    	; 0x248 <__bad_interrupt>
     15e:	00 00       	nop
     160:	0c 94 68 0d 	jmp	0x1ad0	; 0x1ad0 <__vector_88>
     164:	0c 94 7b 0e 	jmp	0x1cf6	; 0x1cf6 <__vector_89>
     168:	6f c0       	rjmp	.+222    	; 0x248 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	6d c0       	rjmp	.+218    	; 0x248 <__bad_interrupt>
     16e:	00 00       	nop
     170:	6b c0       	rjmp	.+214    	; 0x248 <__bad_interrupt>
     172:	00 00       	nop
     174:	69 c0       	rjmp	.+210    	; 0x248 <__bad_interrupt>
     176:	00 00       	nop
     178:	67 c0       	rjmp	.+206    	; 0x248 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	65 c0       	rjmp	.+202    	; 0x248 <__bad_interrupt>
     17e:	00 00       	nop
     180:	63 c0       	rjmp	.+198    	; 0x248 <__bad_interrupt>
     182:	00 00       	nop
     184:	61 c0       	rjmp	.+194    	; 0x248 <__bad_interrupt>
     186:	00 00       	nop
     188:	5f c0       	rjmp	.+190    	; 0x248 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	5d c0       	rjmp	.+186    	; 0x248 <__bad_interrupt>
     18e:	00 00       	nop
     190:	5b c0       	rjmp	.+182    	; 0x248 <__bad_interrupt>
     192:	00 00       	nop
     194:	59 c0       	rjmp	.+178    	; 0x248 <__bad_interrupt>
     196:	00 00       	nop
     198:	57 c0       	rjmp	.+174    	; 0x248 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	55 c0       	rjmp	.+170    	; 0x248 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	53 c0       	rjmp	.+166    	; 0x248 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	51 c0       	rjmp	.+162    	; 0x248 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	4f c0       	rjmp	.+158    	; 0x248 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	4d c0       	rjmp	.+154    	; 0x248 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	4b c0       	rjmp	.+150    	; 0x248 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	49 c0       	rjmp	.+146    	; 0x248 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	47 c0       	rjmp	.+142    	; 0x248 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	45 c0       	rjmp	.+138    	; 0x248 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	43 c0       	rjmp	.+134    	; 0x248 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	41 c0       	rjmp	.+130    	; 0x248 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	3f c0       	rjmp	.+126    	; 0x248 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	3d c0       	rjmp	.+122    	; 0x248 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	3b c0       	rjmp	.+118    	; 0x248 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	39 c0       	rjmp	.+114    	; 0x248 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	37 c0       	rjmp	.+110    	; 0x248 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	35 c0       	rjmp	.+106    	; 0x248 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	33 c0       	rjmp	.+102    	; 0x248 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	31 c0       	rjmp	.+98     	; 0x248 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	2f c0       	rjmp	.+94     	; 0x248 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	2d c0       	rjmp	.+90     	; 0x248 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	2b c0       	rjmp	.+86     	; 0x248 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	29 c0       	rjmp	.+82     	; 0x248 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	27 c0       	rjmp	.+78     	; 0x248 <__bad_interrupt>
	...

000001fc <__ctors_end>:
     1fc:	11 24       	eor	r1, r1
     1fe:	1f be       	out	0x3f, r1	; 63
     200:	cf ef       	ldi	r28, 0xFF	; 255
     202:	cd bf       	out	0x3d, r28	; 61
     204:	df e3       	ldi	r29, 0x3F	; 63
     206:	de bf       	out	0x3e, r29	; 62
     208:	00 e0       	ldi	r16, 0x00	; 0
     20a:	0c bf       	out	0x3c, r16	; 60
     20c:	18 be       	out	0x38, r1	; 56
     20e:	19 be       	out	0x39, r1	; 57
     210:	1a be       	out	0x3a, r1	; 58
     212:	1b be       	out	0x3b, r1	; 59

00000214 <__do_copy_data>:
     214:	10 e2       	ldi	r17, 0x20	; 32
     216:	a0 e0       	ldi	r26, 0x00	; 0
     218:	b0 e2       	ldi	r27, 0x20	; 32
     21a:	e0 ec       	ldi	r30, 0xC0	; 192
     21c:	f0 e2       	ldi	r31, 0x20	; 32
     21e:	00 e0       	ldi	r16, 0x00	; 0
     220:	0b bf       	out	0x3b, r16	; 59
     222:	02 c0       	rjmp	.+4      	; 0x228 <__do_copy_data+0x14>
     224:	07 90       	elpm	r0, Z+
     226:	0d 92       	st	X+, r0
     228:	a2 33       	cpi	r26, 0x32	; 50
     22a:	b1 07       	cpc	r27, r17
     22c:	d9 f7       	brne	.-10     	; 0x224 <__do_copy_data+0x10>
     22e:	1b be       	out	0x3b, r1	; 59

00000230 <__do_clear_bss>:
     230:	28 e3       	ldi	r18, 0x38	; 56
     232:	a2 e3       	ldi	r26, 0x32	; 50
     234:	b0 e2       	ldi	r27, 0x20	; 32
     236:	01 c0       	rjmp	.+2      	; 0x23a <.do_clear_bss_start>

00000238 <.do_clear_bss_loop>:
     238:	1d 92       	st	X+, r1

0000023a <.do_clear_bss_start>:
     23a:	af 31       	cpi	r26, 0x1F	; 31
     23c:	b2 07       	cpc	r27, r18
     23e:	e1 f7       	brne	.-8      	; 0x238 <.do_clear_bss_loop>
     240:	0e 94 b0 0c 	call	0x1960	; 0x1960 <main>
     244:	0c 94 5e 10 	jmp	0x20bc	; 0x20bc <_exit>

00000248 <__bad_interrupt>:
     248:	db ce       	rjmp	.-586    	; 0x0 <__vectors>

0000024a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     24a:	cf 93       	push	r28
     24c:	df 93       	push	r29
     24e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     250:	14 d6       	rcall	.+3112   	; 0xe7a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     252:	40 91 32 20 	lds	r20, 0x2032
     256:	50 91 33 20 	lds	r21, 0x2033
     25a:	9e 01       	movw	r18, r28
     25c:	24 0f       	add	r18, r20
     25e:	35 1f       	adc	r19, r21
     260:	20 37       	cpi	r18, 0x70	; 112
     262:	87 e1       	ldi	r24, 0x17	; 23
     264:	38 07       	cpc	r19, r24
     266:	58 f4       	brcc	.+22     	; 0x27e <pvPortMalloc+0x34>
     268:	42 17       	cp	r20, r18
     26a:	53 07       	cpc	r21, r19
     26c:	58 f4       	brcc	.+22     	; 0x284 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     26e:	ea 01       	movw	r28, r20
     270:	cc 5c       	subi	r28, 0xCC	; 204
     272:	df 4d       	sbci	r29, 0xDF	; 223
			xNextFreeByte += xWantedSize;			
     274:	20 93 32 20 	sts	0x2032, r18
     278:	30 93 33 20 	sts	0x2033, r19
     27c:	05 c0       	rjmp	.+10     	; 0x288 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     27e:	c0 e0       	ldi	r28, 0x00	; 0
     280:	d0 e0       	ldi	r29, 0x00	; 0
     282:	02 c0       	rjmp	.+4      	; 0x288 <pvPortMalloc+0x3e>
     284:	c0 e0       	ldi	r28, 0x00	; 0
     286:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     288:	c9 d6       	rcall	.+3474   	; 0x101c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     28a:	ce 01       	movw	r24, r28
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	08 95       	ret

00000292 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     292:	08 95       	ret

00000294 <pxPortInitialiseStack>:
    /* Should not get here. */
    return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler(void) {
     294:	31 e1       	ldi	r19, 0x11	; 17
     296:	fc 01       	movw	r30, r24
     298:	30 83       	st	Z, r19
     29a:	31 97       	sbiw	r30, 0x01	; 1
     29c:	22 e2       	ldi	r18, 0x22	; 34
     29e:	20 83       	st	Z, r18
     2a0:	31 97       	sbiw	r30, 0x01	; 1
     2a2:	a3 e3       	ldi	r26, 0x33	; 51
     2a4:	a0 83       	st	Z, r26
     2a6:	31 97       	sbiw	r30, 0x01	; 1
     2a8:	60 83       	st	Z, r22
     2aa:	31 97       	sbiw	r30, 0x01	; 1
     2ac:	70 83       	st	Z, r23
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	10 82       	st	Z, r1
     2b2:	31 97       	sbiw	r30, 0x01	; 1
     2b4:	10 82       	st	Z, r1
     2b6:	31 97       	sbiw	r30, 0x01	; 1
     2b8:	60 e8       	ldi	r22, 0x80	; 128
     2ba:	60 83       	st	Z, r22
     2bc:	31 97       	sbiw	r30, 0x01	; 1
     2be:	10 82       	st	Z, r1
     2c0:	31 97       	sbiw	r30, 0x01	; 1
     2c2:	62 e0       	ldi	r22, 0x02	; 2
     2c4:	60 83       	st	Z, r22
     2c6:	31 97       	sbiw	r30, 0x01	; 1
     2c8:	63 e0       	ldi	r22, 0x03	; 3
     2ca:	60 83       	st	Z, r22
     2cc:	31 97       	sbiw	r30, 0x01	; 1
     2ce:	64 e0       	ldi	r22, 0x04	; 4
     2d0:	60 83       	st	Z, r22
     2d2:	31 97       	sbiw	r30, 0x01	; 1
     2d4:	65 e0       	ldi	r22, 0x05	; 5
     2d6:	60 83       	st	Z, r22
     2d8:	31 97       	sbiw	r30, 0x01	; 1
     2da:	66 e0       	ldi	r22, 0x06	; 6
     2dc:	60 83       	st	Z, r22
     2de:	31 97       	sbiw	r30, 0x01	; 1
     2e0:	67 e0       	ldi	r22, 0x07	; 7
     2e2:	60 83       	st	Z, r22
     2e4:	31 97       	sbiw	r30, 0x01	; 1
     2e6:	68 e0       	ldi	r22, 0x08	; 8
     2e8:	60 83       	st	Z, r22
     2ea:	31 97       	sbiw	r30, 0x01	; 1
     2ec:	69 e0       	ldi	r22, 0x09	; 9
     2ee:	60 83       	st	Z, r22
     2f0:	31 97       	sbiw	r30, 0x01	; 1
     2f2:	60 e1       	ldi	r22, 0x10	; 16
     2f4:	60 83       	st	Z, r22
     2f6:	31 97       	sbiw	r30, 0x01	; 1
     2f8:	30 83       	st	Z, r19
     2fa:	31 97       	sbiw	r30, 0x01	; 1
     2fc:	32 e1       	ldi	r19, 0x12	; 18
     2fe:	30 83       	st	Z, r19
     300:	31 97       	sbiw	r30, 0x01	; 1
     302:	33 e1       	ldi	r19, 0x13	; 19
     304:	30 83       	st	Z, r19
     306:	31 97       	sbiw	r30, 0x01	; 1
     308:	34 e1       	ldi	r19, 0x14	; 20
     30a:	30 83       	st	Z, r19
     30c:	31 97       	sbiw	r30, 0x01	; 1
     30e:	35 e1       	ldi	r19, 0x15	; 21
     310:	30 83       	st	Z, r19
     312:	31 97       	sbiw	r30, 0x01	; 1
     314:	36 e1       	ldi	r19, 0x16	; 22
     316:	30 83       	st	Z, r19
     318:	31 97       	sbiw	r30, 0x01	; 1
     31a:	37 e1       	ldi	r19, 0x17	; 23
     31c:	30 83       	st	Z, r19
     31e:	31 97       	sbiw	r30, 0x01	; 1
     320:	38 e1       	ldi	r19, 0x18	; 24
     322:	30 83       	st	Z, r19
     324:	31 97       	sbiw	r30, 0x01	; 1
     326:	39 e1       	ldi	r19, 0x19	; 25
     328:	30 83       	st	Z, r19
     32a:	31 97       	sbiw	r30, 0x01	; 1
     32c:	30 e2       	ldi	r19, 0x20	; 32
     32e:	30 83       	st	Z, r19
     330:	31 97       	sbiw	r30, 0x01	; 1
     332:	31 e2       	ldi	r19, 0x21	; 33
     334:	30 83       	st	Z, r19
     336:	31 97       	sbiw	r30, 0x01	; 1
     338:	20 83       	st	Z, r18
     33a:	31 97       	sbiw	r30, 0x01	; 1
     33c:	23 e2       	ldi	r18, 0x23	; 35
     33e:	20 83       	st	Z, r18
     340:	31 97       	sbiw	r30, 0x01	; 1
     342:	40 83       	st	Z, r20
     344:	31 97       	sbiw	r30, 0x01	; 1
     346:	50 83       	st	Z, r21
     348:	31 97       	sbiw	r30, 0x01	; 1
     34a:	26 e2       	ldi	r18, 0x26	; 38
     34c:	20 83       	st	Z, r18
     34e:	31 97       	sbiw	r30, 0x01	; 1
     350:	27 e2       	ldi	r18, 0x27	; 39
     352:	20 83       	st	Z, r18
     354:	31 97       	sbiw	r30, 0x01	; 1
     356:	28 e2       	ldi	r18, 0x28	; 40
     358:	20 83       	st	Z, r18
     35a:	31 97       	sbiw	r30, 0x01	; 1
     35c:	29 e2       	ldi	r18, 0x29	; 41
     35e:	20 83       	st	Z, r18
     360:	31 97       	sbiw	r30, 0x01	; 1
     362:	20 e3       	ldi	r18, 0x30	; 48
     364:	20 83       	st	Z, r18
     366:	31 97       	sbiw	r30, 0x01	; 1
     368:	21 e3       	ldi	r18, 0x31	; 49
     36a:	20 83       	st	Z, r18
     36c:	87 97       	sbiw	r24, 0x27	; 39
     36e:	08 95       	ret

00000370 <xPortStartScheduler>:
     370:	65 e0       	ldi	r22, 0x05	; 5
     372:	80 e0       	ldi	r24, 0x00	; 0
     374:	98 e0       	ldi	r25, 0x08	; 8
     376:	0e 94 04 0d 	call	0x1a08	; 0x1a08 <TC0_ConfigClockSource>
     37a:	83 ef       	ldi	r24, 0xF3	; 243
     37c:	91 e0       	ldi	r25, 0x01	; 1
     37e:	e0 e0       	ldi	r30, 0x00	; 0
     380:	f8 e0       	ldi	r31, 0x08	; 8
     382:	86 a3       	std	Z+38, r24	; 0x26
     384:	97 a3       	std	Z+39, r25	; 0x27
     386:	61 e0       	ldi	r22, 0x01	; 1
     388:	80 e0       	ldi	r24, 0x00	; 0
     38a:	98 e0       	ldi	r25, 0x08	; 8
     38c:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <TC0_SetOverflowIntLevel>
     390:	e0 ea       	ldi	r30, 0xA0	; 160
     392:	f0 e0       	ldi	r31, 0x00	; 0
     394:	82 81       	ldd	r24, Z+2	; 0x02
     396:	81 60       	ori	r24, 0x01	; 1
     398:	82 83       	std	Z+2, r24	; 0x02
     39a:	a0 91 fb 37 	lds	r26, 0x37FB
     39e:	b0 91 fc 37 	lds	r27, 0x37FC
     3a2:	cd 91       	ld	r28, X+
     3a4:	cd bf       	out	0x3d, r28	; 61
     3a6:	dd 91       	ld	r29, X+
     3a8:	de bf       	out	0x3e, r29	; 62
     3aa:	ff 91       	pop	r31
     3ac:	ef 91       	pop	r30
     3ae:	df 91       	pop	r29
     3b0:	cf 91       	pop	r28
     3b2:	bf 91       	pop	r27
     3b4:	af 91       	pop	r26
     3b6:	9f 91       	pop	r25
     3b8:	8f 91       	pop	r24
     3ba:	7f 91       	pop	r23
     3bc:	6f 91       	pop	r22
     3be:	5f 91       	pop	r21
     3c0:	4f 91       	pop	r20
     3c2:	3f 91       	pop	r19
     3c4:	2f 91       	pop	r18
     3c6:	1f 91       	pop	r17
     3c8:	0f 91       	pop	r16
     3ca:	ff 90       	pop	r15
     3cc:	ef 90       	pop	r14
     3ce:	df 90       	pop	r13
     3d0:	cf 90       	pop	r12
     3d2:	bf 90       	pop	r11
     3d4:	af 90       	pop	r10
     3d6:	9f 90       	pop	r9
     3d8:	8f 90       	pop	r8
     3da:	7f 90       	pop	r7
     3dc:	6f 90       	pop	r6
     3de:	5f 90       	pop	r5
     3e0:	4f 90       	pop	r4
     3e2:	3f 90       	pop	r3
     3e4:	2f 90       	pop	r2
     3e6:	1f 90       	pop	r1
     3e8:	0f 90       	pop	r0
     3ea:	0f be       	out	0x3f, r0	; 63
     3ec:	0f 90       	pop	r0
     3ee:	08 95       	ret
     3f0:	81 e0       	ldi	r24, 0x01	; 1
     3f2:	08 95       	ret

000003f4 <vPortYield>:
 * Manual context switch.  The first thing we do is save the registers so we
 * can use a naked attribute.
 */
void vPortYield(void) __attribute__ ( ( naked ) );
void vPortYield(void) {
    portSAVE_CONTEXT();
     3f4:	0f 92       	push	r0
     3f6:	0f b6       	in	r0, 0x3f	; 63
     3f8:	f8 94       	cli
     3fa:	0f 92       	push	r0
     3fc:	1f 92       	push	r1
     3fe:	11 24       	eor	r1, r1
     400:	2f 92       	push	r2
     402:	3f 92       	push	r3
     404:	4f 92       	push	r4
     406:	5f 92       	push	r5
     408:	6f 92       	push	r6
     40a:	7f 92       	push	r7
     40c:	8f 92       	push	r8
     40e:	9f 92       	push	r9
     410:	af 92       	push	r10
     412:	bf 92       	push	r11
     414:	cf 92       	push	r12
     416:	df 92       	push	r13
     418:	ef 92       	push	r14
     41a:	ff 92       	push	r15
     41c:	0f 93       	push	r16
     41e:	1f 93       	push	r17
     420:	2f 93       	push	r18
     422:	3f 93       	push	r19
     424:	4f 93       	push	r20
     426:	5f 93       	push	r21
     428:	6f 93       	push	r22
     42a:	7f 93       	push	r23
     42c:	8f 93       	push	r24
     42e:	9f 93       	push	r25
     430:	af 93       	push	r26
     432:	bf 93       	push	r27
     434:	cf 93       	push	r28
     436:	df 93       	push	r29
     438:	ef 93       	push	r30
     43a:	ff 93       	push	r31
     43c:	a0 91 fb 37 	lds	r26, 0x37FB
     440:	b0 91 fc 37 	lds	r27, 0x37FC
     444:	0d b6       	in	r0, 0x3d	; 61
     446:	0d 92       	st	X+, r0
     448:	0e b6       	in	r0, 0x3e	; 62
     44a:	0d 92       	st	X+, r0
    vTaskSwitchContext();
     44c:	8a d6       	rcall	.+3348   	; 0x1162 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
     44e:	a0 91 fb 37 	lds	r26, 0x37FB
     452:	b0 91 fc 37 	lds	r27, 0x37FC
     456:	cd 91       	ld	r28, X+
     458:	cd bf       	out	0x3d, r28	; 61
     45a:	dd 91       	ld	r29, X+
     45c:	de bf       	out	0x3e, r29	; 62
     45e:	ff 91       	pop	r31
     460:	ef 91       	pop	r30
     462:	df 91       	pop	r29
     464:	cf 91       	pop	r28
     466:	bf 91       	pop	r27
     468:	af 91       	pop	r26
     46a:	9f 91       	pop	r25
     46c:	8f 91       	pop	r24
     46e:	7f 91       	pop	r23
     470:	6f 91       	pop	r22
     472:	5f 91       	pop	r21
     474:	4f 91       	pop	r20
     476:	3f 91       	pop	r19
     478:	2f 91       	pop	r18
     47a:	1f 91       	pop	r17
     47c:	0f 91       	pop	r16
     47e:	ff 90       	pop	r15
     480:	ef 90       	pop	r14
     482:	df 90       	pop	r13
     484:	cf 90       	pop	r12
     486:	bf 90       	pop	r11
     488:	af 90       	pop	r10
     48a:	9f 90       	pop	r9
     48c:	8f 90       	pop	r8
     48e:	7f 90       	pop	r7
     490:	6f 90       	pop	r6
     492:	5f 90       	pop	r5
     494:	4f 90       	pop	r4
     496:	3f 90       	pop	r3
     498:	2f 90       	pop	r2
     49a:	1f 90       	pop	r1
     49c:	0f 90       	pop	r0
     49e:	0f be       	out	0x3f, r0	; 63
     4a0:	0f 90       	pop	r0

    asm volatile ( "ret" );
     4a2:	08 95       	ret

000004a4 <__vector_14>:
     * Context switch function used by the tick.  This must be identical to
     * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
     * difference from vPortYield() is the tick count is incremented as the
     * call comes from the tick ISR.
     */
    portSAVE_CONTEXT();
     4a4:	0f 92       	push	r0
     4a6:	0f b6       	in	r0, 0x3f	; 63
     4a8:	f8 94       	cli
     4aa:	0f 92       	push	r0
     4ac:	1f 92       	push	r1
     4ae:	11 24       	eor	r1, r1
     4b0:	2f 92       	push	r2
     4b2:	3f 92       	push	r3
     4b4:	4f 92       	push	r4
     4b6:	5f 92       	push	r5
     4b8:	6f 92       	push	r6
     4ba:	7f 92       	push	r7
     4bc:	8f 92       	push	r8
     4be:	9f 92       	push	r9
     4c0:	af 92       	push	r10
     4c2:	bf 92       	push	r11
     4c4:	cf 92       	push	r12
     4c6:	df 92       	push	r13
     4c8:	ef 92       	push	r14
     4ca:	ff 92       	push	r15
     4cc:	0f 93       	push	r16
     4ce:	1f 93       	push	r17
     4d0:	2f 93       	push	r18
     4d2:	3f 93       	push	r19
     4d4:	4f 93       	push	r20
     4d6:	5f 93       	push	r21
     4d8:	6f 93       	push	r22
     4da:	7f 93       	push	r23
     4dc:	8f 93       	push	r24
     4de:	9f 93       	push	r25
     4e0:	af 93       	push	r26
     4e2:	bf 93       	push	r27
     4e4:	cf 93       	push	r28
     4e6:	df 93       	push	r29
     4e8:	ef 93       	push	r30
     4ea:	ff 93       	push	r31
     4ec:	a0 91 fb 37 	lds	r26, 0x37FB
     4f0:	b0 91 fc 37 	lds	r27, 0x37FC
     4f4:	0d b6       	in	r0, 0x3d	; 61
     4f6:	0d 92       	st	X+, r0
     4f8:	0e b6       	in	r0, 0x3e	; 62
     4fa:	0d 92       	st	X+, r0
    vTaskIncrementTick();
     4fc:	ce d4       	rcall	.+2460   	; 0xe9a <vTaskIncrementTick>
    vTaskSwitchContext();
     4fe:	31 d6       	rcall	.+3170   	; 0x1162 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
     500:	a0 91 fb 37 	lds	r26, 0x37FB
     504:	b0 91 fc 37 	lds	r27, 0x37FC
     508:	cd 91       	ld	r28, X+
     50a:	cd bf       	out	0x3d, r28	; 61
     50c:	dd 91       	ld	r29, X+
     50e:	de bf       	out	0x3e, r29	; 62
     510:	ff 91       	pop	r31
     512:	ef 91       	pop	r30
     514:	df 91       	pop	r29
     516:	cf 91       	pop	r28
     518:	bf 91       	pop	r27
     51a:	af 91       	pop	r26
     51c:	9f 91       	pop	r25
     51e:	8f 91       	pop	r24
     520:	7f 91       	pop	r23
     522:	6f 91       	pop	r22
     524:	5f 91       	pop	r21
     526:	4f 91       	pop	r20
     528:	3f 91       	pop	r19
     52a:	2f 91       	pop	r18
     52c:	1f 91       	pop	r17
     52e:	0f 91       	pop	r16
     530:	ff 90       	pop	r15
     532:	ef 90       	pop	r14
     534:	df 90       	pop	r13
     536:	cf 90       	pop	r12
     538:	bf 90       	pop	r11
     53a:	af 90       	pop	r10
     53c:	9f 90       	pop	r9
     53e:	8f 90       	pop	r8
     540:	7f 90       	pop	r7
     542:	6f 90       	pop	r6
     544:	5f 90       	pop	r5
     546:	4f 90       	pop	r4
     548:	3f 90       	pop	r3
     54a:	2f 90       	pop	r2
     54c:	1f 90       	pop	r1
     54e:	0f 90       	pop	r0
     550:	0f be       	out	0x3f, r0	; 63
     552:	0f 90       	pop	r0
    asm volatile ( "reti" );
     554:	18 95       	reti

00000556 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     556:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     558:	03 96       	adiw	r24, 0x03	; 3
     55a:	81 83       	std	Z+1, r24	; 0x01
     55c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     55e:	2f ef       	ldi	r18, 0xFF	; 255
     560:	3f ef       	ldi	r19, 0xFF	; 255
     562:	23 83       	std	Z+3, r18	; 0x03
     564:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     566:	85 83       	std	Z+5, r24	; 0x05
     568:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     56a:	87 83       	std	Z+7, r24	; 0x07
     56c:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     56e:	10 82       	st	Z, r1
     570:	08 95       	ret

00000572 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     572:	fc 01       	movw	r30, r24
     574:	10 86       	std	Z+8, r1	; 0x08
     576:	11 86       	std	Z+9, r1	; 0x09
     578:	08 95       	ret

0000057a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     57a:	cf 93       	push	r28
     57c:	df 93       	push	r29
     57e:	fc 01       	movw	r30, r24
     580:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     582:	21 81       	ldd	r18, Z+1	; 0x01
     584:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     586:	e9 01       	movw	r28, r18
     588:	8a 81       	ldd	r24, Y+2	; 0x02
     58a:	9b 81       	ldd	r25, Y+3	; 0x03
     58c:	12 96       	adiw	r26, 0x02	; 2
     58e:	8d 93       	st	X+, r24
     590:	9c 93       	st	X, r25
     592:	13 97       	sbiw	r26, 0x03	; 3
	pxNewListItem->pxPrevious = pxList->pxIndex;
     594:	81 81       	ldd	r24, Z+1	; 0x01
     596:	92 81       	ldd	r25, Z+2	; 0x02
     598:	14 96       	adiw	r26, 0x04	; 4
     59a:	8d 93       	st	X+, r24
     59c:	9c 93       	st	X, r25
     59e:	15 97       	sbiw	r26, 0x05	; 5
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     5a0:	8a 81       	ldd	r24, Y+2	; 0x02
     5a2:	9b 81       	ldd	r25, Y+3	; 0x03
     5a4:	ec 01       	movw	r28, r24
     5a6:	6c 83       	std	Y+4, r22	; 0x04
     5a8:	7d 83       	std	Y+5, r23	; 0x05
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     5aa:	e9 01       	movw	r28, r18
     5ac:	6a 83       	std	Y+2, r22	; 0x02
     5ae:	7b 83       	std	Y+3, r23	; 0x03
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     5b0:	61 83       	std	Z+1, r22	; 0x01
     5b2:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5b4:	18 96       	adiw	r26, 0x08	; 8
     5b6:	ed 93       	st	X+, r30
     5b8:	fc 93       	st	X, r31
     5ba:	19 97       	sbiw	r26, 0x09	; 9

	( pxList->uxNumberOfItems )++;
     5bc:	80 81       	ld	r24, Z
     5be:	8f 5f       	subi	r24, 0xFF	; 255
     5c0:	80 83       	st	Z, r24
}
     5c2:	df 91       	pop	r29
     5c4:	cf 91       	pop	r28
     5c6:	08 95       	ret

000005c8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     5c8:	cf 93       	push	r28
     5ca:	df 93       	push	r29
     5cc:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     5ce:	48 81       	ld	r20, Y
     5d0:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     5d2:	4f 3f       	cpi	r20, 0xFF	; 255
     5d4:	2f ef       	ldi	r18, 0xFF	; 255
     5d6:	52 07       	cpc	r21, r18
     5d8:	31 f4       	brne	.+12     	; 0x5e6 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     5da:	dc 01       	movw	r26, r24
     5dc:	17 96       	adiw	r26, 0x07	; 7
     5de:	ed 91       	ld	r30, X+
     5e0:	fc 91       	ld	r31, X
     5e2:	18 97       	sbiw	r26, 0x08	; 8
     5e4:	17 c0       	rjmp	.+46     	; 0x614 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     5e6:	fc 01       	movw	r30, r24
     5e8:	33 96       	adiw	r30, 0x03	; 3
     5ea:	dc 01       	movw	r26, r24
     5ec:	15 96       	adiw	r26, 0x05	; 5
     5ee:	2d 91       	ld	r18, X+
     5f0:	3c 91       	ld	r19, X
     5f2:	16 97       	sbiw	r26, 0x06	; 6
     5f4:	d9 01       	movw	r26, r18
     5f6:	2d 91       	ld	r18, X+
     5f8:	3c 91       	ld	r19, X
     5fa:	42 17       	cp	r20, r18
     5fc:	53 07       	cpc	r21, r19
     5fe:	50 f0       	brcs	.+20     	; 0x614 <vListInsert+0x4c>
     600:	02 80       	ldd	r0, Z+2	; 0x02
     602:	f3 81       	ldd	r31, Z+3	; 0x03
     604:	e0 2d       	mov	r30, r0
     606:	a2 81       	ldd	r26, Z+2	; 0x02
     608:	b3 81       	ldd	r27, Z+3	; 0x03
     60a:	2d 91       	ld	r18, X+
     60c:	3c 91       	ld	r19, X
     60e:	42 17       	cp	r20, r18
     610:	53 07       	cpc	r21, r19
     612:	b0 f7       	brcc	.-20     	; 0x600 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     614:	a2 81       	ldd	r26, Z+2	; 0x02
     616:	b3 81       	ldd	r27, Z+3	; 0x03
     618:	aa 83       	std	Y+2, r26	; 0x02
     61a:	bb 83       	std	Y+3, r27	; 0x03
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     61c:	14 96       	adiw	r26, 0x04	; 4
     61e:	cd 93       	st	X+, r28
     620:	dc 93       	st	X, r29
     622:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxIterator;
     624:	ec 83       	std	Y+4, r30	; 0x04
     626:	fd 83       	std	Y+5, r31	; 0x05
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     628:	c2 83       	std	Z+2, r28	; 0x02
     62a:	d3 83       	std	Z+3, r29	; 0x03

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     62c:	88 87       	std	Y+8, r24	; 0x08
     62e:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
     630:	fc 01       	movw	r30, r24
     632:	20 81       	ld	r18, Z
     634:	2f 5f       	subi	r18, 0xFF	; 255
     636:	20 83       	st	Z, r18
}
     638:	df 91       	pop	r29
     63a:	cf 91       	pop	r28
     63c:	08 95       	ret

0000063e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     63e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     640:	a2 81       	ldd	r26, Z+2	; 0x02
     642:	b3 81       	ldd	r27, Z+3	; 0x03
     644:	84 81       	ldd	r24, Z+4	; 0x04
     646:	95 81       	ldd	r25, Z+5	; 0x05
     648:	14 96       	adiw	r26, 0x04	; 4
     64a:	8d 93       	st	X+, r24
     64c:	9c 93       	st	X, r25
     64e:	15 97       	sbiw	r26, 0x05	; 5
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     650:	a4 81       	ldd	r26, Z+4	; 0x04
     652:	b5 81       	ldd	r27, Z+5	; 0x05
     654:	82 81       	ldd	r24, Z+2	; 0x02
     656:	93 81       	ldd	r25, Z+3	; 0x03
     658:	12 96       	adiw	r26, 0x02	; 2
     65a:	8d 93       	st	X+, r24
     65c:	9c 93       	st	X, r25
     65e:	13 97       	sbiw	r26, 0x03	; 3
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     660:	a0 85       	ldd	r26, Z+8	; 0x08
     662:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     664:	11 96       	adiw	r26, 0x01	; 1
     666:	8d 91       	ld	r24, X+
     668:	9c 91       	ld	r25, X
     66a:	12 97       	sbiw	r26, 0x02	; 2
     66c:	8e 17       	cp	r24, r30
     66e:	9f 07       	cpc	r25, r31
     670:	31 f4       	brne	.+12     	; 0x67e <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     672:	84 81       	ldd	r24, Z+4	; 0x04
     674:	95 81       	ldd	r25, Z+5	; 0x05
     676:	11 96       	adiw	r26, 0x01	; 1
     678:	8d 93       	st	X+, r24
     67a:	9c 93       	st	X, r25
     67c:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
     67e:	10 86       	std	Z+8, r1	; 0x08
     680:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
     682:	8c 91       	ld	r24, X
     684:	81 50       	subi	r24, 0x01	; 1
     686:	8c 93       	st	X, r24
     688:	08 95       	ret

0000068a <prvCopyDataToQueue>:

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );

	return xReturn;
}
     68a:	cf 93       	push	r28
     68c:	df 93       	push	r29
     68e:	ec 01       	movw	r28, r24
     690:	8c 8d       	ldd	r24, Y+28	; 0x1c
     692:	81 11       	cpse	r24, r1
     694:	0a c0       	rjmp	.+20     	; 0x6aa <prvCopyDataToQueue+0x20>
     696:	88 81       	ld	r24, Y
     698:	99 81       	ldd	r25, Y+1	; 0x01
     69a:	89 2b       	or	r24, r25
     69c:	d9 f5       	brne	.+118    	; 0x714 <prvCopyDataToQueue+0x8a>
     69e:	8a 81       	ldd	r24, Y+2	; 0x02
     6a0:	9b 81       	ldd	r25, Y+3	; 0x03
     6a2:	f4 d6       	rcall	.+3560   	; 0x148c <vTaskPriorityDisinherit>
     6a4:	1a 82       	std	Y+2, r1	; 0x02
     6a6:	1b 82       	std	Y+3, r1	; 0x03
     6a8:	35 c0       	rjmp	.+106    	; 0x714 <prvCopyDataToQueue+0x8a>
     6aa:	41 11       	cpse	r20, r1
     6ac:	17 c0       	rjmp	.+46     	; 0x6dc <prvCopyDataToQueue+0x52>
     6ae:	48 2f       	mov	r20, r24
     6b0:	50 e0       	ldi	r21, 0x00	; 0
     6b2:	8c 81       	ldd	r24, Y+4	; 0x04
     6b4:	9d 81       	ldd	r25, Y+5	; 0x05
     6b6:	0e 94 3f 10 	call	0x207e	; 0x207e <memcpy>
     6ba:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6bc:	8c 81       	ldd	r24, Y+4	; 0x04
     6be:	9d 81       	ldd	r25, Y+5	; 0x05
     6c0:	82 0f       	add	r24, r18
     6c2:	91 1d       	adc	r25, r1
     6c4:	8c 83       	std	Y+4, r24	; 0x04
     6c6:	9d 83       	std	Y+5, r25	; 0x05
     6c8:	2a 81       	ldd	r18, Y+2	; 0x02
     6ca:	3b 81       	ldd	r19, Y+3	; 0x03
     6cc:	82 17       	cp	r24, r18
     6ce:	93 07       	cpc	r25, r19
     6d0:	08 f1       	brcs	.+66     	; 0x714 <prvCopyDataToQueue+0x8a>
     6d2:	88 81       	ld	r24, Y
     6d4:	99 81       	ldd	r25, Y+1	; 0x01
     6d6:	8c 83       	std	Y+4, r24	; 0x04
     6d8:	9d 83       	std	Y+5, r25	; 0x05
     6da:	1c c0       	rjmp	.+56     	; 0x714 <prvCopyDataToQueue+0x8a>
     6dc:	48 2f       	mov	r20, r24
     6de:	50 e0       	ldi	r21, 0x00	; 0
     6e0:	8e 81       	ldd	r24, Y+6	; 0x06
     6e2:	9f 81       	ldd	r25, Y+7	; 0x07
     6e4:	0e 94 3f 10 	call	0x207e	; 0x207e <memcpy>
     6e8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6ea:	30 e0       	ldi	r19, 0x00	; 0
     6ec:	31 95       	neg	r19
     6ee:	21 95       	neg	r18
     6f0:	31 09       	sbc	r19, r1
     6f2:	8e 81       	ldd	r24, Y+6	; 0x06
     6f4:	9f 81       	ldd	r25, Y+7	; 0x07
     6f6:	82 0f       	add	r24, r18
     6f8:	93 1f       	adc	r25, r19
     6fa:	8e 83       	std	Y+6, r24	; 0x06
     6fc:	9f 83       	std	Y+7, r25	; 0x07
     6fe:	48 81       	ld	r20, Y
     700:	59 81       	ldd	r21, Y+1	; 0x01
     702:	84 17       	cp	r24, r20
     704:	95 07       	cpc	r25, r21
     706:	30 f4       	brcc	.+12     	; 0x714 <prvCopyDataToQueue+0x8a>
     708:	8a 81       	ldd	r24, Y+2	; 0x02
     70a:	9b 81       	ldd	r25, Y+3	; 0x03
     70c:	28 0f       	add	r18, r24
     70e:	39 1f       	adc	r19, r25
     710:	2e 83       	std	Y+6, r18	; 0x06
     712:	3f 83       	std	Y+7, r19	; 0x07
     714:	8a 8d       	ldd	r24, Y+26	; 0x1a
     716:	8f 5f       	subi	r24, 0xFF	; 255
     718:	8a 8f       	std	Y+26, r24	; 0x1a
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	08 95       	ret

00000720 <prvCopyDataFromQueue>:
     720:	fc 01       	movw	r30, r24
     722:	cb 01       	movw	r24, r22
     724:	a0 81       	ld	r26, Z
     726:	b1 81       	ldd	r27, Z+1	; 0x01
     728:	10 97       	sbiw	r26, 0x00	; 0
     72a:	99 f0       	breq	.+38     	; 0x752 <prvCopyDataFromQueue+0x32>
     72c:	44 8d       	ldd	r20, Z+28	; 0x1c
     72e:	50 e0       	ldi	r21, 0x00	; 0
     730:	26 81       	ldd	r18, Z+6	; 0x06
     732:	37 81       	ldd	r19, Z+7	; 0x07
     734:	24 0f       	add	r18, r20
     736:	35 1f       	adc	r19, r21
     738:	26 83       	std	Z+6, r18	; 0x06
     73a:	37 83       	std	Z+7, r19	; 0x07
     73c:	62 81       	ldd	r22, Z+2	; 0x02
     73e:	73 81       	ldd	r23, Z+3	; 0x03
     740:	26 17       	cp	r18, r22
     742:	37 07       	cpc	r19, r23
     744:	10 f0       	brcs	.+4      	; 0x74a <prvCopyDataFromQueue+0x2a>
     746:	a6 83       	std	Z+6, r26	; 0x06
     748:	b7 83       	std	Z+7, r27	; 0x07
     74a:	66 81       	ldd	r22, Z+6	; 0x06
     74c:	77 81       	ldd	r23, Z+7	; 0x07
     74e:	0c 94 3f 10 	jmp	0x207e	; 0x207e <memcpy>
     752:	08 95       	ret

00000754 <prvUnlockQueue>:
     754:	0f 93       	push	r16
     756:	1f 93       	push	r17
     758:	cf 93       	push	r28
     75a:	df 93       	push	r29
     75c:	ec 01       	movw	r28, r24
     75e:	0f b6       	in	r0, 0x3f	; 63
     760:	f8 94       	cli
     762:	0f 92       	push	r0
     764:	8e 8d       	ldd	r24, Y+30	; 0x1e
     766:	18 16       	cp	r1, r24
     768:	9c f4       	brge	.+38     	; 0x790 <prvUnlockQueue+0x3c>
     76a:	89 89       	ldd	r24, Y+17	; 0x11
     76c:	88 23       	and	r24, r24
     76e:	81 f0       	breq	.+32     	; 0x790 <prvUnlockQueue+0x3c>
     770:	8e 01       	movw	r16, r28
     772:	0f 5e       	subi	r16, 0xEF	; 239
     774:	1f 4f       	sbci	r17, 0xFF	; 255
     776:	03 c0       	rjmp	.+6      	; 0x77e <prvUnlockQueue+0x2a>
     778:	89 89       	ldd	r24, Y+17	; 0x11
     77a:	88 23       	and	r24, r24
     77c:	49 f0       	breq	.+18     	; 0x790 <prvUnlockQueue+0x3c>
     77e:	c8 01       	movw	r24, r16
     780:	8f d5       	rcall	.+2846   	; 0x12a0 <xTaskRemoveFromEventList>
     782:	81 11       	cpse	r24, r1
     784:	17 d6       	rcall	.+3118   	; 0x13b4 <vTaskMissedYield>
     786:	8e 8d       	ldd	r24, Y+30	; 0x1e
     788:	81 50       	subi	r24, 0x01	; 1
     78a:	8e 8f       	std	Y+30, r24	; 0x1e
     78c:	18 16       	cp	r1, r24
     78e:	a4 f3       	brlt	.-24     	; 0x778 <prvUnlockQueue+0x24>
     790:	8f ef       	ldi	r24, 0xFF	; 255
     792:	8e 8f       	std	Y+30, r24	; 0x1e
     794:	0f 90       	pop	r0
     796:	0f be       	out	0x3f, r0	; 63
     798:	0f b6       	in	r0, 0x3f	; 63
     79a:	f8 94       	cli
     79c:	0f 92       	push	r0
     79e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     7a0:	18 16       	cp	r1, r24
     7a2:	9c f4       	brge	.+38     	; 0x7ca <prvUnlockQueue+0x76>
     7a4:	88 85       	ldd	r24, Y+8	; 0x08
     7a6:	88 23       	and	r24, r24
     7a8:	81 f0       	breq	.+32     	; 0x7ca <prvUnlockQueue+0x76>
     7aa:	8e 01       	movw	r16, r28
     7ac:	08 5f       	subi	r16, 0xF8	; 248
     7ae:	1f 4f       	sbci	r17, 0xFF	; 255
     7b0:	03 c0       	rjmp	.+6      	; 0x7b8 <prvUnlockQueue+0x64>
     7b2:	88 85       	ldd	r24, Y+8	; 0x08
     7b4:	88 23       	and	r24, r24
     7b6:	49 f0       	breq	.+18     	; 0x7ca <prvUnlockQueue+0x76>
     7b8:	c8 01       	movw	r24, r16
     7ba:	72 d5       	rcall	.+2788   	; 0x12a0 <xTaskRemoveFromEventList>
     7bc:	81 11       	cpse	r24, r1
     7be:	fa d5       	rcall	.+3060   	; 0x13b4 <vTaskMissedYield>
     7c0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     7c2:	81 50       	subi	r24, 0x01	; 1
     7c4:	8d 8f       	std	Y+29, r24	; 0x1d
     7c6:	18 16       	cp	r1, r24
     7c8:	a4 f3       	brlt	.-24     	; 0x7b2 <prvUnlockQueue+0x5e>
     7ca:	8f ef       	ldi	r24, 0xFF	; 255
     7cc:	8d 8f       	std	Y+29, r24	; 0x1d
     7ce:	0f 90       	pop	r0
     7d0:	0f be       	out	0x3f, r0	; 63
     7d2:	df 91       	pop	r29
     7d4:	cf 91       	pop	r28
     7d6:	1f 91       	pop	r17
     7d8:	0f 91       	pop	r16
     7da:	08 95       	ret

000007dc <xQueueCreate>:
     7dc:	cf 92       	push	r12
     7de:	df 92       	push	r13
     7e0:	ef 92       	push	r14
     7e2:	ff 92       	push	r15
     7e4:	0f 93       	push	r16
     7e6:	1f 93       	push	r17
     7e8:	cf 93       	push	r28
     7ea:	df 93       	push	r29
     7ec:	d8 2e       	mov	r13, r24
     7ee:	c6 2e       	mov	r12, r22
     7f0:	88 23       	and	r24, r24
     7f2:	a1 f1       	breq	.+104    	; 0x85c <xQueueCreate+0x80>
     7f4:	8f e1       	ldi	r24, 0x1F	; 31
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	28 dd       	rcall	.-1456   	; 0x24a <pvPortMalloc>
     7fa:	ec 01       	movw	r28, r24
     7fc:	00 97       	sbiw	r24, 0x00	; 0
     7fe:	81 f1       	breq	.+96     	; 0x860 <xQueueCreate+0x84>
     800:	ec 2c       	mov	r14, r12
     802:	f1 2c       	mov	r15, r1
     804:	de 9c       	mul	r13, r14
     806:	80 01       	movw	r16, r0
     808:	df 9c       	mul	r13, r15
     80a:	10 0d       	add	r17, r0
     80c:	11 24       	eor	r1, r1
     80e:	c8 01       	movw	r24, r16
     810:	01 96       	adiw	r24, 0x01	; 1
     812:	1b dd       	rcall	.-1482   	; 0x24a <pvPortMalloc>
     814:	88 83       	st	Y, r24
     816:	99 83       	std	Y+1, r25	; 0x01
     818:	00 97       	sbiw	r24, 0x00	; 0
     81a:	d9 f0       	breq	.+54     	; 0x852 <xQueueCreate+0x76>
     81c:	ac 01       	movw	r20, r24
     81e:	40 0f       	add	r20, r16
     820:	51 1f       	adc	r21, r17
     822:	4a 83       	std	Y+2, r20	; 0x02
     824:	5b 83       	std	Y+3, r21	; 0x03
     826:	1a 8e       	std	Y+26, r1	; 0x1a
     828:	8c 83       	std	Y+4, r24	; 0x04
     82a:	9d 83       	std	Y+5, r25	; 0x05
     82c:	0e 19       	sub	r16, r14
     82e:	1f 09       	sbc	r17, r15
     830:	9c 01       	movw	r18, r24
     832:	20 0f       	add	r18, r16
     834:	31 1f       	adc	r19, r17
     836:	2e 83       	std	Y+6, r18	; 0x06
     838:	3f 83       	std	Y+7, r19	; 0x07
     83a:	db 8e       	std	Y+27, r13	; 0x1b
     83c:	cc 8e       	std	Y+28, r12	; 0x1c
     83e:	8f ef       	ldi	r24, 0xFF	; 255
     840:	8d 8f       	std	Y+29, r24	; 0x1d
     842:	8e 8f       	std	Y+30, r24	; 0x1e
     844:	ce 01       	movw	r24, r28
     846:	08 96       	adiw	r24, 0x08	; 8
     848:	86 de       	rcall	.-756    	; 0x556 <vListInitialise>
     84a:	ce 01       	movw	r24, r28
     84c:	41 96       	adiw	r24, 0x11	; 17
     84e:	83 de       	rcall	.-762    	; 0x556 <vListInitialise>
     850:	07 c0       	rjmp	.+14     	; 0x860 <xQueueCreate+0x84>
     852:	ce 01       	movw	r24, r28
     854:	1e dd       	rcall	.-1476   	; 0x292 <vPortFree>
     856:	c0 e0       	ldi	r28, 0x00	; 0
     858:	d0 e0       	ldi	r29, 0x00	; 0
     85a:	02 c0       	rjmp	.+4      	; 0x860 <xQueueCreate+0x84>
     85c:	c0 e0       	ldi	r28, 0x00	; 0
     85e:	d0 e0       	ldi	r29, 0x00	; 0
     860:	ce 01       	movw	r24, r28
     862:	df 91       	pop	r29
     864:	cf 91       	pop	r28
     866:	1f 91       	pop	r17
     868:	0f 91       	pop	r16
     86a:	ff 90       	pop	r15
     86c:	ef 90       	pop	r14
     86e:	df 90       	pop	r13
     870:	cf 90       	pop	r12
     872:	08 95       	ret

00000874 <xQueueGenericSend>:
     874:	af 92       	push	r10
     876:	bf 92       	push	r11
     878:	cf 92       	push	r12
     87a:	df 92       	push	r13
     87c:	ef 92       	push	r14
     87e:	ff 92       	push	r15
     880:	0f 93       	push	r16
     882:	1f 93       	push	r17
     884:	cf 93       	push	r28
     886:	df 93       	push	r29
     888:	cd b7       	in	r28, 0x3d	; 61
     88a:	de b7       	in	r29, 0x3e	; 62
     88c:	25 97       	sbiw	r28, 0x05	; 5
     88e:	cd bf       	out	0x3d, r28	; 61
     890:	de bf       	out	0x3e, r29	; 62
     892:	8c 01       	movw	r16, r24
     894:	6b 01       	movw	r12, r22
     896:	4c 83       	std	Y+4, r20	; 0x04
     898:	5d 83       	std	Y+5, r21	; 0x05
     89a:	a2 2e       	mov	r10, r18
     89c:	b1 2c       	mov	r11, r1
     89e:	7c 01       	movw	r14, r24
     8a0:	88 e0       	ldi	r24, 0x08	; 8
     8a2:	e8 0e       	add	r14, r24
     8a4:	f1 1c       	adc	r15, r1
     8a6:	0f b6       	in	r0, 0x3f	; 63
     8a8:	f8 94       	cli
     8aa:	0f 92       	push	r0
     8ac:	f8 01       	movw	r30, r16
     8ae:	92 8d       	ldd	r25, Z+26	; 0x1a
     8b0:	83 8d       	ldd	r24, Z+27	; 0x1b
     8b2:	98 17       	cp	r25, r24
     8b4:	90 f4       	brcc	.+36     	; 0x8da <xQueueGenericSend+0x66>
     8b6:	4a 2d       	mov	r20, r10
     8b8:	b6 01       	movw	r22, r12
     8ba:	c8 01       	movw	r24, r16
     8bc:	e6 de       	rcall	.-564    	; 0x68a <prvCopyDataToQueue>
     8be:	f8 01       	movw	r30, r16
     8c0:	81 89       	ldd	r24, Z+17	; 0x11
     8c2:	88 23       	and	r24, r24
     8c4:	31 f0       	breq	.+12     	; 0x8d2 <xQueueGenericSend+0x5e>
     8c6:	c8 01       	movw	r24, r16
     8c8:	41 96       	adiw	r24, 0x11	; 17
     8ca:	ea d4       	rcall	.+2516   	; 0x12a0 <xTaskRemoveFromEventList>
     8cc:	81 30       	cpi	r24, 0x01	; 1
     8ce:	09 f4       	brne	.+2      	; 0x8d2 <xQueueGenericSend+0x5e>
     8d0:	91 dd       	rcall	.-1246   	; 0x3f4 <vPortYield>
     8d2:	0f 90       	pop	r0
     8d4:	0f be       	out	0x3f, r0	; 63
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	47 c0       	rjmp	.+142    	; 0x968 <xQueueGenericSend+0xf4>
     8da:	ec 81       	ldd	r30, Y+4	; 0x04
     8dc:	fd 81       	ldd	r31, Y+5	; 0x05
     8de:	ef 2b       	or	r30, r31
     8e0:	21 f4       	brne	.+8      	; 0x8ea <xQueueGenericSend+0x76>
     8e2:	0f 90       	pop	r0
     8e4:	0f be       	out	0x3f, r0	; 63
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	3f c0       	rjmp	.+126    	; 0x968 <xQueueGenericSend+0xf4>
     8ea:	b1 10       	cpse	r11, r1
     8ec:	05 c0       	rjmp	.+10     	; 0x8f8 <xQueueGenericSend+0x84>
     8ee:	ce 01       	movw	r24, r28
     8f0:	01 96       	adiw	r24, 0x01	; 1
     8f2:	17 d5       	rcall	.+2606   	; 0x1322 <vTaskSetTimeOutState>
     8f4:	bb 24       	eor	r11, r11
     8f6:	b3 94       	inc	r11
     8f8:	0f 90       	pop	r0
     8fa:	0f be       	out	0x3f, r0	; 63
     8fc:	be d2       	rcall	.+1404   	; 0xe7a <vTaskSuspendAll>
     8fe:	0f b6       	in	r0, 0x3f	; 63
     900:	f8 94       	cli
     902:	0f 92       	push	r0
     904:	f8 01       	movw	r30, r16
     906:	85 8d       	ldd	r24, Z+29	; 0x1d
     908:	8f 3f       	cpi	r24, 0xFF	; 255
     90a:	09 f4       	brne	.+2      	; 0x90e <xQueueGenericSend+0x9a>
     90c:	15 8e       	std	Z+29, r1	; 0x1d
     90e:	f8 01       	movw	r30, r16
     910:	86 8d       	ldd	r24, Z+30	; 0x1e
     912:	8f 3f       	cpi	r24, 0xFF	; 255
     914:	09 f4       	brne	.+2      	; 0x918 <xQueueGenericSend+0xa4>
     916:	16 8e       	std	Z+30, r1	; 0x1e
     918:	0f 90       	pop	r0
     91a:	0f be       	out	0x3f, r0	; 63
     91c:	be 01       	movw	r22, r28
     91e:	6c 5f       	subi	r22, 0xFC	; 252
     920:	7f 4f       	sbci	r23, 0xFF	; 255
     922:	ce 01       	movw	r24, r28
     924:	01 96       	adiw	r24, 0x01	; 1
     926:	08 d5       	rcall	.+2576   	; 0x1338 <xTaskCheckForTimeOut>
     928:	81 11       	cpse	r24, r1
     92a:	1a c0       	rjmp	.+52     	; 0x960 <xQueueGenericSend+0xec>
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	0f 92       	push	r0
     932:	f8 01       	movw	r30, r16
     934:	92 8d       	ldd	r25, Z+26	; 0x1a
     936:	0f 90       	pop	r0
     938:	0f be       	out	0x3f, r0	; 63
     93a:	f8 01       	movw	r30, r16
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	98 13       	cpse	r25, r24
     940:	0b c0       	rjmp	.+22     	; 0x958 <xQueueGenericSend+0xe4>
     942:	6c 81       	ldd	r22, Y+4	; 0x04
     944:	7d 81       	ldd	r23, Y+5	; 0x05
     946:	c7 01       	movw	r24, r14
     948:	69 d4       	rcall	.+2258   	; 0x121c <vTaskPlaceOnEventList>
     94a:	c8 01       	movw	r24, r16
     94c:	03 df       	rcall	.-506    	; 0x754 <prvUnlockQueue>
     94e:	66 d3       	rcall	.+1740   	; 0x101c <xTaskResumeAll>
     950:	81 11       	cpse	r24, r1
     952:	a9 cf       	rjmp	.-174    	; 0x8a6 <xQueueGenericSend+0x32>
     954:	4f dd       	rcall	.-1378   	; 0x3f4 <vPortYield>
     956:	a7 cf       	rjmp	.-178    	; 0x8a6 <xQueueGenericSend+0x32>
     958:	c8 01       	movw	r24, r16
     95a:	fc de       	rcall	.-520    	; 0x754 <prvUnlockQueue>
     95c:	5f d3       	rcall	.+1726   	; 0x101c <xTaskResumeAll>
     95e:	a3 cf       	rjmp	.-186    	; 0x8a6 <xQueueGenericSend+0x32>
     960:	c8 01       	movw	r24, r16
     962:	f8 de       	rcall	.-528    	; 0x754 <prvUnlockQueue>
     964:	5b d3       	rcall	.+1718   	; 0x101c <xTaskResumeAll>
     966:	80 e0       	ldi	r24, 0x00	; 0
     968:	25 96       	adiw	r28, 0x05	; 5
     96a:	cd bf       	out	0x3d, r28	; 61
     96c:	de bf       	out	0x3e, r29	; 62
     96e:	df 91       	pop	r29
     970:	cf 91       	pop	r28
     972:	1f 91       	pop	r17
     974:	0f 91       	pop	r16
     976:	ff 90       	pop	r15
     978:	ef 90       	pop	r14
     97a:	df 90       	pop	r13
     97c:	cf 90       	pop	r12
     97e:	bf 90       	pop	r11
     980:	af 90       	pop	r10
     982:	08 95       	ret

00000984 <xQueueGenericSendFromISR>:
     984:	0f 93       	push	r16
     986:	1f 93       	push	r17
     988:	cf 93       	push	r28
     98a:	df 93       	push	r29
     98c:	ec 01       	movw	r28, r24
     98e:	8a 01       	movw	r16, r20
     990:	9a 8d       	ldd	r25, Y+26	; 0x1a
     992:	8b 8d       	ldd	r24, Y+27	; 0x1b
     994:	98 17       	cp	r25, r24
     996:	b0 f4       	brcc	.+44     	; 0x9c4 <xQueueGenericSendFromISR+0x40>
     998:	42 2f       	mov	r20, r18
     99a:	ce 01       	movw	r24, r28
     99c:	76 de       	rcall	.-788    	; 0x68a <prvCopyDataToQueue>
     99e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     9a0:	8f 3f       	cpi	r24, 0xFF	; 255
     9a2:	61 f4       	brne	.+24     	; 0x9bc <xQueueGenericSendFromISR+0x38>
     9a4:	89 89       	ldd	r24, Y+17	; 0x11
     9a6:	88 23       	and	r24, r24
     9a8:	79 f0       	breq	.+30     	; 0x9c8 <xQueueGenericSendFromISR+0x44>
     9aa:	ce 01       	movw	r24, r28
     9ac:	41 96       	adiw	r24, 0x11	; 17
     9ae:	78 d4       	rcall	.+2288   	; 0x12a0 <xTaskRemoveFromEventList>
     9b0:	88 23       	and	r24, r24
     9b2:	61 f0       	breq	.+24     	; 0x9cc <xQueueGenericSendFromISR+0x48>
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	f8 01       	movw	r30, r16
     9b8:	80 83       	st	Z, r24
     9ba:	09 c0       	rjmp	.+18     	; 0x9ce <xQueueGenericSendFromISR+0x4a>
     9bc:	8f 5f       	subi	r24, 0xFF	; 255
     9be:	8e 8f       	std	Y+30, r24	; 0x1e
     9c0:	81 e0       	ldi	r24, 0x01	; 1
     9c2:	05 c0       	rjmp	.+10     	; 0x9ce <xQueueGenericSendFromISR+0x4a>
     9c4:	80 e0       	ldi	r24, 0x00	; 0
     9c6:	03 c0       	rjmp	.+6      	; 0x9ce <xQueueGenericSendFromISR+0x4a>
     9c8:	81 e0       	ldi	r24, 0x01	; 1
     9ca:	01 c0       	rjmp	.+2      	; 0x9ce <xQueueGenericSendFromISR+0x4a>
     9cc:	81 e0       	ldi	r24, 0x01	; 1
     9ce:	df 91       	pop	r29
     9d0:	cf 91       	pop	r28
     9d2:	1f 91       	pop	r17
     9d4:	0f 91       	pop	r16
     9d6:	08 95       	ret

000009d8 <xQueueGenericReceive>:
     9d8:	af 92       	push	r10
     9da:	bf 92       	push	r11
     9dc:	cf 92       	push	r12
     9de:	df 92       	push	r13
     9e0:	ef 92       	push	r14
     9e2:	ff 92       	push	r15
     9e4:	0f 93       	push	r16
     9e6:	1f 93       	push	r17
     9e8:	cf 93       	push	r28
     9ea:	df 93       	push	r29
     9ec:	cd b7       	in	r28, 0x3d	; 61
     9ee:	de b7       	in	r29, 0x3e	; 62
     9f0:	25 97       	sbiw	r28, 0x05	; 5
     9f2:	cd bf       	out	0x3d, r28	; 61
     9f4:	de bf       	out	0x3e, r29	; 62
     9f6:	8c 01       	movw	r16, r24
     9f8:	6b 01       	movw	r12, r22
     9fa:	4c 83       	std	Y+4, r20	; 0x04
     9fc:	5d 83       	std	Y+5, r21	; 0x05
     9fe:	b2 2e       	mov	r11, r18
     a00:	a1 2c       	mov	r10, r1
     a02:	7c 01       	movw	r14, r24
     a04:	81 e1       	ldi	r24, 0x11	; 17
     a06:	e8 0e       	add	r14, r24
     a08:	f1 1c       	adc	r15, r1
     a0a:	0f b6       	in	r0, 0x3f	; 63
     a0c:	f8 94       	cli
     a0e:	0f 92       	push	r0
     a10:	f8 01       	movw	r30, r16
     a12:	82 8d       	ldd	r24, Z+26	; 0x1a
     a14:	88 23       	and	r24, r24
     a16:	69 f1       	breq	.+90     	; 0xa72 <xQueueGenericReceive+0x9a>
     a18:	e6 80       	ldd	r14, Z+6	; 0x06
     a1a:	f7 80       	ldd	r15, Z+7	; 0x07
     a1c:	b6 01       	movw	r22, r12
     a1e:	c8 01       	movw	r24, r16
     a20:	7f de       	rcall	.-770    	; 0x720 <prvCopyDataFromQueue>
     a22:	b1 10       	cpse	r11, r1
     a24:	17 c0       	rjmp	.+46     	; 0xa54 <xQueueGenericReceive+0x7c>
     a26:	f8 01       	movw	r30, r16
     a28:	82 8d       	ldd	r24, Z+26	; 0x1a
     a2a:	81 50       	subi	r24, 0x01	; 1
     a2c:	82 8f       	std	Z+26, r24	; 0x1a
     a2e:	80 81       	ld	r24, Z
     a30:	91 81       	ldd	r25, Z+1	; 0x01
     a32:	89 2b       	or	r24, r25
     a34:	21 f4       	brne	.+8      	; 0xa3e <xQueueGenericReceive+0x66>
     a36:	c2 d4       	rcall	.+2436   	; 0x13bc <xTaskGetCurrentTaskHandle>
     a38:	f8 01       	movw	r30, r16
     a3a:	82 83       	std	Z+2, r24	; 0x02
     a3c:	93 83       	std	Z+3, r25	; 0x03
     a3e:	f8 01       	movw	r30, r16
     a40:	80 85       	ldd	r24, Z+8	; 0x08
     a42:	88 23       	and	r24, r24
     a44:	91 f0       	breq	.+36     	; 0xa6a <xQueueGenericReceive+0x92>
     a46:	c8 01       	movw	r24, r16
     a48:	08 96       	adiw	r24, 0x08	; 8
     a4a:	2a d4       	rcall	.+2132   	; 0x12a0 <xTaskRemoveFromEventList>
     a4c:	81 30       	cpi	r24, 0x01	; 1
     a4e:	69 f4       	brne	.+26     	; 0xa6a <xQueueGenericReceive+0x92>
     a50:	d1 dc       	rcall	.-1630   	; 0x3f4 <vPortYield>
     a52:	0b c0       	rjmp	.+22     	; 0xa6a <xQueueGenericReceive+0x92>
     a54:	f8 01       	movw	r30, r16
     a56:	e6 82       	std	Z+6, r14	; 0x06
     a58:	f7 82       	std	Z+7, r15	; 0x07
     a5a:	81 89       	ldd	r24, Z+17	; 0x11
     a5c:	88 23       	and	r24, r24
     a5e:	29 f0       	breq	.+10     	; 0xa6a <xQueueGenericReceive+0x92>
     a60:	c8 01       	movw	r24, r16
     a62:	41 96       	adiw	r24, 0x11	; 17
     a64:	1d d4       	rcall	.+2106   	; 0x12a0 <xTaskRemoveFromEventList>
     a66:	81 11       	cpse	r24, r1
     a68:	c5 dc       	rcall	.-1654   	; 0x3f4 <vPortYield>
     a6a:	0f 90       	pop	r0
     a6c:	0f be       	out	0x3f, r0	; 63
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	53 c0       	rjmp	.+166    	; 0xb18 <xQueueGenericReceive+0x140>
     a72:	4c 81       	ldd	r20, Y+4	; 0x04
     a74:	5d 81       	ldd	r21, Y+5	; 0x05
     a76:	45 2b       	or	r20, r21
     a78:	21 f4       	brne	.+8      	; 0xa82 <xQueueGenericReceive+0xaa>
     a7a:	0f 90       	pop	r0
     a7c:	0f be       	out	0x3f, r0	; 63
     a7e:	80 e0       	ldi	r24, 0x00	; 0
     a80:	4b c0       	rjmp	.+150    	; 0xb18 <xQueueGenericReceive+0x140>
     a82:	a1 10       	cpse	r10, r1
     a84:	05 c0       	rjmp	.+10     	; 0xa90 <xQueueGenericReceive+0xb8>
     a86:	ce 01       	movw	r24, r28
     a88:	01 96       	adiw	r24, 0x01	; 1
     a8a:	4b d4       	rcall	.+2198   	; 0x1322 <vTaskSetTimeOutState>
     a8c:	aa 24       	eor	r10, r10
     a8e:	a3 94       	inc	r10
     a90:	0f 90       	pop	r0
     a92:	0f be       	out	0x3f, r0	; 63
     a94:	f2 d1       	rcall	.+996    	; 0xe7a <vTaskSuspendAll>
     a96:	0f b6       	in	r0, 0x3f	; 63
     a98:	f8 94       	cli
     a9a:	0f 92       	push	r0
     a9c:	f8 01       	movw	r30, r16
     a9e:	85 8d       	ldd	r24, Z+29	; 0x1d
     aa0:	8f 3f       	cpi	r24, 0xFF	; 255
     aa2:	09 f4       	brne	.+2      	; 0xaa6 <xQueueGenericReceive+0xce>
     aa4:	15 8e       	std	Z+29, r1	; 0x1d
     aa6:	f8 01       	movw	r30, r16
     aa8:	86 8d       	ldd	r24, Z+30	; 0x1e
     aaa:	8f 3f       	cpi	r24, 0xFF	; 255
     aac:	09 f4       	brne	.+2      	; 0xab0 <xQueueGenericReceive+0xd8>
     aae:	16 8e       	std	Z+30, r1	; 0x1e
     ab0:	0f 90       	pop	r0
     ab2:	0f be       	out	0x3f, r0	; 63
     ab4:	be 01       	movw	r22, r28
     ab6:	6c 5f       	subi	r22, 0xFC	; 252
     ab8:	7f 4f       	sbci	r23, 0xFF	; 255
     aba:	ce 01       	movw	r24, r28
     abc:	01 96       	adiw	r24, 0x01	; 1
     abe:	3c d4       	rcall	.+2168   	; 0x1338 <xTaskCheckForTimeOut>
     ac0:	81 11       	cpse	r24, r1
     ac2:	26 c0       	rjmp	.+76     	; 0xb10 <xQueueGenericReceive+0x138>
     ac4:	0f b6       	in	r0, 0x3f	; 63
     ac6:	f8 94       	cli
     ac8:	0f 92       	push	r0
     aca:	f8 01       	movw	r30, r16
     acc:	82 8d       	ldd	r24, Z+26	; 0x1a
     ace:	0f 90       	pop	r0
     ad0:	0f be       	out	0x3f, r0	; 63
     ad2:	81 11       	cpse	r24, r1
     ad4:	19 c0       	rjmp	.+50     	; 0xb08 <xQueueGenericReceive+0x130>
     ad6:	f8 01       	movw	r30, r16
     ad8:	80 81       	ld	r24, Z
     ada:	91 81       	ldd	r25, Z+1	; 0x01
     adc:	89 2b       	or	r24, r25
     ade:	49 f4       	brne	.+18     	; 0xaf2 <xQueueGenericReceive+0x11a>
     ae0:	0f b6       	in	r0, 0x3f	; 63
     ae2:	f8 94       	cli
     ae4:	0f 92       	push	r0
     ae6:	f8 01       	movw	r30, r16
     ae8:	82 81       	ldd	r24, Z+2	; 0x02
     aea:	93 81       	ldd	r25, Z+3	; 0x03
     aec:	7a d4       	rcall	.+2292   	; 0x13e2 <vTaskPriorityInherit>
     aee:	0f 90       	pop	r0
     af0:	0f be       	out	0x3f, r0	; 63
     af2:	6c 81       	ldd	r22, Y+4	; 0x04
     af4:	7d 81       	ldd	r23, Y+5	; 0x05
     af6:	c7 01       	movw	r24, r14
     af8:	91 d3       	rcall	.+1826   	; 0x121c <vTaskPlaceOnEventList>
     afa:	c8 01       	movw	r24, r16
     afc:	2b de       	rcall	.-938    	; 0x754 <prvUnlockQueue>
     afe:	8e d2       	rcall	.+1308   	; 0x101c <xTaskResumeAll>
     b00:	81 11       	cpse	r24, r1
     b02:	83 cf       	rjmp	.-250    	; 0xa0a <xQueueGenericReceive+0x32>
     b04:	77 dc       	rcall	.-1810   	; 0x3f4 <vPortYield>
     b06:	81 cf       	rjmp	.-254    	; 0xa0a <xQueueGenericReceive+0x32>
     b08:	c8 01       	movw	r24, r16
     b0a:	24 de       	rcall	.-952    	; 0x754 <prvUnlockQueue>
     b0c:	87 d2       	rcall	.+1294   	; 0x101c <xTaskResumeAll>
     b0e:	7d cf       	rjmp	.-262    	; 0xa0a <xQueueGenericReceive+0x32>
     b10:	c8 01       	movw	r24, r16
     b12:	20 de       	rcall	.-960    	; 0x754 <prvUnlockQueue>
     b14:	83 d2       	rcall	.+1286   	; 0x101c <xTaskResumeAll>
     b16:	80 e0       	ldi	r24, 0x00	; 0
     b18:	25 96       	adiw	r28, 0x05	; 5
     b1a:	cd bf       	out	0x3d, r28	; 61
     b1c:	de bf       	out	0x3e, r29	; 62
     b1e:	df 91       	pop	r29
     b20:	cf 91       	pop	r28
     b22:	1f 91       	pop	r17
     b24:	0f 91       	pop	r16
     b26:	ff 90       	pop	r15
     b28:	ef 90       	pop	r14
     b2a:	df 90       	pop	r13
     b2c:	cf 90       	pop	r12
     b2e:	bf 90       	pop	r11
     b30:	af 90       	pop	r10
     b32:	08 95       	ret

00000b34 <xQueueReceiveFromISR>:
     b34:	0f 93       	push	r16
     b36:	1f 93       	push	r17
     b38:	cf 93       	push	r28
     b3a:	df 93       	push	r29
     b3c:	ec 01       	movw	r28, r24
     b3e:	8a 01       	movw	r16, r20
     b40:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b42:	88 23       	and	r24, r24
     b44:	c1 f0       	breq	.+48     	; 0xb76 <xQueueReceiveFromISR+0x42>
     b46:	ce 01       	movw	r24, r28
     b48:	eb dd       	rcall	.-1066   	; 0x720 <prvCopyDataFromQueue>
     b4a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b4c:	81 50       	subi	r24, 0x01	; 1
     b4e:	8a 8f       	std	Y+26, r24	; 0x1a
     b50:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b52:	8f 3f       	cpi	r24, 0xFF	; 255
     b54:	61 f4       	brne	.+24     	; 0xb6e <xQueueReceiveFromISR+0x3a>
     b56:	88 85       	ldd	r24, Y+8	; 0x08
     b58:	88 23       	and	r24, r24
     b5a:	79 f0       	breq	.+30     	; 0xb7a <xQueueReceiveFromISR+0x46>
     b5c:	ce 01       	movw	r24, r28
     b5e:	08 96       	adiw	r24, 0x08	; 8
     b60:	9f d3       	rcall	.+1854   	; 0x12a0 <xTaskRemoveFromEventList>
     b62:	88 23       	and	r24, r24
     b64:	61 f0       	breq	.+24     	; 0xb7e <xQueueReceiveFromISR+0x4a>
     b66:	81 e0       	ldi	r24, 0x01	; 1
     b68:	f8 01       	movw	r30, r16
     b6a:	80 83       	st	Z, r24
     b6c:	09 c0       	rjmp	.+18     	; 0xb80 <xQueueReceiveFromISR+0x4c>
     b6e:	8f 5f       	subi	r24, 0xFF	; 255
     b70:	8d 8f       	std	Y+29, r24	; 0x1d
     b72:	81 e0       	ldi	r24, 0x01	; 1
     b74:	05 c0       	rjmp	.+10     	; 0xb80 <xQueueReceiveFromISR+0x4c>
     b76:	80 e0       	ldi	r24, 0x00	; 0
     b78:	03 c0       	rjmp	.+6      	; 0xb80 <xQueueReceiveFromISR+0x4c>
     b7a:	81 e0       	ldi	r24, 0x01	; 1
     b7c:	01 c0       	rjmp	.+2      	; 0xb80 <xQueueReceiveFromISR+0x4c>
     b7e:	81 e0       	ldi	r24, 0x01	; 1
     b80:	df 91       	pop	r29
     b82:	cf 91       	pop	r28
     b84:	1f 91       	pop	r17
     b86:	0f 91       	pop	r16
     b88:	08 95       	ret

00000b8a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
     b8a:	cf 93       	push	r28
     b8c:	df 93       	push	r29
     b8e:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
     b90:	0f b6       	in	r0, 0x3f	; 63
     b92:	f8 94       	cli
     b94:	0f 92       	push	r0
     b96:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b98:	8f 3f       	cpi	r24, 0xFF	; 255
     b9a:	09 f4       	brne	.+2      	; 0xb9e <vQueueWaitForMessageRestricted+0x14>
     b9c:	1d 8e       	std	Y+29, r1	; 0x1d
     b9e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     ba0:	8f 3f       	cpi	r24, 0xFF	; 255
     ba2:	09 f4       	brne	.+2      	; 0xba6 <vQueueWaitForMessageRestricted+0x1c>
     ba4:	1e 8e       	std	Y+30, r1	; 0x1e
     ba6:	0f 90       	pop	r0
     ba8:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
     baa:	8a 8d       	ldd	r24, Y+26	; 0x1a
     bac:	81 11       	cpse	r24, r1
     bae:	03 c0       	rjmp	.+6      	; 0xbb6 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     bb0:	ce 01       	movw	r24, r28
     bb2:	41 96       	adiw	r24, 0x11	; 17
     bb4:	5b d3       	rcall	.+1718   	; 0x126c <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
     bb6:	ce 01       	movw	r24, r28
     bb8:	cd dd       	rcall	.-1126   	; 0x754 <prvUnlockQueue>
	}
     bba:	df 91       	pop	r29
     bbc:	cf 91       	pop	r28
     bbe:	08 95       	ret

00000bc0 <prvIdleTask>:
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
     bc0:	c7 ed       	ldi	r28, 0xD7	; 215
     bc2:	d7 e3       	ldi	r29, 0x37	; 55
     bc4:	88 81       	ld	r24, Y
     bc6:	82 30       	cpi	r24, 0x02	; 2
     bc8:	e8 f3       	brcs	.-6      	; 0xbc4 <prvIdleTask+0x4>
     bca:	14 dc       	rcall	.-2008   	; 0x3f4 <vPortYield>
     bcc:	fb cf       	rjmp	.-10     	; 0xbc4 <prvIdleTask+0x4>

00000bce <prvAddCurrentTaskToDelayedList>:
     bce:	cf 93       	push	r28
     bd0:	df 93       	push	r29
     bd2:	ec 01       	movw	r28, r24
     bd4:	e0 91 fb 37 	lds	r30, 0x37FB
     bd8:	f0 91 fc 37 	lds	r31, 0x37FC
     bdc:	82 83       	std	Z+2, r24	; 0x02
     bde:	93 83       	std	Z+3, r25	; 0x03
     be0:	80 91 ac 37 	lds	r24, 0x37AC
     be4:	90 91 ad 37 	lds	r25, 0x37AD
     be8:	c8 17       	cp	r28, r24
     bea:	d9 07       	cpc	r29, r25
     bec:	60 f4       	brcc	.+24     	; 0xc06 <prvAddCurrentTaskToDelayedList+0x38>
     bee:	60 91 fb 37 	lds	r22, 0x37FB
     bf2:	70 91 fc 37 	lds	r23, 0x37FC
     bf6:	80 91 c1 37 	lds	r24, 0x37C1
     bfa:	90 91 c2 37 	lds	r25, 0x37C2
     bfe:	6e 5f       	subi	r22, 0xFE	; 254
     c00:	7f 4f       	sbci	r23, 0xFF	; 255
     c02:	e2 dc       	rcall	.-1596   	; 0x5c8 <vListInsert>
     c04:	16 c0       	rjmp	.+44     	; 0xc32 <prvAddCurrentTaskToDelayedList+0x64>
     c06:	60 91 fb 37 	lds	r22, 0x37FB
     c0a:	70 91 fc 37 	lds	r23, 0x37FC
     c0e:	80 91 c3 37 	lds	r24, 0x37C3
     c12:	90 91 c4 37 	lds	r25, 0x37C4
     c16:	6e 5f       	subi	r22, 0xFE	; 254
     c18:	7f 4f       	sbci	r23, 0xFF	; 255
     c1a:	d6 dc       	rcall	.-1620   	; 0x5c8 <vListInsert>
     c1c:	80 91 00 20 	lds	r24, 0x2000
     c20:	90 91 01 20 	lds	r25, 0x2001
     c24:	c8 17       	cp	r28, r24
     c26:	d9 07       	cpc	r29, r25
     c28:	20 f4       	brcc	.+8      	; 0xc32 <prvAddCurrentTaskToDelayedList+0x64>
     c2a:	c0 93 00 20 	sts	0x2000, r28
     c2e:	d0 93 01 20 	sts	0x2001, r29
     c32:	df 91       	pop	r29
     c34:	cf 91       	pop	r28
     c36:	08 95       	ret

00000c38 <xTaskGenericCreate>:
     c38:	4f 92       	push	r4
     c3a:	5f 92       	push	r5
     c3c:	6f 92       	push	r6
     c3e:	7f 92       	push	r7
     c40:	8f 92       	push	r8
     c42:	9f 92       	push	r9
     c44:	af 92       	push	r10
     c46:	bf 92       	push	r11
     c48:	cf 92       	push	r12
     c4a:	df 92       	push	r13
     c4c:	ef 92       	push	r14
     c4e:	ff 92       	push	r15
     c50:	0f 93       	push	r16
     c52:	1f 93       	push	r17
     c54:	cf 93       	push	r28
     c56:	df 93       	push	r29
     c58:	4c 01       	movw	r8, r24
     c5a:	3b 01       	movw	r6, r22
     c5c:	5a 01       	movw	r10, r20
     c5e:	29 01       	movw	r4, r18
     c60:	82 e2       	ldi	r24, 0x22	; 34
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	f2 da       	rcall	.-2588   	; 0x24a <pvPortMalloc>
     c66:	ec 01       	movw	r28, r24
     c68:	00 97       	sbiw	r24, 0x00	; 0
     c6a:	09 f4       	brne	.+2      	; 0xc6e <xTaskGenericCreate+0x36>
     c6c:	c8 c0       	rjmp	.+400    	; 0xdfe <xTaskGenericCreate+0x1c6>
     c6e:	c1 14       	cp	r12, r1
     c70:	d1 04       	cpc	r13, r1
     c72:	09 f0       	breq	.+2      	; 0xc76 <xTaskGenericCreate+0x3e>
     c74:	c0 c0       	rjmp	.+384    	; 0xdf6 <xTaskGenericCreate+0x1be>
     c76:	c5 01       	movw	r24, r10
     c78:	e8 da       	rcall	.-2608   	; 0x24a <pvPortMalloc>
     c7a:	8f 8b       	std	Y+23, r24	; 0x17
     c7c:	98 8f       	std	Y+24, r25	; 0x18
     c7e:	00 97       	sbiw	r24, 0x00	; 0
     c80:	19 f4       	brne	.+6      	; 0xc88 <xTaskGenericCreate+0x50>
     c82:	ce 01       	movw	r24, r28
     c84:	06 db       	rcall	.-2548   	; 0x292 <vPortFree>
     c86:	bb c0       	rjmp	.+374    	; 0xdfe <xTaskGenericCreate+0x1c6>
     c88:	a5 01       	movw	r20, r10
     c8a:	65 ea       	ldi	r22, 0xA5	; 165
     c8c:	70 e0       	ldi	r23, 0x00	; 0
     c8e:	0e 94 48 10 	call	0x2090	; 0x2090 <memset>
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	a8 1a       	sub	r10, r24
     c96:	b1 08       	sbc	r11, r1
     c98:	8f 89       	ldd	r24, Y+23	; 0x17
     c9a:	98 8d       	ldd	r25, Y+24	; 0x18
     c9c:	a8 0e       	add	r10, r24
     c9e:	b9 1e       	adc	r11, r25
     ca0:	48 e0       	ldi	r20, 0x08	; 8
     ca2:	50 e0       	ldi	r21, 0x00	; 0
     ca4:	b3 01       	movw	r22, r6
     ca6:	ce 01       	movw	r24, r28
     ca8:	49 96       	adiw	r24, 0x19	; 25
     caa:	0e 94 4f 10 	call	0x209e	; 0x209e <strncpy>
     cae:	18 a2       	std	Y+32, r1	; 0x20
     cb0:	10 2f       	mov	r17, r16
     cb2:	04 30       	cpi	r16, 0x04	; 4
     cb4:	08 f0       	brcs	.+2      	; 0xcb8 <xTaskGenericCreate+0x80>
     cb6:	13 e0       	ldi	r17, 0x03	; 3
     cb8:	1e 8b       	std	Y+22, r17	; 0x16
     cba:	19 a3       	std	Y+33, r17	; 0x21
     cbc:	6e 01       	movw	r12, r28
     cbe:	e2 e0       	ldi	r30, 0x02	; 2
     cc0:	ce 0e       	add	r12, r30
     cc2:	d1 1c       	adc	r13, r1
     cc4:	c6 01       	movw	r24, r12
     cc6:	55 dc       	rcall	.-1878   	; 0x572 <vListInitialiseItem>
     cc8:	ce 01       	movw	r24, r28
     cca:	0c 96       	adiw	r24, 0x0c	; 12
     ccc:	52 dc       	rcall	.-1884   	; 0x572 <vListInitialiseItem>
     cce:	c8 87       	std	Y+8, r28	; 0x08
     cd0:	d9 87       	std	Y+9, r29	; 0x09
     cd2:	84 e0       	ldi	r24, 0x04	; 4
     cd4:	90 e0       	ldi	r25, 0x00	; 0
     cd6:	81 1b       	sub	r24, r17
     cd8:	91 09       	sbc	r25, r1
     cda:	8c 87       	std	Y+12, r24	; 0x0c
     cdc:	9d 87       	std	Y+13, r25	; 0x0d
     cde:	ca 8b       	std	Y+18, r28	; 0x12
     ce0:	db 8b       	std	Y+19, r29	; 0x13
     ce2:	a2 01       	movw	r20, r4
     ce4:	b4 01       	movw	r22, r8
     ce6:	c5 01       	movw	r24, r10
     ce8:	d5 da       	rcall	.-2646   	; 0x294 <pxPortInitialiseStack>
     cea:	88 83       	st	Y, r24
     cec:	99 83       	std	Y+1, r25	; 0x01
     cee:	e1 14       	cp	r14, r1
     cf0:	f1 04       	cpc	r15, r1
     cf2:	19 f0       	breq	.+6      	; 0xcfa <xTaskGenericCreate+0xc2>
     cf4:	f7 01       	movw	r30, r14
     cf6:	c0 83       	st	Z, r28
     cf8:	d1 83       	std	Z+1, r29	; 0x01
     cfa:	0f b6       	in	r0, 0x3f	; 63
     cfc:	f8 94       	cli
     cfe:	0f 92       	push	r0
     d00:	80 91 ae 37 	lds	r24, 0x37AE
     d04:	8f 5f       	subi	r24, 0xFF	; 255
     d06:	80 93 ae 37 	sts	0x37AE, r24
     d0a:	80 91 fb 37 	lds	r24, 0x37FB
     d0e:	90 91 fc 37 	lds	r25, 0x37FC
     d12:	89 2b       	or	r24, r25
     d14:	69 f5       	brne	.+90     	; 0xd70 <xTaskGenericCreate+0x138>
     d16:	c0 93 fb 37 	sts	0x37FB, r28
     d1a:	d0 93 fc 37 	sts	0x37FC, r29
     d1e:	80 91 ae 37 	lds	r24, 0x37AE
     d22:	81 30       	cpi	r24, 0x01	; 1
     d24:	a1 f5       	brne	.+104    	; 0xd8e <xTaskGenericCreate+0x156>
     d26:	87 ed       	ldi	r24, 0xD7	; 215
     d28:	97 e3       	ldi	r25, 0x37	; 55
     d2a:	15 dc       	rcall	.-2006   	; 0x556 <vListInitialise>
     d2c:	80 ee       	ldi	r24, 0xE0	; 224
     d2e:	97 e3       	ldi	r25, 0x37	; 55
     d30:	12 dc       	rcall	.-2012   	; 0x556 <vListInitialise>
     d32:	89 ee       	ldi	r24, 0xE9	; 233
     d34:	97 e3       	ldi	r25, 0x37	; 55
     d36:	0f dc       	rcall	.-2018   	; 0x556 <vListInitialise>
     d38:	82 ef       	ldi	r24, 0xF2	; 242
     d3a:	97 e3       	ldi	r25, 0x37	; 55
     d3c:	0c dc       	rcall	.-2024   	; 0x556 <vListInitialise>
     d3e:	8e ec       	ldi	r24, 0xCE	; 206
     d40:	97 e3       	ldi	r25, 0x37	; 55
     d42:	09 dc       	rcall	.-2030   	; 0x556 <vListInitialise>
     d44:	85 ec       	ldi	r24, 0xC5	; 197
     d46:	97 e3       	ldi	r25, 0x37	; 55
     d48:	06 dc       	rcall	.-2036   	; 0x556 <vListInitialise>
     d4a:	88 eb       	ldi	r24, 0xB8	; 184
     d4c:	97 e3       	ldi	r25, 0x37	; 55
     d4e:	03 dc       	rcall	.-2042   	; 0x556 <vListInitialise>
     d50:	8f ea       	ldi	r24, 0xAF	; 175
     d52:	97 e3       	ldi	r25, 0x37	; 55
     d54:	00 dc       	rcall	.-2048   	; 0x556 <vListInitialise>
     d56:	8e ec       	ldi	r24, 0xCE	; 206
     d58:	97 e3       	ldi	r25, 0x37	; 55
     d5a:	80 93 c3 37 	sts	0x37C3, r24
     d5e:	90 93 c4 37 	sts	0x37C4, r25
     d62:	85 ec       	ldi	r24, 0xC5	; 197
     d64:	97 e3       	ldi	r25, 0x37	; 55
     d66:	80 93 c1 37 	sts	0x37C1, r24
     d6a:	90 93 c2 37 	sts	0x37C2, r25
     d6e:	0f c0       	rjmp	.+30     	; 0xd8e <xTaskGenericCreate+0x156>
     d70:	80 91 a9 37 	lds	r24, 0x37A9
     d74:	81 11       	cpse	r24, r1
     d76:	0b c0       	rjmp	.+22     	; 0xd8e <xTaskGenericCreate+0x156>
     d78:	e0 91 fb 37 	lds	r30, 0x37FB
     d7c:	f0 91 fc 37 	lds	r31, 0x37FC
     d80:	86 89       	ldd	r24, Z+22	; 0x16
     d82:	08 17       	cp	r16, r24
     d84:	20 f0       	brcs	.+8      	; 0xd8e <xTaskGenericCreate+0x156>
     d86:	c0 93 fb 37 	sts	0x37FB, r28
     d8a:	d0 93 fc 37 	sts	0x37FC, r29
     d8e:	8e 89       	ldd	r24, Y+22	; 0x16
     d90:	90 91 ab 37 	lds	r25, 0x37AB
     d94:	98 17       	cp	r25, r24
     d96:	10 f4       	brcc	.+4      	; 0xd9c <xTaskGenericCreate+0x164>
     d98:	80 93 ab 37 	sts	0x37AB, r24
     d9c:	90 91 a4 37 	lds	r25, 0x37A4
     da0:	9f 5f       	subi	r25, 0xFF	; 255
     da2:	90 93 a4 37 	sts	0x37A4, r25
     da6:	90 91 aa 37 	lds	r25, 0x37AA
     daa:	98 17       	cp	r25, r24
     dac:	10 f4       	brcc	.+4      	; 0xdb2 <xTaskGenericCreate+0x17a>
     dae:	80 93 aa 37 	sts	0x37AA, r24
     db2:	90 e0       	ldi	r25, 0x00	; 0
     db4:	9c 01       	movw	r18, r24
     db6:	22 0f       	add	r18, r18
     db8:	33 1f       	adc	r19, r19
     dba:	22 0f       	add	r18, r18
     dbc:	33 1f       	adc	r19, r19
     dbe:	22 0f       	add	r18, r18
     dc0:	33 1f       	adc	r19, r19
     dc2:	82 0f       	add	r24, r18
     dc4:	93 1f       	adc	r25, r19
     dc6:	b6 01       	movw	r22, r12
     dc8:	89 52       	subi	r24, 0x29	; 41
     dca:	98 4c       	sbci	r25, 0xC8	; 200
     dcc:	d6 db       	rcall	.-2132   	; 0x57a <vListInsertEnd>
     dce:	0f 90       	pop	r0
     dd0:	0f be       	out	0x3f, r0	; 63
     dd2:	80 91 a9 37 	lds	r24, 0x37A9
     dd6:	88 23       	and	r24, r24
     dd8:	51 f0       	breq	.+20     	; 0xdee <xTaskGenericCreate+0x1b6>
     dda:	e0 91 fb 37 	lds	r30, 0x37FB
     dde:	f0 91 fc 37 	lds	r31, 0x37FC
     de2:	86 89       	ldd	r24, Z+22	; 0x16
     de4:	80 17       	cp	r24, r16
     de6:	28 f4       	brcc	.+10     	; 0xdf2 <xTaskGenericCreate+0x1ba>
     de8:	05 db       	rcall	.-2550   	; 0x3f4 <vPortYield>
     dea:	81 e0       	ldi	r24, 0x01	; 1
     dec:	09 c0       	rjmp	.+18     	; 0xe00 <xTaskGenericCreate+0x1c8>
     dee:	81 e0       	ldi	r24, 0x01	; 1
     df0:	07 c0       	rjmp	.+14     	; 0xe00 <xTaskGenericCreate+0x1c8>
     df2:	81 e0       	ldi	r24, 0x01	; 1
     df4:	05 c0       	rjmp	.+10     	; 0xe00 <xTaskGenericCreate+0x1c8>
     df6:	cf 8a       	std	Y+23, r12	; 0x17
     df8:	d8 8e       	std	Y+24, r13	; 0x18
     dfa:	c6 01       	movw	r24, r12
     dfc:	45 cf       	rjmp	.-374    	; 0xc88 <xTaskGenericCreate+0x50>
     dfe:	8f ef       	ldi	r24, 0xFF	; 255
     e00:	df 91       	pop	r29
     e02:	cf 91       	pop	r28
     e04:	1f 91       	pop	r17
     e06:	0f 91       	pop	r16
     e08:	ff 90       	pop	r15
     e0a:	ef 90       	pop	r14
     e0c:	df 90       	pop	r13
     e0e:	cf 90       	pop	r12
     e10:	bf 90       	pop	r11
     e12:	af 90       	pop	r10
     e14:	9f 90       	pop	r9
     e16:	8f 90       	pop	r8
     e18:	7f 90       	pop	r7
     e1a:	6f 90       	pop	r6
     e1c:	5f 90       	pop	r5
     e1e:	4f 90       	pop	r4
     e20:	08 95       	ret

00000e22 <vTaskStartScheduler>:
     e22:	af 92       	push	r10
     e24:	bf 92       	push	r11
     e26:	cf 92       	push	r12
     e28:	df 92       	push	r13
     e2a:	ef 92       	push	r14
     e2c:	ff 92       	push	r15
     e2e:	0f 93       	push	r16
     e30:	a1 2c       	mov	r10, r1
     e32:	b1 2c       	mov	r11, r1
     e34:	c1 2c       	mov	r12, r1
     e36:	d1 2c       	mov	r13, r1
     e38:	e1 2c       	mov	r14, r1
     e3a:	f1 2c       	mov	r15, r1
     e3c:	00 e0       	ldi	r16, 0x00	; 0
     e3e:	20 e0       	ldi	r18, 0x00	; 0
     e40:	30 e0       	ldi	r19, 0x00	; 0
     e42:	46 e9       	ldi	r20, 0x96	; 150
     e44:	50 e0       	ldi	r21, 0x00	; 0
     e46:	62 e0       	ldi	r22, 0x02	; 2
     e48:	70 e2       	ldi	r23, 0x20	; 32
     e4a:	80 ee       	ldi	r24, 0xE0	; 224
     e4c:	95 e0       	ldi	r25, 0x05	; 5
     e4e:	f4 de       	rcall	.-536    	; 0xc38 <xTaskGenericCreate>
     e50:	81 30       	cpi	r24, 0x01	; 1
     e52:	59 f4       	brne	.+22     	; 0xe6a <vTaskStartScheduler+0x48>
     e54:	a0 d3       	rcall	.+1856   	; 0x1596 <xTimerCreateTimerTask>
     e56:	81 30       	cpi	r24, 0x01	; 1
     e58:	41 f4       	brne	.+16     	; 0xe6a <vTaskStartScheduler+0x48>
     e5a:	f8 94       	cli
     e5c:	80 93 a9 37 	sts	0x37A9, r24
     e60:	10 92 ac 37 	sts	0x37AC, r1
     e64:	10 92 ad 37 	sts	0x37AD, r1
     e68:	83 da       	rcall	.-2810   	; 0x370 <xPortStartScheduler>
     e6a:	0f 91       	pop	r16
     e6c:	ff 90       	pop	r15
     e6e:	ef 90       	pop	r14
     e70:	df 90       	pop	r13
     e72:	cf 90       	pop	r12
     e74:	bf 90       	pop	r11
     e76:	af 90       	pop	r10
     e78:	08 95       	ret

00000e7a <vTaskSuspendAll>:
     e7a:	80 91 a8 37 	lds	r24, 0x37A8
     e7e:	8f 5f       	subi	r24, 0xFF	; 255
     e80:	80 93 a8 37 	sts	0x37A8, r24
     e84:	08 95       	ret

00000e86 <xTaskGetTickCount>:
     e86:	0f b6       	in	r0, 0x3f	; 63
     e88:	f8 94       	cli
     e8a:	0f 92       	push	r0
     e8c:	80 91 ac 37 	lds	r24, 0x37AC
     e90:	90 91 ad 37 	lds	r25, 0x37AD
     e94:	0f 90       	pop	r0
     e96:	0f be       	out	0x3f, r0	; 63
     e98:	08 95       	ret

00000e9a <vTaskIncrementTick>:
     e9a:	0f 93       	push	r16
     e9c:	1f 93       	push	r17
     e9e:	cf 93       	push	r28
     ea0:	df 93       	push	r29
     ea2:	80 91 a8 37 	lds	r24, 0x37A8
     ea6:	81 11       	cpse	r24, r1
     ea8:	af c0       	rjmp	.+350    	; 0x1008 <vTaskIncrementTick+0x16e>
     eaa:	80 91 ac 37 	lds	r24, 0x37AC
     eae:	90 91 ad 37 	lds	r25, 0x37AD
     eb2:	01 96       	adiw	r24, 0x01	; 1
     eb4:	80 93 ac 37 	sts	0x37AC, r24
     eb8:	90 93 ad 37 	sts	0x37AD, r25
     ebc:	80 91 ac 37 	lds	r24, 0x37AC
     ec0:	90 91 ad 37 	lds	r25, 0x37AD
     ec4:	89 2b       	or	r24, r25
     ec6:	99 f5       	brne	.+102    	; 0xf2e <vTaskIncrementTick+0x94>
     ec8:	80 91 c3 37 	lds	r24, 0x37C3
     ecc:	90 91 c4 37 	lds	r25, 0x37C4
     ed0:	20 91 c1 37 	lds	r18, 0x37C1
     ed4:	30 91 c2 37 	lds	r19, 0x37C2
     ed8:	20 93 c3 37 	sts	0x37C3, r18
     edc:	30 93 c4 37 	sts	0x37C4, r19
     ee0:	80 93 c1 37 	sts	0x37C1, r24
     ee4:	90 93 c2 37 	sts	0x37C2, r25
     ee8:	80 91 a5 37 	lds	r24, 0x37A5
     eec:	8f 5f       	subi	r24, 0xFF	; 255
     eee:	80 93 a5 37 	sts	0x37A5, r24
     ef2:	e0 91 c3 37 	lds	r30, 0x37C3
     ef6:	f0 91 c4 37 	lds	r31, 0x37C4
     efa:	80 81       	ld	r24, Z
     efc:	81 11       	cpse	r24, r1
     efe:	07 c0       	rjmp	.+14     	; 0xf0e <vTaskIncrementTick+0x74>
     f00:	8f ef       	ldi	r24, 0xFF	; 255
     f02:	9f ef       	ldi	r25, 0xFF	; 255
     f04:	80 93 00 20 	sts	0x2000, r24
     f08:	90 93 01 20 	sts	0x2001, r25
     f0c:	10 c0       	rjmp	.+32     	; 0xf2e <vTaskIncrementTick+0x94>
     f0e:	e0 91 c3 37 	lds	r30, 0x37C3
     f12:	f0 91 c4 37 	lds	r31, 0x37C4
     f16:	05 80       	ldd	r0, Z+5	; 0x05
     f18:	f6 81       	ldd	r31, Z+6	; 0x06
     f1a:	e0 2d       	mov	r30, r0
     f1c:	06 80       	ldd	r0, Z+6	; 0x06
     f1e:	f7 81       	ldd	r31, Z+7	; 0x07
     f20:	e0 2d       	mov	r30, r0
     f22:	82 81       	ldd	r24, Z+2	; 0x02
     f24:	93 81       	ldd	r25, Z+3	; 0x03
     f26:	80 93 00 20 	sts	0x2000, r24
     f2a:	90 93 01 20 	sts	0x2001, r25
     f2e:	20 91 ac 37 	lds	r18, 0x37AC
     f32:	30 91 ad 37 	lds	r19, 0x37AD
     f36:	80 91 00 20 	lds	r24, 0x2000
     f3a:	90 91 01 20 	lds	r25, 0x2001
     f3e:	28 17       	cp	r18, r24
     f40:	39 07       	cpc	r19, r25
     f42:	08 f4       	brcc	.+2      	; 0xf46 <vTaskIncrementTick+0xac>
     f44:	66 c0       	rjmp	.+204    	; 0x1012 <vTaskIncrementTick+0x178>
     f46:	e0 91 c3 37 	lds	r30, 0x37C3
     f4a:	f0 91 c4 37 	lds	r31, 0x37C4
     f4e:	80 81       	ld	r24, Z
     f50:	88 23       	and	r24, r24
     f52:	99 f0       	breq	.+38     	; 0xf7a <vTaskIncrementTick+0xe0>
     f54:	e0 91 c3 37 	lds	r30, 0x37C3
     f58:	f0 91 c4 37 	lds	r31, 0x37C4
     f5c:	05 80       	ldd	r0, Z+5	; 0x05
     f5e:	f6 81       	ldd	r31, Z+6	; 0x06
     f60:	e0 2d       	mov	r30, r0
     f62:	c6 81       	ldd	r28, Z+6	; 0x06
     f64:	d7 81       	ldd	r29, Z+7	; 0x07
     f66:	8a 81       	ldd	r24, Y+2	; 0x02
     f68:	9b 81       	ldd	r25, Y+3	; 0x03
     f6a:	20 91 ac 37 	lds	r18, 0x37AC
     f6e:	30 91 ad 37 	lds	r19, 0x37AD
     f72:	28 17       	cp	r18, r24
     f74:	39 07       	cpc	r19, r25
     f76:	f8 f4       	brcc	.+62     	; 0xfb6 <vTaskIncrementTick+0x11c>
     f78:	19 c0       	rjmp	.+50     	; 0xfac <vTaskIncrementTick+0x112>
     f7a:	8f ef       	ldi	r24, 0xFF	; 255
     f7c:	9f ef       	ldi	r25, 0xFF	; 255
     f7e:	80 93 00 20 	sts	0x2000, r24
     f82:	90 93 01 20 	sts	0x2001, r25
     f86:	45 c0       	rjmp	.+138    	; 0x1012 <vTaskIncrementTick+0x178>
     f88:	e0 91 c3 37 	lds	r30, 0x37C3
     f8c:	f0 91 c4 37 	lds	r31, 0x37C4
     f90:	05 80       	ldd	r0, Z+5	; 0x05
     f92:	f6 81       	ldd	r31, Z+6	; 0x06
     f94:	e0 2d       	mov	r30, r0
     f96:	c6 81       	ldd	r28, Z+6	; 0x06
     f98:	d7 81       	ldd	r29, Z+7	; 0x07
     f9a:	8a 81       	ldd	r24, Y+2	; 0x02
     f9c:	9b 81       	ldd	r25, Y+3	; 0x03
     f9e:	20 91 ac 37 	lds	r18, 0x37AC
     fa2:	30 91 ad 37 	lds	r19, 0x37AD
     fa6:	28 17       	cp	r18, r24
     fa8:	39 07       	cpc	r19, r25
     faa:	28 f4       	brcc	.+10     	; 0xfb6 <vTaskIncrementTick+0x11c>
     fac:	80 93 00 20 	sts	0x2000, r24
     fb0:	90 93 01 20 	sts	0x2001, r25
     fb4:	2e c0       	rjmp	.+92     	; 0x1012 <vTaskIncrementTick+0x178>
     fb6:	8e 01       	movw	r16, r28
     fb8:	0e 5f       	subi	r16, 0xFE	; 254
     fba:	1f 4f       	sbci	r17, 0xFF	; 255
     fbc:	c8 01       	movw	r24, r16
     fbe:	3f db       	rcall	.-2434   	; 0x63e <vListRemove>
     fc0:	8c 89       	ldd	r24, Y+20	; 0x14
     fc2:	9d 89       	ldd	r25, Y+21	; 0x15
     fc4:	89 2b       	or	r24, r25
     fc6:	19 f0       	breq	.+6      	; 0xfce <vTaskIncrementTick+0x134>
     fc8:	ce 01       	movw	r24, r28
     fca:	0c 96       	adiw	r24, 0x0c	; 12
     fcc:	38 db       	rcall	.-2448   	; 0x63e <vListRemove>
     fce:	8e 89       	ldd	r24, Y+22	; 0x16
     fd0:	90 91 aa 37 	lds	r25, 0x37AA
     fd4:	98 17       	cp	r25, r24
     fd6:	10 f4       	brcc	.+4      	; 0xfdc <vTaskIncrementTick+0x142>
     fd8:	80 93 aa 37 	sts	0x37AA, r24
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	9c 01       	movw	r18, r24
     fe0:	22 0f       	add	r18, r18
     fe2:	33 1f       	adc	r19, r19
     fe4:	22 0f       	add	r18, r18
     fe6:	33 1f       	adc	r19, r19
     fe8:	22 0f       	add	r18, r18
     fea:	33 1f       	adc	r19, r19
     fec:	82 0f       	add	r24, r18
     fee:	93 1f       	adc	r25, r19
     ff0:	b8 01       	movw	r22, r16
     ff2:	89 52       	subi	r24, 0x29	; 41
     ff4:	98 4c       	sbci	r25, 0xC8	; 200
     ff6:	c1 da       	rcall	.-2686   	; 0x57a <vListInsertEnd>
     ff8:	e0 91 c3 37 	lds	r30, 0x37C3
     ffc:	f0 91 c4 37 	lds	r31, 0x37C4
    1000:	80 81       	ld	r24, Z
    1002:	81 11       	cpse	r24, r1
    1004:	c1 cf       	rjmp	.-126    	; 0xf88 <vTaskIncrementTick+0xee>
    1006:	b9 cf       	rjmp	.-142    	; 0xf7a <vTaskIncrementTick+0xe0>
    1008:	80 91 a7 37 	lds	r24, 0x37A7
    100c:	8f 5f       	subi	r24, 0xFF	; 255
    100e:	80 93 a7 37 	sts	0x37A7, r24
    1012:	df 91       	pop	r29
    1014:	cf 91       	pop	r28
    1016:	1f 91       	pop	r17
    1018:	0f 91       	pop	r16
    101a:	08 95       	ret

0000101c <xTaskResumeAll>:
    101c:	bf 92       	push	r11
    101e:	cf 92       	push	r12
    1020:	df 92       	push	r13
    1022:	ef 92       	push	r14
    1024:	ff 92       	push	r15
    1026:	0f 93       	push	r16
    1028:	1f 93       	push	r17
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	0f b6       	in	r0, 0x3f	; 63
    1030:	f8 94       	cli
    1032:	0f 92       	push	r0
    1034:	80 91 a8 37 	lds	r24, 0x37A8
    1038:	81 50       	subi	r24, 0x01	; 1
    103a:	80 93 a8 37 	sts	0x37A8, r24
    103e:	80 91 a8 37 	lds	r24, 0x37A8
    1042:	81 11       	cpse	r24, r1
    1044:	62 c0       	rjmp	.+196    	; 0x110a <xTaskResumeAll+0xee>
    1046:	80 91 ae 37 	lds	r24, 0x37AE
    104a:	88 23       	and	r24, r24
    104c:	09 f4       	brne	.+2      	; 0x1050 <xTaskResumeAll+0x34>
    104e:	5f c0       	rjmp	.+190    	; 0x110e <xTaskResumeAll+0xf2>
    1050:	b1 2c       	mov	r11, r1
    1052:	0f 2e       	mov	r0, r31
    1054:	f8 eb       	ldi	r31, 0xB8	; 184
    1056:	ef 2e       	mov	r14, r31
    1058:	f7 e3       	ldi	r31, 0x37	; 55
    105a:	ff 2e       	mov	r15, r31
    105c:	f0 2d       	mov	r31, r0
    105e:	0f 2e       	mov	r0, r31
    1060:	fd eb       	ldi	r31, 0xBD	; 189
    1062:	cf 2e       	mov	r12, r31
    1064:	f7 e3       	ldi	r31, 0x37	; 55
    1066:	df 2e       	mov	r13, r31
    1068:	f0 2d       	mov	r31, r0
    106a:	2c c0       	rjmp	.+88     	; 0x10c4 <xTaskResumeAll+0xa8>
    106c:	d6 01       	movw	r26, r12
    106e:	ed 91       	ld	r30, X+
    1070:	fc 91       	ld	r31, X
    1072:	c6 81       	ldd	r28, Z+6	; 0x06
    1074:	d7 81       	ldd	r29, Z+7	; 0x07
    1076:	ce 01       	movw	r24, r28
    1078:	0c 96       	adiw	r24, 0x0c	; 12
    107a:	e1 da       	rcall	.-2622   	; 0x63e <vListRemove>
    107c:	8e 01       	movw	r16, r28
    107e:	0e 5f       	subi	r16, 0xFE	; 254
    1080:	1f 4f       	sbci	r17, 0xFF	; 255
    1082:	c8 01       	movw	r24, r16
    1084:	dc da       	rcall	.-2632   	; 0x63e <vListRemove>
    1086:	8e 89       	ldd	r24, Y+22	; 0x16
    1088:	90 91 aa 37 	lds	r25, 0x37AA
    108c:	98 17       	cp	r25, r24
    108e:	10 f4       	brcc	.+4      	; 0x1094 <xTaskResumeAll+0x78>
    1090:	80 93 aa 37 	sts	0x37AA, r24
    1094:	90 e0       	ldi	r25, 0x00	; 0
    1096:	9c 01       	movw	r18, r24
    1098:	22 0f       	add	r18, r18
    109a:	33 1f       	adc	r19, r19
    109c:	22 0f       	add	r18, r18
    109e:	33 1f       	adc	r19, r19
    10a0:	22 0f       	add	r18, r18
    10a2:	33 1f       	adc	r19, r19
    10a4:	82 0f       	add	r24, r18
    10a6:	93 1f       	adc	r25, r19
    10a8:	b8 01       	movw	r22, r16
    10aa:	89 52       	subi	r24, 0x29	; 41
    10ac:	98 4c       	sbci	r25, 0xC8	; 200
    10ae:	65 da       	rcall	.-2870   	; 0x57a <vListInsertEnd>
    10b0:	e0 91 fb 37 	lds	r30, 0x37FB
    10b4:	f0 91 fc 37 	lds	r31, 0x37FC
    10b8:	9e 89       	ldd	r25, Y+22	; 0x16
    10ba:	86 89       	ldd	r24, Z+22	; 0x16
    10bc:	98 17       	cp	r25, r24
    10be:	10 f0       	brcs	.+4      	; 0x10c4 <xTaskResumeAll+0xa8>
    10c0:	bb 24       	eor	r11, r11
    10c2:	b3 94       	inc	r11
    10c4:	f7 01       	movw	r30, r14
    10c6:	80 81       	ld	r24, Z
    10c8:	81 11       	cpse	r24, r1
    10ca:	d0 cf       	rjmp	.-96     	; 0x106c <xTaskResumeAll+0x50>
    10cc:	80 91 a7 37 	lds	r24, 0x37A7
    10d0:	88 23       	and	r24, r24
    10d2:	79 f0       	breq	.+30     	; 0x10f2 <xTaskResumeAll+0xd6>
    10d4:	80 91 a7 37 	lds	r24, 0x37A7
    10d8:	88 23       	and	r24, r24
    10da:	91 f0       	breq	.+36     	; 0x1100 <xTaskResumeAll+0xe4>
    10dc:	de de       	rcall	.-580    	; 0xe9a <vTaskIncrementTick>
    10de:	80 91 a7 37 	lds	r24, 0x37A7
    10e2:	81 50       	subi	r24, 0x01	; 1
    10e4:	80 93 a7 37 	sts	0x37A7, r24
    10e8:	80 91 a7 37 	lds	r24, 0x37A7
    10ec:	81 11       	cpse	r24, r1
    10ee:	f6 cf       	rjmp	.-20     	; 0x10dc <xTaskResumeAll+0xc0>
    10f0:	07 c0       	rjmp	.+14     	; 0x1100 <xTaskResumeAll+0xe4>
    10f2:	f1 e0       	ldi	r31, 0x01	; 1
    10f4:	bf 16       	cp	r11, r31
    10f6:	21 f0       	breq	.+8      	; 0x1100 <xTaskResumeAll+0xe4>
    10f8:	80 91 a6 37 	lds	r24, 0x37A6
    10fc:	81 30       	cpi	r24, 0x01	; 1
    10fe:	49 f4       	brne	.+18     	; 0x1112 <xTaskResumeAll+0xf6>
    1100:	10 92 a6 37 	sts	0x37A6, r1
    1104:	77 d9       	rcall	.-3346   	; 0x3f4 <vPortYield>
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	05 c0       	rjmp	.+10     	; 0x1114 <xTaskResumeAll+0xf8>
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	03 c0       	rjmp	.+6      	; 0x1114 <xTaskResumeAll+0xf8>
    110e:	80 e0       	ldi	r24, 0x00	; 0
    1110:	01 c0       	rjmp	.+2      	; 0x1114 <xTaskResumeAll+0xf8>
    1112:	80 e0       	ldi	r24, 0x00	; 0
    1114:	0f 90       	pop	r0
    1116:	0f be       	out	0x3f, r0	; 63
    1118:	df 91       	pop	r29
    111a:	cf 91       	pop	r28
    111c:	1f 91       	pop	r17
    111e:	0f 91       	pop	r16
    1120:	ff 90       	pop	r15
    1122:	ef 90       	pop	r14
    1124:	df 90       	pop	r13
    1126:	cf 90       	pop	r12
    1128:	bf 90       	pop	r11
    112a:	08 95       	ret

0000112c <vTaskDelay>:
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	ec 01       	movw	r28, r24
    1132:	00 97       	sbiw	r24, 0x00	; 0
    1134:	91 f0       	breq	.+36     	; 0x115a <vTaskDelay+0x2e>
    1136:	a1 de       	rcall	.-702    	; 0xe7a <vTaskSuspendAll>
    1138:	80 91 ac 37 	lds	r24, 0x37AC
    113c:	90 91 ad 37 	lds	r25, 0x37AD
    1140:	c8 0f       	add	r28, r24
    1142:	d9 1f       	adc	r29, r25
    1144:	80 91 fb 37 	lds	r24, 0x37FB
    1148:	90 91 fc 37 	lds	r25, 0x37FC
    114c:	02 96       	adiw	r24, 0x02	; 2
    114e:	77 da       	rcall	.-2834   	; 0x63e <vListRemove>
    1150:	ce 01       	movw	r24, r28
    1152:	3d dd       	rcall	.-1414   	; 0xbce <prvAddCurrentTaskToDelayedList>
    1154:	63 df       	rcall	.-314    	; 0x101c <xTaskResumeAll>
    1156:	81 11       	cpse	r24, r1
    1158:	01 c0       	rjmp	.+2      	; 0x115c <vTaskDelay+0x30>
    115a:	4c d9       	rcall	.-3432   	; 0x3f4 <vPortYield>
    115c:	df 91       	pop	r29
    115e:	cf 91       	pop	r28
    1160:	08 95       	ret

00001162 <vTaskSwitchContext>:
    1162:	80 91 a8 37 	lds	r24, 0x37A8
    1166:	81 11       	cpse	r24, r1
    1168:	13 c0       	rjmp	.+38     	; 0x1190 <vTaskSwitchContext+0x2e>
    116a:	80 91 aa 37 	lds	r24, 0x37AA
    116e:	90 e0       	ldi	r25, 0x00	; 0
    1170:	fc 01       	movw	r30, r24
    1172:	ee 0f       	add	r30, r30
    1174:	ff 1f       	adc	r31, r31
    1176:	ee 0f       	add	r30, r30
    1178:	ff 1f       	adc	r31, r31
    117a:	ee 0f       	add	r30, r30
    117c:	ff 1f       	adc	r31, r31
    117e:	8e 0f       	add	r24, r30
    1180:	9f 1f       	adc	r25, r31
    1182:	fc 01       	movw	r30, r24
    1184:	e9 52       	subi	r30, 0x29	; 41
    1186:	f8 4c       	sbci	r31, 0xC8	; 200
    1188:	80 81       	ld	r24, Z
    118a:	88 23       	and	r24, r24
    118c:	29 f0       	breq	.+10     	; 0x1198 <vTaskSwitchContext+0x36>
    118e:	1b c0       	rjmp	.+54     	; 0x11c6 <vTaskSwitchContext+0x64>
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	80 93 a6 37 	sts	0x37A6, r24
    1196:	08 95       	ret
    1198:	80 91 aa 37 	lds	r24, 0x37AA
    119c:	81 50       	subi	r24, 0x01	; 1
    119e:	80 93 aa 37 	sts	0x37AA, r24
    11a2:	80 91 aa 37 	lds	r24, 0x37AA
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	fc 01       	movw	r30, r24
    11aa:	ee 0f       	add	r30, r30
    11ac:	ff 1f       	adc	r31, r31
    11ae:	ee 0f       	add	r30, r30
    11b0:	ff 1f       	adc	r31, r31
    11b2:	ee 0f       	add	r30, r30
    11b4:	ff 1f       	adc	r31, r31
    11b6:	8e 0f       	add	r24, r30
    11b8:	9f 1f       	adc	r25, r31
    11ba:	fc 01       	movw	r30, r24
    11bc:	e9 52       	subi	r30, 0x29	; 41
    11be:	f8 4c       	sbci	r31, 0xC8	; 200
    11c0:	80 81       	ld	r24, Z
    11c2:	88 23       	and	r24, r24
    11c4:	49 f3       	breq	.-46     	; 0x1198 <vTaskSwitchContext+0x36>
    11c6:	e0 91 aa 37 	lds	r30, 0x37AA
    11ca:	f0 e0       	ldi	r31, 0x00	; 0
    11cc:	cf 01       	movw	r24, r30
    11ce:	88 0f       	add	r24, r24
    11d0:	99 1f       	adc	r25, r25
    11d2:	88 0f       	add	r24, r24
    11d4:	99 1f       	adc	r25, r25
    11d6:	88 0f       	add	r24, r24
    11d8:	99 1f       	adc	r25, r25
    11da:	e8 0f       	add	r30, r24
    11dc:	f9 1f       	adc	r31, r25
    11de:	e9 52       	subi	r30, 0x29	; 41
    11e0:	f8 4c       	sbci	r31, 0xC8	; 200
    11e2:	a1 81       	ldd	r26, Z+1	; 0x01
    11e4:	b2 81       	ldd	r27, Z+2	; 0x02
    11e6:	12 96       	adiw	r26, 0x02	; 2
    11e8:	0d 90       	ld	r0, X+
    11ea:	bc 91       	ld	r27, X
    11ec:	a0 2d       	mov	r26, r0
    11ee:	a1 83       	std	Z+1, r26	; 0x01
    11f0:	b2 83       	std	Z+2, r27	; 0x02
    11f2:	cf 01       	movw	r24, r30
    11f4:	03 96       	adiw	r24, 0x03	; 3
    11f6:	a8 17       	cp	r26, r24
    11f8:	b9 07       	cpc	r27, r25
    11fa:	31 f4       	brne	.+12     	; 0x1208 <vTaskSwitchContext+0xa6>
    11fc:	12 96       	adiw	r26, 0x02	; 2
    11fe:	8d 91       	ld	r24, X+
    1200:	9c 91       	ld	r25, X
    1202:	13 97       	sbiw	r26, 0x03	; 3
    1204:	81 83       	std	Z+1, r24	; 0x01
    1206:	92 83       	std	Z+2, r25	; 0x02
    1208:	01 80       	ldd	r0, Z+1	; 0x01
    120a:	f2 81       	ldd	r31, Z+2	; 0x02
    120c:	e0 2d       	mov	r30, r0
    120e:	86 81       	ldd	r24, Z+6	; 0x06
    1210:	97 81       	ldd	r25, Z+7	; 0x07
    1212:	80 93 fb 37 	sts	0x37FB, r24
    1216:	90 93 fc 37 	sts	0x37FC, r25
    121a:	08 95       	ret

0000121c <vTaskPlaceOnEventList>:
    121c:	cf 93       	push	r28
    121e:	df 93       	push	r29
    1220:	eb 01       	movw	r28, r22
    1222:	60 91 fb 37 	lds	r22, 0x37FB
    1226:	70 91 fc 37 	lds	r23, 0x37FC
    122a:	64 5f       	subi	r22, 0xF4	; 244
    122c:	7f 4f       	sbci	r23, 0xFF	; 255
    122e:	cc d9       	rcall	.-3176   	; 0x5c8 <vListInsert>
    1230:	80 91 fb 37 	lds	r24, 0x37FB
    1234:	90 91 fc 37 	lds	r25, 0x37FC
    1238:	02 96       	adiw	r24, 0x02	; 2
    123a:	01 da       	rcall	.-3070   	; 0x63e <vListRemove>
    123c:	cf 3f       	cpi	r28, 0xFF	; 255
    123e:	8f ef       	ldi	r24, 0xFF	; 255
    1240:	d8 07       	cpc	r29, r24
    1242:	51 f4       	brne	.+20     	; 0x1258 <vTaskPlaceOnEventList+0x3c>
    1244:	60 91 fb 37 	lds	r22, 0x37FB
    1248:	70 91 fc 37 	lds	r23, 0x37FC
    124c:	6e 5f       	subi	r22, 0xFE	; 254
    124e:	7f 4f       	sbci	r23, 0xFF	; 255
    1250:	8f ea       	ldi	r24, 0xAF	; 175
    1252:	97 e3       	ldi	r25, 0x37	; 55
    1254:	92 d9       	rcall	.-3292   	; 0x57a <vListInsertEnd>
    1256:	07 c0       	rjmp	.+14     	; 0x1266 <vTaskPlaceOnEventList+0x4a>
    1258:	80 91 ac 37 	lds	r24, 0x37AC
    125c:	90 91 ad 37 	lds	r25, 0x37AD
    1260:	8c 0f       	add	r24, r28
    1262:	9d 1f       	adc	r25, r29
    1264:	b4 dc       	rcall	.-1688   	; 0xbce <prvAddCurrentTaskToDelayedList>
    1266:	df 91       	pop	r29
    1268:	cf 91       	pop	r28
    126a:	08 95       	ret

0000126c <vTaskPlaceOnEventListRestricted>:
    126c:	cf 93       	push	r28
    126e:	df 93       	push	r29
    1270:	eb 01       	movw	r28, r22
    1272:	60 91 fb 37 	lds	r22, 0x37FB
    1276:	70 91 fc 37 	lds	r23, 0x37FC
    127a:	64 5f       	subi	r22, 0xF4	; 244
    127c:	7f 4f       	sbci	r23, 0xFF	; 255
    127e:	7d d9       	rcall	.-3334   	; 0x57a <vListInsertEnd>
    1280:	80 91 fb 37 	lds	r24, 0x37FB
    1284:	90 91 fc 37 	lds	r25, 0x37FC
    1288:	02 96       	adiw	r24, 0x02	; 2
    128a:	d9 d9       	rcall	.-3150   	; 0x63e <vListRemove>
    128c:	80 91 ac 37 	lds	r24, 0x37AC
    1290:	90 91 ad 37 	lds	r25, 0x37AD
    1294:	8c 0f       	add	r24, r28
    1296:	9d 1f       	adc	r25, r29
    1298:	9a dc       	rcall	.-1740   	; 0xbce <prvAddCurrentTaskToDelayedList>
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	08 95       	ret

000012a0 <xTaskRemoveFromEventList>:
    12a0:	0f 93       	push	r16
    12a2:	1f 93       	push	r17
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	dc 01       	movw	r26, r24
    12aa:	15 96       	adiw	r26, 0x05	; 5
    12ac:	ed 91       	ld	r30, X+
    12ae:	fc 91       	ld	r31, X
    12b0:	16 97       	sbiw	r26, 0x06	; 6
    12b2:	c6 81       	ldd	r28, Z+6	; 0x06
    12b4:	d7 81       	ldd	r29, Z+7	; 0x07
    12b6:	8e 01       	movw	r16, r28
    12b8:	04 5f       	subi	r16, 0xF4	; 244
    12ba:	1f 4f       	sbci	r17, 0xFF	; 255
    12bc:	c8 01       	movw	r24, r16
    12be:	bf d9       	rcall	.-3202   	; 0x63e <vListRemove>
    12c0:	80 91 a8 37 	lds	r24, 0x37A8
    12c4:	81 11       	cpse	r24, r1
    12c6:	1a c0       	rjmp	.+52     	; 0x12fc <xTaskRemoveFromEventList+0x5c>
    12c8:	0a 50       	subi	r16, 0x0A	; 10
    12ca:	11 09       	sbc	r17, r1
    12cc:	c8 01       	movw	r24, r16
    12ce:	b7 d9       	rcall	.-3218   	; 0x63e <vListRemove>
    12d0:	8e 89       	ldd	r24, Y+22	; 0x16
    12d2:	90 91 aa 37 	lds	r25, 0x37AA
    12d6:	98 17       	cp	r25, r24
    12d8:	10 f4       	brcc	.+4      	; 0x12de <xTaskRemoveFromEventList+0x3e>
    12da:	80 93 aa 37 	sts	0x37AA, r24
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	9c 01       	movw	r18, r24
    12e2:	22 0f       	add	r18, r18
    12e4:	33 1f       	adc	r19, r19
    12e6:	22 0f       	add	r18, r18
    12e8:	33 1f       	adc	r19, r19
    12ea:	22 0f       	add	r18, r18
    12ec:	33 1f       	adc	r19, r19
    12ee:	82 0f       	add	r24, r18
    12f0:	93 1f       	adc	r25, r19
    12f2:	b8 01       	movw	r22, r16
    12f4:	89 52       	subi	r24, 0x29	; 41
    12f6:	98 4c       	sbci	r25, 0xC8	; 200
    12f8:	40 d9       	rcall	.-3456   	; 0x57a <vListInsertEnd>
    12fa:	04 c0       	rjmp	.+8      	; 0x1304 <xTaskRemoveFromEventList+0x64>
    12fc:	b8 01       	movw	r22, r16
    12fe:	88 eb       	ldi	r24, 0xB8	; 184
    1300:	97 e3       	ldi	r25, 0x37	; 55
    1302:	3b d9       	rcall	.-3466   	; 0x57a <vListInsertEnd>
    1304:	e0 91 fb 37 	lds	r30, 0x37FB
    1308:	f0 91 fc 37 	lds	r31, 0x37FC
    130c:	81 e0       	ldi	r24, 0x01	; 1
    130e:	2e 89       	ldd	r18, Y+22	; 0x16
    1310:	96 89       	ldd	r25, Z+22	; 0x16
    1312:	29 17       	cp	r18, r25
    1314:	08 f4       	brcc	.+2      	; 0x1318 <xTaskRemoveFromEventList+0x78>
    1316:	80 e0       	ldi	r24, 0x00	; 0
    1318:	df 91       	pop	r29
    131a:	cf 91       	pop	r28
    131c:	1f 91       	pop	r17
    131e:	0f 91       	pop	r16
    1320:	08 95       	ret

00001322 <vTaskSetTimeOutState>:
    1322:	20 91 a5 37 	lds	r18, 0x37A5
    1326:	fc 01       	movw	r30, r24
    1328:	20 83       	st	Z, r18
    132a:	20 91 ac 37 	lds	r18, 0x37AC
    132e:	30 91 ad 37 	lds	r19, 0x37AD
    1332:	21 83       	std	Z+1, r18	; 0x01
    1334:	32 83       	std	Z+2, r19	; 0x02
    1336:	08 95       	ret

00001338 <xTaskCheckForTimeOut>:
    1338:	0f b6       	in	r0, 0x3f	; 63
    133a:	f8 94       	cli
    133c:	0f 92       	push	r0
    133e:	db 01       	movw	r26, r22
    1340:	2d 91       	ld	r18, X+
    1342:	3c 91       	ld	r19, X
    1344:	2f 3f       	cpi	r18, 0xFF	; 255
    1346:	bf ef       	ldi	r27, 0xFF	; 255
    1348:	3b 07       	cpc	r19, r27
    134a:	61 f1       	breq	.+88     	; 0x13a4 <xTaskCheckForTimeOut+0x6c>
    134c:	40 91 a5 37 	lds	r20, 0x37A5
    1350:	fc 01       	movw	r30, r24
    1352:	50 81       	ld	r21, Z
    1354:	54 17       	cp	r21, r20
    1356:	51 f0       	breq	.+20     	; 0x136c <xTaskCheckForTimeOut+0x34>
    1358:	40 91 ac 37 	lds	r20, 0x37AC
    135c:	50 91 ad 37 	lds	r21, 0x37AD
    1360:	01 80       	ldd	r0, Z+1	; 0x01
    1362:	f2 81       	ldd	r31, Z+2	; 0x02
    1364:	e0 2d       	mov	r30, r0
    1366:	4e 17       	cp	r20, r30
    1368:	5f 07       	cpc	r21, r31
    136a:	f0 f4       	brcc	.+60     	; 0x13a8 <xTaskCheckForTimeOut+0x70>
    136c:	e0 91 ac 37 	lds	r30, 0x37AC
    1370:	f0 91 ad 37 	lds	r31, 0x37AD
    1374:	dc 01       	movw	r26, r24
    1376:	11 96       	adiw	r26, 0x01	; 1
    1378:	4d 91       	ld	r20, X+
    137a:	5c 91       	ld	r21, X
    137c:	12 97       	sbiw	r26, 0x02	; 2
    137e:	e4 1b       	sub	r30, r20
    1380:	f5 0b       	sbc	r31, r21
    1382:	e2 17       	cp	r30, r18
    1384:	f3 07       	cpc	r31, r19
    1386:	90 f4       	brcc	.+36     	; 0x13ac <xTaskCheckForTimeOut+0x74>
    1388:	e0 91 ac 37 	lds	r30, 0x37AC
    138c:	f0 91 ad 37 	lds	r31, 0x37AD
    1390:	4e 1b       	sub	r20, r30
    1392:	5f 0b       	sbc	r21, r31
    1394:	24 0f       	add	r18, r20
    1396:	35 1f       	adc	r19, r21
    1398:	fb 01       	movw	r30, r22
    139a:	20 83       	st	Z, r18
    139c:	31 83       	std	Z+1, r19	; 0x01
    139e:	c1 df       	rcall	.-126    	; 0x1322 <vTaskSetTimeOutState>
    13a0:	80 e0       	ldi	r24, 0x00	; 0
    13a2:	05 c0       	rjmp	.+10     	; 0x13ae <xTaskCheckForTimeOut+0x76>
    13a4:	80 e0       	ldi	r24, 0x00	; 0
    13a6:	03 c0       	rjmp	.+6      	; 0x13ae <xTaskCheckForTimeOut+0x76>
    13a8:	81 e0       	ldi	r24, 0x01	; 1
    13aa:	01 c0       	rjmp	.+2      	; 0x13ae <xTaskCheckForTimeOut+0x76>
    13ac:	81 e0       	ldi	r24, 0x01	; 1
    13ae:	0f 90       	pop	r0
    13b0:	0f be       	out	0x3f, r0	; 63
    13b2:	08 95       	ret

000013b4 <vTaskMissedYield>:
    13b4:	81 e0       	ldi	r24, 0x01	; 1
    13b6:	80 93 a6 37 	sts	0x37A6, r24
    13ba:	08 95       	ret

000013bc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    13bc:	80 91 fb 37 	lds	r24, 0x37FB
    13c0:	90 91 fc 37 	lds	r25, 0x37FC

		return xReturn;
	}
    13c4:	08 95       	ret

000013c6 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
    13c6:	80 91 a9 37 	lds	r24, 0x37A9
    13ca:	88 23       	and	r24, r24
    13cc:	31 f0       	breq	.+12     	; 0x13da <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    13ce:	80 91 a8 37 	lds	r24, 0x37A8
    13d2:	81 11       	cpse	r24, r1
    13d4:	04 c0       	rjmp	.+8      	; 0x13de <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
    13d6:	81 e0       	ldi	r24, 0x01	; 1
    13d8:	08 95       	ret
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    13da:	80 e0       	ldi	r24, 0x00	; 0
    13dc:	08 95       	ret
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    13de:	82 e0       	ldi	r24, 0x02	; 2
			}
		}

		return xReturn;
	}
    13e0:	08 95       	ret

000013e2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    13e2:	0f 93       	push	r16
    13e4:	1f 93       	push	r17
    13e6:	cf 93       	push	r28
    13e8:	df 93       	push	r29
    13ea:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    13ec:	8e 89       	ldd	r24, Y+22	; 0x16
    13ee:	e0 91 fb 37 	lds	r30, 0x37FB
    13f2:	f0 91 fc 37 	lds	r31, 0x37FC
    13f6:	96 89       	ldd	r25, Z+22	; 0x16
    13f8:	89 17       	cp	r24, r25
    13fa:	08 f0       	brcs	.+2      	; 0x13fe <vTaskPriorityInherit+0x1c>
    13fc:	42 c0       	rjmp	.+132    	; 0x1482 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    13fe:	e0 91 fb 37 	lds	r30, 0x37FB
    1402:	f0 91 fc 37 	lds	r31, 0x37FC
    1406:	96 89       	ldd	r25, Z+22	; 0x16
    1408:	24 e0       	ldi	r18, 0x04	; 4
    140a:	30 e0       	ldi	r19, 0x00	; 0
    140c:	29 1b       	sub	r18, r25
    140e:	31 09       	sbc	r19, r1
    1410:	2c 87       	std	Y+12, r18	; 0x0c
    1412:	3d 87       	std	Y+13, r19	; 0x0d

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1414:	90 e0       	ldi	r25, 0x00	; 0
    1416:	9c 01       	movw	r18, r24
    1418:	22 0f       	add	r18, r18
    141a:	33 1f       	adc	r19, r19
    141c:	22 0f       	add	r18, r18
    141e:	33 1f       	adc	r19, r19
    1420:	22 0f       	add	r18, r18
    1422:	33 1f       	adc	r19, r19
    1424:	82 0f       	add	r24, r18
    1426:	93 1f       	adc	r25, r19
    1428:	89 52       	subi	r24, 0x29	; 41
    142a:	98 4c       	sbci	r25, 0xC8	; 200
    142c:	2a 85       	ldd	r18, Y+10	; 0x0a
    142e:	3b 85       	ldd	r19, Y+11	; 0x0b
    1430:	28 17       	cp	r18, r24
    1432:	39 07       	cpc	r19, r25
    1434:	01 f5       	brne	.+64     	; 0x1476 <vTaskPriorityInherit+0x94>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    1436:	8e 01       	movw	r16, r28
    1438:	0e 5f       	subi	r16, 0xFE	; 254
    143a:	1f 4f       	sbci	r17, 0xFF	; 255
    143c:	c8 01       	movw	r24, r16
    143e:	ff d8       	rcall	.-3586   	; 0x63e <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1440:	e0 91 fb 37 	lds	r30, 0x37FB
    1444:	f0 91 fc 37 	lds	r31, 0x37FC
    1448:	86 89       	ldd	r24, Z+22	; 0x16
    144a:	8e 8b       	std	Y+22, r24	; 0x16
				prvAddTaskToReadyQueue( pxTCB );
    144c:	90 91 aa 37 	lds	r25, 0x37AA
    1450:	98 17       	cp	r25, r24
    1452:	10 f4       	brcc	.+4      	; 0x1458 <vTaskPriorityInherit+0x76>
    1454:	80 93 aa 37 	sts	0x37AA, r24
    1458:	90 e0       	ldi	r25, 0x00	; 0
    145a:	9c 01       	movw	r18, r24
    145c:	22 0f       	add	r18, r18
    145e:	33 1f       	adc	r19, r19
    1460:	22 0f       	add	r18, r18
    1462:	33 1f       	adc	r19, r19
    1464:	22 0f       	add	r18, r18
    1466:	33 1f       	adc	r19, r19
    1468:	82 0f       	add	r24, r18
    146a:	93 1f       	adc	r25, r19
    146c:	b8 01       	movw	r22, r16
    146e:	89 52       	subi	r24, 0x29	; 41
    1470:	98 4c       	sbci	r25, 0xC8	; 200
    1472:	83 d8       	rcall	.-3834   	; 0x57a <vListInsertEnd>
    1474:	06 c0       	rjmp	.+12     	; 0x1482 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1476:	e0 91 fb 37 	lds	r30, 0x37FB
    147a:	f0 91 fc 37 	lds	r31, 0x37FC
    147e:	86 89       	ldd	r24, Z+22	; 0x16
    1480:	8e 8b       	std	Y+22, r24	; 0x16
			}
		}
	}
    1482:	df 91       	pop	r29
    1484:	cf 91       	pop	r28
    1486:	1f 91       	pop	r17
    1488:	0f 91       	pop	r16
    148a:	08 95       	ret

0000148c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    148c:	0f 93       	push	r16
    148e:	1f 93       	push	r17
    1490:	cf 93       	push	r28
    1492:	df 93       	push	r29
    1494:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    1496:	00 97       	sbiw	r24, 0x00	; 0
    1498:	29 f1       	breq	.+74     	; 0x14e4 <vTaskPriorityDisinherit+0x58>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    149a:	9e 89       	ldd	r25, Y+22	; 0x16
    149c:	89 a1       	ldd	r24, Y+33	; 0x21
    149e:	98 17       	cp	r25, r24
    14a0:	09 f1       	breq	.+66     	; 0x14e4 <vTaskPriorityDisinherit+0x58>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    14a2:	8e 01       	movw	r16, r28
    14a4:	0e 5f       	subi	r16, 0xFE	; 254
    14a6:	1f 4f       	sbci	r17, 0xFF	; 255
    14a8:	c8 01       	movw	r24, r16
    14aa:	c9 d8       	rcall	.-3694   	; 0x63e <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    14ac:	89 a1       	ldd	r24, Y+33	; 0x21
    14ae:	8e 8b       	std	Y+22, r24	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    14b0:	24 e0       	ldi	r18, 0x04	; 4
    14b2:	30 e0       	ldi	r19, 0x00	; 0
    14b4:	28 1b       	sub	r18, r24
    14b6:	31 09       	sbc	r19, r1
    14b8:	2c 87       	std	Y+12, r18	; 0x0c
    14ba:	3d 87       	std	Y+13, r19	; 0x0d
				prvAddTaskToReadyQueue( pxTCB );
    14bc:	90 91 aa 37 	lds	r25, 0x37AA
    14c0:	98 17       	cp	r25, r24
    14c2:	10 f4       	brcc	.+4      	; 0x14c8 <vTaskPriorityDisinherit+0x3c>
    14c4:	80 93 aa 37 	sts	0x37AA, r24
    14c8:	90 e0       	ldi	r25, 0x00	; 0
    14ca:	9c 01       	movw	r18, r24
    14cc:	22 0f       	add	r18, r18
    14ce:	33 1f       	adc	r19, r19
    14d0:	22 0f       	add	r18, r18
    14d2:	33 1f       	adc	r19, r19
    14d4:	22 0f       	add	r18, r18
    14d6:	33 1f       	adc	r19, r19
    14d8:	82 0f       	add	r24, r18
    14da:	93 1f       	adc	r25, r19
    14dc:	b8 01       	movw	r22, r16
    14de:	89 52       	subi	r24, 0x29	; 41
    14e0:	98 4c       	sbci	r25, 0xC8	; 200
    14e2:	4b d8       	rcall	.-3946   	; 0x57a <vListInsertEnd>
			}
		}
	}
    14e4:	df 91       	pop	r29
    14e6:	cf 91       	pop	r28
    14e8:	1f 91       	pop	r17
    14ea:	0f 91       	pop	r16
    14ec:	08 95       	ret

000014ee <prvInsertTimerInActiveList>:
			traceTIMER_CREATE_FAILED();
		}
	}
	
	return ( xTimerHandle ) pxNewTimer;
}
    14ee:	fc 01       	movw	r30, r24
    14f0:	62 83       	std	Z+2, r22	; 0x02
    14f2:	73 83       	std	Z+3, r23	; 0x03
    14f4:	80 87       	std	Z+8, r24	; 0x08
    14f6:	91 87       	std	Z+9, r25	; 0x09
    14f8:	46 17       	cp	r20, r22
    14fa:	57 07       	cpc	r21, r23
    14fc:	88 f0       	brcs	.+34     	; 0x1520 <prvInsertTimerInActiveList+0x32>
    14fe:	42 1b       	sub	r20, r18
    1500:	53 0b       	sbc	r21, r19
    1502:	84 85       	ldd	r24, Z+12	; 0x0c
    1504:	95 85       	ldd	r25, Z+13	; 0x0d
    1506:	48 17       	cp	r20, r24
    1508:	59 07       	cpc	r21, r25
    150a:	d0 f4       	brcc	.+52     	; 0x1540 <prvInsertTimerInActiveList+0x52>
    150c:	bf 01       	movw	r22, r30
    150e:	6e 5f       	subi	r22, 0xFE	; 254
    1510:	7f 4f       	sbci	r23, 0xFF	; 255
    1512:	80 91 01 38 	lds	r24, 0x3801
    1516:	90 91 02 38 	lds	r25, 0x3802
    151a:	56 d8       	rcall	.-3924   	; 0x5c8 <vListInsert>
    151c:	80 e0       	ldi	r24, 0x00	; 0
    151e:	08 95       	ret
    1520:	42 17       	cp	r20, r18
    1522:	53 07       	cpc	r21, r19
    1524:	18 f4       	brcc	.+6      	; 0x152c <prvInsertTimerInActiveList+0x3e>
    1526:	62 17       	cp	r22, r18
    1528:	73 07       	cpc	r23, r19
    152a:	60 f4       	brcc	.+24     	; 0x1544 <prvInsertTimerInActiveList+0x56>
    152c:	bf 01       	movw	r22, r30
    152e:	6e 5f       	subi	r22, 0xFE	; 254
    1530:	7f 4f       	sbci	r23, 0xFF	; 255
    1532:	80 91 03 38 	lds	r24, 0x3803
    1536:	90 91 04 38 	lds	r25, 0x3804
    153a:	46 d8       	rcall	.-3956   	; 0x5c8 <vListInsert>
    153c:	80 e0       	ldi	r24, 0x00	; 0
    153e:	08 95       	ret
    1540:	81 e0       	ldi	r24, 0x01	; 1
    1542:	08 95       	ret
    1544:	81 e0       	ldi	r24, 0x01	; 1
    1546:	08 95       	ret

00001548 <prvCheckForValidListAndQueue>:
    1548:	0f b6       	in	r0, 0x3f	; 63
    154a:	f8 94       	cli
    154c:	0f 92       	push	r0
    154e:	80 91 ff 37 	lds	r24, 0x37FF
    1552:	90 91 00 38 	lds	r25, 0x3800
    1556:	89 2b       	or	r24, r25
    1558:	d9 f4       	brne	.+54     	; 0x1590 <prvCheckForValidListAndQueue+0x48>
    155a:	8e e0       	ldi	r24, 0x0E	; 14
    155c:	98 e3       	ldi	r25, 0x38	; 56
    155e:	0e 94 ab 02 	call	0x556	; 0x556 <vListInitialise>
    1562:	85 e0       	ldi	r24, 0x05	; 5
    1564:	98 e3       	ldi	r25, 0x38	; 56
    1566:	0e 94 ab 02 	call	0x556	; 0x556 <vListInitialise>
    156a:	8e e0       	ldi	r24, 0x0E	; 14
    156c:	98 e3       	ldi	r25, 0x38	; 56
    156e:	80 93 03 38 	sts	0x3803, r24
    1572:	90 93 04 38 	sts	0x3804, r25
    1576:	85 e0       	ldi	r24, 0x05	; 5
    1578:	98 e3       	ldi	r25, 0x38	; 56
    157a:	80 93 01 38 	sts	0x3801, r24
    157e:	90 93 02 38 	sts	0x3802, r25
    1582:	65 e0       	ldi	r22, 0x05	; 5
    1584:	80 e1       	ldi	r24, 0x10	; 16
    1586:	2a d9       	rcall	.-3500   	; 0x7dc <xQueueCreate>
    1588:	80 93 ff 37 	sts	0x37FF, r24
    158c:	90 93 00 38 	sts	0x3800, r25
    1590:	0f 90       	pop	r0
    1592:	0f be       	out	0x3f, r0	; 63
    1594:	08 95       	ret

00001596 <xTimerCreateTimerTask>:
    1596:	af 92       	push	r10
    1598:	bf 92       	push	r11
    159a:	cf 92       	push	r12
    159c:	df 92       	push	r13
    159e:	ef 92       	push	r14
    15a0:	ff 92       	push	r15
    15a2:	0f 93       	push	r16
    15a4:	d1 df       	rcall	.-94     	; 0x1548 <prvCheckForValidListAndQueue>
    15a6:	80 91 ff 37 	lds	r24, 0x37FF
    15aa:	90 91 00 38 	lds	r25, 0x3800
    15ae:	89 2b       	or	r24, r25
    15b0:	89 f0       	breq	.+34     	; 0x15d4 <xTimerCreateTimerTask+0x3e>
    15b2:	a1 2c       	mov	r10, r1
    15b4:	b1 2c       	mov	r11, r1
    15b6:	c1 2c       	mov	r12, r1
    15b8:	d1 2c       	mov	r13, r1
    15ba:	e1 2c       	mov	r14, r1
    15bc:	f1 2c       	mov	r15, r1
    15be:	01 e0       	ldi	r16, 0x01	; 1
    15c0:	20 e0       	ldi	r18, 0x00	; 0
    15c2:	30 e0       	ldi	r19, 0x00	; 0
    15c4:	46 e9       	ldi	r20, 0x96	; 150
    15c6:	50 e0       	ldi	r21, 0x00	; 0
    15c8:	67 e0       	ldi	r22, 0x07	; 7
    15ca:	70 e2       	ldi	r23, 0x20	; 32
    15cc:	85 ea       	ldi	r24, 0xA5	; 165
    15ce:	9b e0       	ldi	r25, 0x0B	; 11
    15d0:	33 db       	rcall	.-2458   	; 0xc38 <xTaskGenericCreate>
    15d2:	01 c0       	rjmp	.+2      	; 0x15d6 <xTimerCreateTimerTask+0x40>
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	0f 91       	pop	r16
    15d8:	ff 90       	pop	r15
    15da:	ef 90       	pop	r14
    15dc:	df 90       	pop	r13
    15de:	cf 90       	pop	r12
    15e0:	bf 90       	pop	r11
    15e2:	af 90       	pop	r10
    15e4:	08 95       	ret

000015e6 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
    15e6:	0f 93       	push	r16
    15e8:	1f 93       	push	r17
    15ea:	cf 93       	push	r28
    15ec:	df 93       	push	r29
    15ee:	cd b7       	in	r28, 0x3d	; 61
    15f0:	de b7       	in	r29, 0x3e	; 62
    15f2:	25 97       	sbiw	r28, 0x05	; 5
    15f4:	cd bf       	out	0x3d, r28	; 61
    15f6:	de bf       	out	0x3e, r29	; 62
    15f8:	d9 01       	movw	r26, r18
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    15fa:	e0 91 ff 37 	lds	r30, 0x37FF
    15fe:	f0 91 00 38 	lds	r31, 0x3800
    1602:	30 97       	sbiw	r30, 0x00	; 0
    1604:	49 f1       	breq	.+82     	; 0x1658 <xTimerGenericCommand+0x72>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    1606:	69 83       	std	Y+1, r22	; 0x01
		xMessage.xMessageValue = xOptionalValue;
    1608:	4a 83       	std	Y+2, r20	; 0x02
    160a:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.pxTimer = ( xTIMER * ) xTimer;
    160c:	8c 83       	std	Y+4, r24	; 0x04
    160e:	9d 83       	std	Y+5, r25	; 0x05

		if( pxHigherPriorityTaskWoken == NULL )
    1610:	10 97       	sbiw	r26, 0x00	; 0
    1612:	d1 f4       	brne	.+52     	; 0x1648 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1614:	d8 de       	rcall	.-592    	; 0x13c6 <xTaskGetSchedulerState>
    1616:	81 30       	cpi	r24, 0x01	; 1
    1618:	59 f4       	brne	.+22     	; 0x1630 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
    161a:	20 e0       	ldi	r18, 0x00	; 0
    161c:	a8 01       	movw	r20, r16
    161e:	be 01       	movw	r22, r28
    1620:	6f 5f       	subi	r22, 0xFF	; 255
    1622:	7f 4f       	sbci	r23, 0xFF	; 255
    1624:	80 91 ff 37 	lds	r24, 0x37FF
    1628:	90 91 00 38 	lds	r25, 0x3800
    162c:	23 d9       	rcall	.-3514   	; 0x874 <xQueueGenericSend>
    162e:	15 c0       	rjmp	.+42     	; 0x165a <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1630:	20 e0       	ldi	r18, 0x00	; 0
    1632:	40 e0       	ldi	r20, 0x00	; 0
    1634:	50 e0       	ldi	r21, 0x00	; 0
    1636:	be 01       	movw	r22, r28
    1638:	6f 5f       	subi	r22, 0xFF	; 255
    163a:	7f 4f       	sbci	r23, 0xFF	; 255
    163c:	80 91 ff 37 	lds	r24, 0x37FF
    1640:	90 91 00 38 	lds	r25, 0x3800
    1644:	17 d9       	rcall	.-3538   	; 0x874 <xQueueGenericSend>
    1646:	09 c0       	rjmp	.+18     	; 0x165a <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1648:	20 e0       	ldi	r18, 0x00	; 0
    164a:	ad 01       	movw	r20, r26
    164c:	be 01       	movw	r22, r28
    164e:	6f 5f       	subi	r22, 0xFF	; 255
    1650:	7f 4f       	sbci	r23, 0xFF	; 255
    1652:	cf 01       	movw	r24, r30
    1654:	97 d9       	rcall	.-3282   	; 0x984 <xQueueGenericSendFromISR>
    1656:	01 c0       	rjmp	.+2      	; 0x165a <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
portBASE_TYPE xReturn = pdFAIL;
    1658:	80 e0       	ldi	r24, 0x00	; 0
		
		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}
	
	return xReturn;
}
    165a:	25 96       	adiw	r28, 0x05	; 5
    165c:	cd bf       	out	0x3d, r28	; 61
    165e:	de bf       	out	0x3e, r29	; 62
    1660:	df 91       	pop	r29
    1662:	cf 91       	pop	r28
    1664:	1f 91       	pop	r17
    1666:	0f 91       	pop	r16
    1668:	08 95       	ret

0000166a <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
    166a:	af 92       	push	r10
    166c:	bf 92       	push	r11
    166e:	cf 92       	push	r12
    1670:	df 92       	push	r13
    1672:	ef 92       	push	r14
    1674:	ff 92       	push	r15
    1676:	0f 93       	push	r16
    1678:	1f 93       	push	r17
    167a:	cf 93       	push	r28
    167c:	df 93       	push	r29
    167e:	5c 01       	movw	r10, r24
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
    1680:	02 dc       	rcall	.-2044   	; 0xe86 <xTaskGetTickCount>
    1682:	6c 01       	movw	r12, r24
	
	if( xTimeNow < xLastTime )
    1684:	80 91 fd 37 	lds	r24, 0x37FD
    1688:	90 91 fe 37 	lds	r25, 0x37FE
    168c:	c8 16       	cp	r12, r24
    168e:	d9 06       	cpc	r13, r25
    1690:	08 f0       	brcs	.+2      	; 0x1694 <prvSampleTimeNow+0x2a>
    1692:	49 c0       	rjmp	.+146    	; 0x1726 <prvSampleTimeNow+0xbc>
    1694:	31 c0       	rjmp	.+98     	; 0x16f8 <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1696:	a5 81       	ldd	r26, Z+5	; 0x05
    1698:	b6 81       	ldd	r27, Z+6	; 0x06
    169a:	ed 90       	ld	r14, X+
    169c:	fc 90       	ld	r15, X

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    169e:	05 80       	ldd	r0, Z+5	; 0x05
    16a0:	f6 81       	ldd	r31, Z+6	; 0x06
    16a2:	e0 2d       	mov	r30, r0
    16a4:	c6 81       	ldd	r28, Z+6	; 0x06
    16a6:	d7 81       	ldd	r29, Z+7	; 0x07
		vListRemove( &( pxTimer->xTimerListItem ) );
    16a8:	8e 01       	movw	r16, r28
    16aa:	0e 5f       	subi	r16, 0xFE	; 254
    16ac:	1f 4f       	sbci	r17, 0xFF	; 255
    16ae:	c8 01       	movw	r24, r16
    16b0:	0e 94 1f 03 	call	0x63e	; 0x63e <vListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    16b4:	e9 89       	ldd	r30, Y+17	; 0x11
    16b6:	fa 89       	ldd	r31, Y+18	; 0x12
    16b8:	ce 01       	movw	r24, r28
    16ba:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    16bc:	8e 85       	ldd	r24, Y+14	; 0x0e
    16be:	81 30       	cpi	r24, 0x01	; 1
    16c0:	d9 f4       	brne	.+54     	; 0x16f8 <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    16c2:	8c 85       	ldd	r24, Y+12	; 0x0c
    16c4:	9d 85       	ldd	r25, Y+13	; 0x0d
    16c6:	8e 0d       	add	r24, r14
    16c8:	9f 1d       	adc	r25, r15
			if( xReloadTime > xNextExpireTime )
    16ca:	e8 16       	cp	r14, r24
    16cc:	f9 06       	cpc	r15, r25
    16ce:	60 f4       	brcc	.+24     	; 0x16e8 <prvSampleTimeNow+0x7e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    16d0:	8a 83       	std	Y+2, r24	; 0x02
    16d2:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    16d4:	c8 87       	std	Y+8, r28	; 0x08
    16d6:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    16d8:	b8 01       	movw	r22, r16
    16da:	80 91 03 38 	lds	r24, 0x3803
    16de:	90 91 04 38 	lds	r25, 0x3804
    16e2:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <vListInsert>
    16e6:	08 c0       	rjmp	.+16     	; 0x16f8 <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    16e8:	00 e0       	ldi	r16, 0x00	; 0
    16ea:	10 e0       	ldi	r17, 0x00	; 0
    16ec:	20 e0       	ldi	r18, 0x00	; 0
    16ee:	30 e0       	ldi	r19, 0x00	; 0
    16f0:	a7 01       	movw	r20, r14
    16f2:	60 e0       	ldi	r22, 0x00	; 0
    16f4:	ce 01       	movw	r24, r28
    16f6:	77 df       	rcall	.-274    	; 0x15e6 <xTimerGenericCommand>
	
	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    16f8:	e0 91 03 38 	lds	r30, 0x3803
    16fc:	f0 91 04 38 	lds	r31, 0x3804
    1700:	80 81       	ld	r24, Z
    1702:	81 11       	cpse	r24, r1
    1704:	c8 cf       	rjmp	.-112    	; 0x1696 <prvSampleTimeNow+0x2c>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    1706:	80 91 01 38 	lds	r24, 0x3801
    170a:	90 91 02 38 	lds	r25, 0x3802
    170e:	80 93 03 38 	sts	0x3803, r24
    1712:	90 93 04 38 	sts	0x3804, r25
	pxOverflowTimerList = pxTemp;
    1716:	e0 93 01 38 	sts	0x3801, r30
    171a:	f0 93 02 38 	sts	0x3802, r31
	xTimeNow = xTaskGetTickCount();
	
	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists( xLastTime );
		*pxTimerListsWereSwitched = pdTRUE;
    171e:	81 e0       	ldi	r24, 0x01	; 1
    1720:	f5 01       	movw	r30, r10
    1722:	80 83       	st	Z, r24
    1724:	02 c0       	rjmp	.+4      	; 0x172a <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    1726:	f5 01       	movw	r30, r10
    1728:	10 82       	st	Z, r1
	}
	
	xLastTime = xTimeNow;
    172a:	c0 92 fd 37 	sts	0x37FD, r12
    172e:	d0 92 fe 37 	sts	0x37FE, r13
	
	return xTimeNow;
}
    1732:	c6 01       	movw	r24, r12
    1734:	df 91       	pop	r29
    1736:	cf 91       	pop	r28
    1738:	1f 91       	pop	r17
    173a:	0f 91       	pop	r16
    173c:	ff 90       	pop	r15
    173e:	ef 90       	pop	r14
    1740:	df 90       	pop	r13
    1742:	cf 90       	pop	r12
    1744:	bf 90       	pop	r11
    1746:	af 90       	pop	r10
    1748:	08 95       	ret

0000174a <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    174a:	cf 93       	push	r28
    174c:	df 93       	push	r29
    174e:	00 d0       	rcall	.+0      	; 0x1750 <prvTimerTask+0x6>
    1750:	00 d0       	rcall	.+0      	; 0x1752 <prvTimerTask+0x8>
    1752:	cd b7       	in	r28, 0x3d	; 61
    1754:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1756:	ce 01       	movw	r24, r28
    1758:	01 96       	adiw	r24, 0x01	; 1
    175a:	5c 01       	movw	r10, r24

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    175c:	88 2e       	mov	r8, r24
    175e:	9b 2c       	mov	r9, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1760:	e0 91 03 38 	lds	r30, 0x3803
    1764:	f0 91 04 38 	lds	r31, 0x3804
    1768:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    176a:	88 23       	and	r24, r24
    176c:	09 f4       	brne	.+2      	; 0x1770 <prvTimerTask+0x26>
    176e:	b0 c0       	rjmp	.+352    	; 0x18d0 <prvTimerTask+0x186>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1770:	05 80       	ldd	r0, Z+5	; 0x05
    1772:	f6 81       	ldd	r31, Z+6	; 0x06
    1774:	e0 2d       	mov	r30, r0
    1776:	e0 80       	ld	r14, Z
    1778:	f1 80       	ldd	r15, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    177a:	7f db       	rcall	.-2306   	; 0xe7a <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    177c:	c5 01       	movw	r24, r10
    177e:	75 df       	rcall	.-278    	; 0x166a <prvSampleTimeNow>
    1780:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    1782:	89 81       	ldd	r24, Y+1	; 0x01
    1784:	81 11       	cpse	r24, r1
    1786:	43 c0       	rjmp	.+134    	; 0x180e <prvTimerTask+0xc4>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1788:	0e 15       	cp	r16, r14
    178a:	1f 05       	cpc	r17, r15
    178c:	90 f1       	brcs	.+100    	; 0x17f2 <prvTimerTask+0xa8>
			{
				xTaskResumeAll();
    178e:	46 dc       	rcall	.-1908   	; 0x101c <xTaskResumeAll>
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    1790:	e0 91 03 38 	lds	r30, 0x3803
    1794:	f0 91 04 38 	lds	r31, 0x3804
    1798:	05 80       	ldd	r0, Z+5	; 0x05
    179a:	f6 81       	ldd	r31, Z+6	; 0x06
    179c:	e0 2d       	mov	r30, r0
    179e:	c6 80       	ldd	r12, Z+6	; 0x06
    17a0:	d7 80       	ldd	r13, Z+7	; 0x07
	vListRemove( &( pxTimer->xTimerListItem ) );
    17a2:	c6 01       	movw	r24, r12
    17a4:	02 96       	adiw	r24, 0x02	; 2
    17a6:	0e 94 1f 03 	call	0x63e	; 0x63e <vListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    17aa:	d6 01       	movw	r26, r12
    17ac:	1e 96       	adiw	r26, 0x0e	; 14
    17ae:	8c 91       	ld	r24, X
    17b0:	1e 97       	sbiw	r26, 0x0e	; 14
    17b2:	81 30       	cpi	r24, 0x01	; 1
    17b4:	a1 f4       	brne	.+40     	; 0x17de <prvTimerTask+0x94>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    17b6:	1c 96       	adiw	r26, 0x0c	; 12
    17b8:	6d 91       	ld	r22, X+
    17ba:	7c 91       	ld	r23, X
    17bc:	1d 97       	sbiw	r26, 0x0d	; 13
    17be:	6e 0d       	add	r22, r14
    17c0:	7f 1d       	adc	r23, r15
    17c2:	97 01       	movw	r18, r14
    17c4:	a8 01       	movw	r20, r16
    17c6:	c6 01       	movw	r24, r12
    17c8:	92 de       	rcall	.-732    	; 0x14ee <prvInsertTimerInActiveList>
    17ca:	81 30       	cpi	r24, 0x01	; 1
    17cc:	41 f4       	brne	.+16     	; 0x17de <prvTimerTask+0x94>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    17ce:	00 e0       	ldi	r16, 0x00	; 0
    17d0:	10 e0       	ldi	r17, 0x00	; 0
    17d2:	20 e0       	ldi	r18, 0x00	; 0
    17d4:	30 e0       	ldi	r19, 0x00	; 0
    17d6:	a7 01       	movw	r20, r14
    17d8:	60 e0       	ldi	r22, 0x00	; 0
    17da:	c6 01       	movw	r24, r12
    17dc:	04 df       	rcall	.-504    	; 0x15e6 <xTimerGenericCommand>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    17de:	d6 01       	movw	r26, r12
    17e0:	51 96       	adiw	r26, 0x11	; 17
    17e2:	ed 91       	ld	r30, X+
    17e4:	fc 91       	ld	r31, X
    17e6:	52 97       	sbiw	r26, 0x12	; 18
    17e8:	c6 01       	movw	r24, r12
    17ea:	19 95       	eicall
    17ec:	11 c0       	rjmp	.+34     	; 0x1810 <prvTimerTask+0xc6>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
    17ee:	e1 2c       	mov	r14, r1
    17f0:	f1 2c       	mov	r15, r1
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    17f2:	b7 01       	movw	r22, r14
    17f4:	60 1b       	sub	r22, r16
    17f6:	71 0b       	sbc	r23, r17
    17f8:	80 91 ff 37 	lds	r24, 0x37FF
    17fc:	90 91 00 38 	lds	r25, 0x3800
    1800:	c4 d9       	rcall	.-3192   	; 0xb8a <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    1802:	0c dc       	rcall	.-2024   	; 0x101c <xTaskResumeAll>
    1804:	81 11       	cpse	r24, r1
    1806:	04 c0       	rjmp	.+8      	; 0x1810 <prvTimerTask+0xc6>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
    1808:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vPortYield>
    180c:	01 c0       	rjmp	.+2      	; 0x1810 <prvTimerTask+0xc6>
				}
			}
		}
		else
		{
			xTaskResumeAll();
    180e:	06 dc       	rcall	.-2036   	; 0x101c <xTaskResumeAll>
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1810:	ce 01       	movw	r24, r28
    1812:	06 96       	adiw	r24, 0x06	; 6
    1814:	2a df       	rcall	.-428    	; 0x166a <prvSampleTimeNow>
    1816:	6c 01       	movw	r12, r24
    1818:	4e c0       	rjmp	.+156    	; 0x18b6 <prvTimerTask+0x16c>

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
    181a:	ec 80       	ldd	r14, Y+4	; 0x04
    181c:	fd 80       	ldd	r15, Y+5	; 0x05

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
    181e:	e1 14       	cp	r14, r1
    1820:	f1 04       	cpc	r15, r1
    1822:	59 f0       	breq	.+22     	; 0x183a <prvTimerTask+0xf0>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    1824:	d7 01       	movw	r26, r14
    1826:	1a 96       	adiw	r26, 0x0a	; 10
    1828:	ed 91       	ld	r30, X+
    182a:	fc 91       	ld	r31, X
    182c:	1b 97       	sbiw	r26, 0x0b	; 11
    182e:	ef 2b       	or	r30, r31
    1830:	21 f0       	breq	.+8      	; 0x183a <prvTimerTask+0xf0>
			{
				/* The timer is in a list, remove it. */
				vListRemove( &( pxTimer->xTimerListItem ) );
    1832:	c7 01       	movw	r24, r14
    1834:	02 96       	adiw	r24, 0x02	; 2
    1836:	0e 94 1f 03 	call	0x63e	; 0x63e <vListRemove>
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
		
		switch( xMessage.xMessageID )
    183a:	89 81       	ldd	r24, Y+1	; 0x01
    183c:	82 30       	cpi	r24, 0x02	; 2
    183e:	49 f1       	breq	.+82     	; 0x1892 <prvTimerTask+0x148>
    1840:	83 30       	cpi	r24, 0x03	; 3
    1842:	b1 f1       	breq	.+108    	; 0x18b0 <prvTimerTask+0x166>
    1844:	81 11       	cpse	r24, r1
    1846:	37 c0       	rjmp	.+110    	; 0x18b6 <prvTimerTask+0x16c>
		{
			case tmrCOMMAND_START :	
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
    1848:	2a 81       	ldd	r18, Y+2	; 0x02
    184a:	3b 81       	ldd	r19, Y+3	; 0x03
    184c:	f7 01       	movw	r30, r14
    184e:	64 85       	ldd	r22, Z+12	; 0x0c
    1850:	75 85       	ldd	r23, Z+13	; 0x0d
    1852:	62 0f       	add	r22, r18
    1854:	73 1f       	adc	r23, r19
    1856:	a6 01       	movw	r20, r12
    1858:	c7 01       	movw	r24, r14
    185a:	49 de       	rcall	.-878    	; 0x14ee <prvInsertTimerInActiveList>
    185c:	81 30       	cpi	r24, 0x01	; 1
    185e:	59 f5       	brne	.+86     	; 0x18b6 <prvTimerTask+0x16c>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    1860:	d7 01       	movw	r26, r14
    1862:	51 96       	adiw	r26, 0x11	; 17
    1864:	ed 91       	ld	r30, X+
    1866:	fc 91       	ld	r31, X
    1868:	52 97       	sbiw	r26, 0x12	; 18
    186a:	c7 01       	movw	r24, r14
    186c:	19 95       	eicall

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    186e:	f7 01       	movw	r30, r14
    1870:	86 85       	ldd	r24, Z+14	; 0x0e
    1872:	81 30       	cpi	r24, 0x01	; 1
    1874:	01 f5       	brne	.+64     	; 0x18b6 <prvTimerTask+0x16c>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1876:	44 85       	ldd	r20, Z+12	; 0x0c
    1878:	55 85       	ldd	r21, Z+13	; 0x0d
    187a:	8a 81       	ldd	r24, Y+2	; 0x02
    187c:	9b 81       	ldd	r25, Y+3	; 0x03
    187e:	48 0f       	add	r20, r24
    1880:	59 1f       	adc	r21, r25
    1882:	00 e0       	ldi	r16, 0x00	; 0
    1884:	10 e0       	ldi	r17, 0x00	; 0
    1886:	20 e0       	ldi	r18, 0x00	; 0
    1888:	30 e0       	ldi	r19, 0x00	; 0
    188a:	60 e0       	ldi	r22, 0x00	; 0
    188c:	c7 01       	movw	r24, r14
    188e:	ab de       	rcall	.-682    	; 0x15e6 <xTimerGenericCommand>
    1890:	12 c0       	rjmp	.+36     	; 0x18b6 <prvTimerTask+0x16c>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
    1892:	2a 81       	ldd	r18, Y+2	; 0x02
    1894:	3b 81       	ldd	r19, Y+3	; 0x03
    1896:	d7 01       	movw	r26, r14
    1898:	1c 96       	adiw	r26, 0x0c	; 12
    189a:	2d 93       	st	X+, r18
    189c:	3c 93       	st	X, r19
    189e:	1d 97       	sbiw	r26, 0x0d	; 13
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    18a0:	b6 01       	movw	r22, r12
    18a2:	62 0f       	add	r22, r18
    18a4:	73 1f       	adc	r23, r19
    18a6:	96 01       	movw	r18, r12
    18a8:	a6 01       	movw	r20, r12
    18aa:	c7 01       	movw	r24, r14
    18ac:	20 de       	rcall	.-960    	; 0x14ee <prvInsertTimerInActiveList>
    18ae:	03 c0       	rjmp	.+6      	; 0x18b6 <prvTimerTask+0x16c>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
    18b0:	c7 01       	movw	r24, r14
    18b2:	0e 94 49 01 	call	0x292	; 0x292 <vPortFree>

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    18b6:	20 e0       	ldi	r18, 0x00	; 0
    18b8:	40 e0       	ldi	r20, 0x00	; 0
    18ba:	50 e0       	ldi	r21, 0x00	; 0
    18bc:	68 2d       	mov	r22, r8
    18be:	79 2d       	mov	r23, r9
    18c0:	80 91 ff 37 	lds	r24, 0x37FF
    18c4:	90 91 00 38 	lds	r25, 0x3800
    18c8:	87 d8       	rcall	.-3826   	; 0x9d8 <xQueueGenericReceive>
    18ca:	81 11       	cpse	r24, r1
    18cc:	a6 cf       	rjmp	.-180    	; 0x181a <prvTimerTask+0xd0>
    18ce:	48 cf       	rjmp	.-368    	; 0x1760 <prvTimerTask+0x16>
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    18d0:	d4 da       	rcall	.-2648   	; 0xe7a <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    18d2:	c5 01       	movw	r24, r10
    18d4:	ca de       	rcall	.-620    	; 0x166a <prvSampleTimeNow>
    18d6:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    18d8:	89 81       	ldd	r24, Y+1	; 0x01
    18da:	88 23       	and	r24, r24
    18dc:	09 f4       	brne	.+2      	; 0x18e0 <prvTimerTask+0x196>
    18de:	87 cf       	rjmp	.-242    	; 0x17ee <prvTimerTask+0xa4>
    18e0:	96 cf       	rjmp	.-212    	; 0x180e <prvTimerTask+0xc4>

000018e2 <blink1>:

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	base->OUTTGL = arch_ioport_pin_to_mask(pin);
    18e2:	c0 e0       	ldi	r28, 0x00	; 0
    18e4:	d6 e0       	ldi	r29, 0x06	; 6
    18e6:	10 e1       	ldi	r17, 0x10	; 16
    18e8:	1f 83       	std	Y+7, r17	; 0x07
void blink1(void *p) {
	
	while (1) {
		
		ioport_toggle_pin_level(RED);
        vTaskDelay(1000);
    18ea:	88 ee       	ldi	r24, 0xE8	; 232
    18ec:	93 e0       	ldi	r25, 0x03	; 3
    18ee:	1e dc       	rcall	.-1988   	; 0x112c <vTaskDelay>
    18f0:	fb cf       	rjmp	.-10     	; 0x18e8 <blink1+0x6>

000018f2 <blink2>:
    18f2:	c0 e0       	ldi	r28, 0x00	; 0
    18f4:	d6 e0       	ldi	r29, 0x06	; 6
    18f6:	11 e0       	ldi	r17, 0x01	; 1
    18f8:	1f 83       	std	Y+7, r17	; 0x07
void blink2(void *p) {
	
	while (1) {
		
		ioport_toggle_pin_level(YELLOW);
		vTaskDelay(100);
    18fa:	84 e6       	ldi	r24, 0x64	; 100
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	16 dc       	rcall	.-2004   	; 0x112c <vTaskDelay>
    1900:	fb cf       	rjmp	.-10     	; 0x18f8 <blink2+0x6>

00001902 <uartLoopBack>:
	}
}

void uartLoopBack(void *p) {
    1902:	cf 93       	push	r28
    1904:	df 93       	push	r29
    1906:	1f 92       	push	r1
    1908:	cd b7       	in	r28, 0x3d	; 61
    190a:	de b7       	in	r29, 0x3e	; 62
	
	unsigned char znak;
	
	UsartBuffer * pc_usart_buffer = usartBufferInitialize(&PC_USART, BAUD19200, 128);
    190c:	40 e8       	ldi	r20, 0x80	; 128
    190e:	62 e0       	ldi	r22, 0x02	; 2
    1910:	80 ea       	ldi	r24, 0xA0	; 160
    1912:	98 e0       	ldi	r25, 0x08	; 8
    1914:	b6 d2       	rcall	.+1388   	; 0x1e82 <usartBufferInitialize>
    1916:	8c 01       	movw	r16, r24
	usartBufferPutString(pc_usart_buffer, "\n\n\rXMEGA ready", 10);
    1918:	4a e0       	ldi	r20, 0x0A	; 10
    191a:	50 e0       	ldi	r21, 0x00	; 0
    191c:	6f e0       	ldi	r22, 0x0F	; 15
    191e:	70 e2       	ldi	r23, 0x20	; 32
    1920:	94 d3       	rcall	.+1832   	; 0x204a <usartBufferPutString>
	
	while (1) {
		
		if (usartBufferGetByte(pc_usart_buffer, &znak, 0)) {
    1922:	40 e0       	ldi	r20, 0x00	; 0
    1924:	50 e0       	ldi	r21, 0x00	; 0
    1926:	be 01       	movw	r22, r28
    1928:	6f 5f       	subi	r22, 0xFF	; 255
    192a:	7f 4f       	sbci	r23, 0xFF	; 255
    192c:	c8 01       	movw	r24, r16
    192e:	86 d3       	rcall	.+1804   	; 0x203c <usartBufferGetByte>
    1930:	88 23       	and	r24, r24
    1932:	b9 f3       	breq	.-18     	; 0x1922 <uartLoopBack+0x20>
			
			usartBufferPutByte(pc_usart_buffer, znak, 10);
    1934:	4a e0       	ldi	r20, 0x0A	; 10
    1936:	50 e0       	ldi	r21, 0x00	; 0
    1938:	69 81       	ldd	r22, Y+1	; 0x01
    193a:	c8 01       	movw	r24, r16
    193c:	59 d3       	rcall	.+1714   	; 0x1ff0 <usartBufferPutByte>
    193e:	f1 cf       	rjmp	.-30     	; 0x1922 <uartLoopBack+0x20>

00001940 <EnableInter32MhzOsc>:
// define the usart port
#define PC_USART	 USARTC0

void EnableInter32MhzOsc() {
	
	CCP = CCP_IOREG_gc;// disable register security for oscillator update
    1940:	88 ed       	ldi	r24, 0xD8	; 216
    1942:	84 bf       	out	0x34, r24	; 52
	OSC.CTRL = OSC_RC32MEN_bm; // enable 32MHz oscillator
    1944:	82 e0       	ldi	r24, 0x02	; 2
    1946:	80 93 50 00 	sts	0x0050, r24
	while(!(OSC.STATUS & OSC_RC32MRDY_bm)); // wait for oscillator to be ready
    194a:	e0 e5       	ldi	r30, 0x50	; 80
    194c:	f0 e0       	ldi	r31, 0x00	; 0
    194e:	81 81       	ldd	r24, Z+1	; 0x01
    1950:	81 ff       	sbrs	r24, 1
    1952:	fd cf       	rjmp	.-6      	; 0x194e <EnableInter32MhzOsc+0xe>
	CCP = CCP_IOREG_gc; //disable register security for clock update
    1954:	88 ed       	ldi	r24, 0xD8	; 216
    1956:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL = CLK_SCLKSEL_RC32M_gc; // switch to 32MHz clock
    1958:	81 e0       	ldi	r24, 0x01	; 1
    195a:	80 93 40 00 	sts	0x0040, r24
    195e:	08 95       	ret

00001960 <main>:
		}
	}
}

int main(void)
{	
    1960:	af 92       	push	r10
    1962:	bf 92       	push	r11
    1964:	cf 92       	push	r12
    1966:	df 92       	push	r13
    1968:	ef 92       	push	r14
    196a:	ff 92       	push	r15
    196c:	0f 93       	push	r16
	
	EnableInter32MhzOsc();
    196e:	e8 df       	rcall	.-48     	; 0x1940 <EnableInter32MhzOsc>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    1970:	e0 e0       	ldi	r30, 0x00	; 0
    1972:	f6 e0       	ldi	r31, 0x06	; 6
    1974:	80 e1       	ldi	r24, 0x10	; 16
    1976:	81 83       	std	Z+1, r24	; 0x01
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	81 83       	std	Z+1, r24	; 0x01
	ioport_init();
	ioport_set_pin_dir(RED, IOPORT_DIR_OUTPUT);
	ioport_set_pin_dir(YELLOW, IOPORT_DIR_OUTPUT);
			
	// start tasks
	xTaskCreate(blink1, (signed char*) "blink1", 1024, NULL, 2, NULL);
    197c:	a1 2c       	mov	r10, r1
    197e:	b1 2c       	mov	r11, r1
    1980:	c1 2c       	mov	r12, r1
    1982:	d1 2c       	mov	r13, r1
    1984:	e1 2c       	mov	r14, r1
    1986:	f1 2c       	mov	r15, r1
    1988:	02 e0       	ldi	r16, 0x02	; 2
    198a:	20 e0       	ldi	r18, 0x00	; 0
    198c:	30 e0       	ldi	r19, 0x00	; 0
    198e:	40 e0       	ldi	r20, 0x00	; 0
    1990:	54 e0       	ldi	r21, 0x04	; 4
    1992:	6e e1       	ldi	r22, 0x1E	; 30
    1994:	70 e2       	ldi	r23, 0x20	; 32
    1996:	81 e7       	ldi	r24, 0x71	; 113
    1998:	9c e0       	ldi	r25, 0x0C	; 12
    199a:	4e d9       	rcall	.-3428   	; 0xc38 <xTaskGenericCreate>
	xTaskCreate(blink2, (signed char*) "blink2", 1024, NULL, 2, NULL);
    199c:	20 e0       	ldi	r18, 0x00	; 0
    199e:	30 e0       	ldi	r19, 0x00	; 0
    19a0:	40 e0       	ldi	r20, 0x00	; 0
    19a2:	54 e0       	ldi	r21, 0x04	; 4
    19a4:	65 e2       	ldi	r22, 0x25	; 37
    19a6:	70 e2       	ldi	r23, 0x20	; 32
    19a8:	89 e7       	ldi	r24, 0x79	; 121
    19aa:	9c e0       	ldi	r25, 0x0C	; 12
    19ac:	45 d9       	rcall	.-3446   	; 0xc38 <xTaskGenericCreate>
	xTaskCreate(uartLoopBack, (signed char*) "uart1", 1024, NULL, 2, NULL);
    19ae:	20 e0       	ldi	r18, 0x00	; 0
    19b0:	30 e0       	ldi	r19, 0x00	; 0
    19b2:	40 e0       	ldi	r20, 0x00	; 0
    19b4:	54 e0       	ldi	r21, 0x04	; 4
    19b6:	6c e2       	ldi	r22, 0x2C	; 44
    19b8:	70 e2       	ldi	r23, 0x20	; 32
    19ba:	81 e8       	ldi	r24, 0x81	; 129
    19bc:	9c e0       	ldi	r25, 0x0C	; 12
    19be:	3c d9       	rcall	.-3464   	; 0xc38 <xTaskGenericCreate>
	
	vTaskStartScheduler();
    19c0:	30 da       	rcall	.-2976   	; 0xe22 <vTaskStartScheduler>
	
	return 0;
    19c2:	80 e0       	ldi	r24, 0x00	; 0
    19c4:	90 e0       	ldi	r25, 0x00	; 0
    19c6:	0f 91       	pop	r16
    19c8:	ff 90       	pop	r15
    19ca:	ef 90       	pop	r14
    19cc:	df 90       	pop	r13
    19ce:	cf 90       	pop	r12
    19d0:	bf 90       	pop	r11
    19d2:	af 90       	pop	r10
    19d4:	08 95       	ret

000019d6 <PORT_ConfigurePins>:
                         uint8_t pinMask,
                         uint8_t slewRateEnable,
                         uint8_t invertEnable,
                         PORT_OPC_t opc,
                         PORT_ISC_t isc)
{
    19d6:	ef 92       	push	r14
    19d8:	0f 93       	push	r16
	/* Build pin control register value. */
	uint8_t temp = (uint8_t) opc |
    19da:	0e 29       	or	r16, r14
    19dc:	44 23       	and	r20, r20
    19de:	11 f0       	breq	.+4      	; 0x19e4 <PORT_ConfigurePins+0xe>
    19e0:	30 e8       	ldi	r19, 0x80	; 128
    19e2:	01 c0       	rjmp	.+2      	; 0x19e6 <PORT_ConfigurePins+0x10>
    19e4:	30 e0       	ldi	r19, 0x00	; 0
    19e6:	03 2b       	or	r16, r19
    19e8:	22 23       	and	r18, r18
    19ea:	11 f0       	breq	.+4      	; 0x19f0 <PORT_ConfigurePins+0x1a>
    19ec:	20 e4       	ldi	r18, 0x40	; 64
    19ee:	01 c0       	rjmp	.+2      	; 0x19f2 <PORT_ConfigurePins+0x1c>
    19f0:	20 e0       	ldi	r18, 0x00	; 0
    19f2:	02 2b       	or	r16, r18
	               (invertEnable ? PORT_INVEN_bm : 0);

	/* Configure the pins in one atomic operation. */

	/* Save status register. */
	uint8_t sreg = SREG;
    19f4:	2f b7       	in	r18, 0x3f	; 63

	cli();
    19f6:	f8 94       	cli
	PORTCFG.MPCMASK = pinMask;
    19f8:	60 93 b0 00 	sts	0x00B0, r22
	port->PIN0CTRL = temp;
    19fc:	fc 01       	movw	r30, r24
    19fe:	00 8b       	std	Z+16, r16	; 0x10

	/* Restore status register. */
	SREG = sreg;
    1a00:	2f bf       	out	0x3f, r18	; 63
}
    1a02:	0f 91       	pop	r16
    1a04:	ef 90       	pop	r14
    1a06:	08 95       	ret

00001a08 <TC0_ConfigClockSource>:
{
	/* Make sure only CCxEN bits are set in disableMask. */
	disableMask &= ( TC1_CCAEN_bm | TC1_CCBEN_bm );

	/* Disable channels. */
	tc->CTRLB &= ~disableMask;
    1a08:	fc 01       	movw	r30, r24
    1a0a:	20 81       	ld	r18, Z
    1a0c:	20 7f       	andi	r18, 0xF0	; 240
    1a0e:	62 2b       	or	r22, r18
    1a10:	60 83       	st	Z, r22
    1a12:	08 95       	ret

00001a14 <TC0_SetOverflowIntLevel>:
 *  \param tc               Timer/Counter module instance.
 *  \param intLevel         New overflow interrupt level.
 */
void TC0_SetOverflowIntLevel( volatile TC0_t * tc, TC_OVFINTLVL_t intLevel )
{
	tc->INTCTRLA = ( tc->INTCTRLA & ~TC0_OVFINTLVL_gm ) | intLevel;
    1a14:	fc 01       	movw	r30, r24
    1a16:	26 81       	ldd	r18, Z+6	; 0x06
    1a18:	2c 7f       	andi	r18, 0xFC	; 252
    1a1a:	62 2b       	or	r22, r18
    1a1c:	66 83       	std	Z+6, r22	; 0x06
    1a1e:	08 95       	ret

00001a20 <__vector_25>:
 *  correct USART as argument.
 */
ISR(USARTC0_DRE_vect){USART_DataRegEmpty(usartBufferC);}
ISR(USARTD0_DRE_vect){USART_DataRegEmpty(usartBufferD);}
ISR(USARTE0_DRE_vect){USART_DataRegEmpty(usartBufferE);}
ISR(USARTF0_DRE_vect){USART_DataRegEmpty(usartBufferF);}
    1a20:	1f 92       	push	r1
    1a22:	0f 92       	push	r0
    1a24:	0f b6       	in	r0, 0x3f	; 63
    1a26:	0f 92       	push	r0
    1a28:	11 24       	eor	r1, r1
    1a2a:	08 b6       	in	r0, 0x38	; 56
    1a2c:	0f 92       	push	r0
    1a2e:	18 be       	out	0x38, r1	; 56
    1a30:	09 b6       	in	r0, 0x39	; 57
    1a32:	0f 92       	push	r0
    1a34:	19 be       	out	0x39, r1	; 57
    1a36:	0a b6       	in	r0, 0x3a	; 58
    1a38:	0f 92       	push	r0
    1a3a:	1a be       	out	0x3a, r1	; 58
    1a3c:	0b b6       	in	r0, 0x3b	; 59
    1a3e:	0f 92       	push	r0
    1a40:	1b be       	out	0x3b, r1	; 59
    1a42:	2f 93       	push	r18
    1a44:	3f 93       	push	r19
    1a46:	4f 93       	push	r20
    1a48:	5f 93       	push	r21
    1a4a:	6f 93       	push	r22
    1a4c:	7f 93       	push	r23
    1a4e:	8f 93       	push	r24
    1a50:	9f 93       	push	r25
    1a52:	af 93       	push	r26
    1a54:	bf 93       	push	r27
    1a56:	ef 93       	push	r30
    1a58:	ff 93       	push	r31
    1a5a:	cf 93       	push	r28
    1a5c:	df 93       	push	r29
    1a5e:	1f 92       	push	r1
    1a60:	1f 92       	push	r1
    1a62:	cd b7       	in	r28, 0x3d	; 61
    1a64:	de b7       	in	r29, 0x3e	; 62
    1a66:	e0 91 1d 38 	lds	r30, 0x381D
    1a6a:	f0 91 1e 38 	lds	r31, 0x381E
    1a6e:	1a 82       	std	Y+2, r1	; 0x02
    1a70:	a0 81       	ld	r26, Z
    1a72:	b1 81       	ldd	r27, Z+1	; 0x01
    1a74:	8c 91       	ld	r24, X
    1a76:	89 83       	std	Y+1, r24	; 0x01
    1a78:	20 e0       	ldi	r18, 0x00	; 0
    1a7a:	ae 01       	movw	r20, r28
    1a7c:	4e 5f       	subi	r20, 0xFE	; 254
    1a7e:	5f 4f       	sbci	r21, 0xFF	; 255
    1a80:	be 01       	movw	r22, r28
    1a82:	6f 5f       	subi	r22, 0xFF	; 255
    1a84:	7f 4f       	sbci	r23, 0xFF	; 255
    1a86:	83 81       	ldd	r24, Z+3	; 0x03
    1a88:	94 81       	ldd	r25, Z+4	; 0x04
    1a8a:	0e 94 c2 04 	call	0x984	; 0x984 <xQueueGenericSendFromISR>
    1a8e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a90:	81 11       	cpse	r24, r1
    1a92:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vPortYield>
    1a96:	0f 90       	pop	r0
    1a98:	0f 90       	pop	r0
    1a9a:	df 91       	pop	r29
    1a9c:	cf 91       	pop	r28
    1a9e:	ff 91       	pop	r31
    1aa0:	ef 91       	pop	r30
    1aa2:	bf 91       	pop	r27
    1aa4:	af 91       	pop	r26
    1aa6:	9f 91       	pop	r25
    1aa8:	8f 91       	pop	r24
    1aaa:	7f 91       	pop	r23
    1aac:	6f 91       	pop	r22
    1aae:	5f 91       	pop	r21
    1ab0:	4f 91       	pop	r20
    1ab2:	3f 91       	pop	r19
    1ab4:	2f 91       	pop	r18
    1ab6:	0f 90       	pop	r0
    1ab8:	0b be       	out	0x3b, r0	; 59
    1aba:	0f 90       	pop	r0
    1abc:	0a be       	out	0x3a, r0	; 58
    1abe:	0f 90       	pop	r0
    1ac0:	09 be       	out	0x39, r0	; 57
    1ac2:	0f 90       	pop	r0
    1ac4:	08 be       	out	0x38, r0	; 56
    1ac6:	0f 90       	pop	r0
    1ac8:	0f be       	out	0x3f, r0	; 63
    1aca:	0f 90       	pop	r0
    1acc:	1f 90       	pop	r1
    1ace:	18 95       	reti

00001ad0 <__vector_88>:
    1ad0:	1f 92       	push	r1
    1ad2:	0f 92       	push	r0
    1ad4:	0f b6       	in	r0, 0x3f	; 63
    1ad6:	0f 92       	push	r0
    1ad8:	11 24       	eor	r1, r1
    1ada:	08 b6       	in	r0, 0x38	; 56
    1adc:	0f 92       	push	r0
    1ade:	18 be       	out	0x38, r1	; 56
    1ae0:	09 b6       	in	r0, 0x39	; 57
    1ae2:	0f 92       	push	r0
    1ae4:	19 be       	out	0x39, r1	; 57
    1ae6:	0a b6       	in	r0, 0x3a	; 58
    1ae8:	0f 92       	push	r0
    1aea:	1a be       	out	0x3a, r1	; 58
    1aec:	0b b6       	in	r0, 0x3b	; 59
    1aee:	0f 92       	push	r0
    1af0:	1b be       	out	0x3b, r1	; 59
    1af2:	2f 93       	push	r18
    1af4:	3f 93       	push	r19
    1af6:	4f 93       	push	r20
    1af8:	5f 93       	push	r21
    1afa:	6f 93       	push	r22
    1afc:	7f 93       	push	r23
    1afe:	8f 93       	push	r24
    1b00:	9f 93       	push	r25
    1b02:	af 93       	push	r26
    1b04:	bf 93       	push	r27
    1b06:	ef 93       	push	r30
    1b08:	ff 93       	push	r31
    1b0a:	cf 93       	push	r28
    1b0c:	df 93       	push	r29
    1b0e:	1f 92       	push	r1
    1b10:	1f 92       	push	r1
    1b12:	cd b7       	in	r28, 0x3d	; 61
    1b14:	de b7       	in	r29, 0x3e	; 62
    1b16:	e0 91 1b 38 	lds	r30, 0x381B
    1b1a:	f0 91 1c 38 	lds	r31, 0x381C
    1b1e:	1a 82       	std	Y+2, r1	; 0x02
    1b20:	a0 81       	ld	r26, Z
    1b22:	b1 81       	ldd	r27, Z+1	; 0x01
    1b24:	8c 91       	ld	r24, X
    1b26:	89 83       	std	Y+1, r24	; 0x01
    1b28:	20 e0       	ldi	r18, 0x00	; 0
    1b2a:	ae 01       	movw	r20, r28
    1b2c:	4e 5f       	subi	r20, 0xFE	; 254
    1b2e:	5f 4f       	sbci	r21, 0xFF	; 255
    1b30:	be 01       	movw	r22, r28
    1b32:	6f 5f       	subi	r22, 0xFF	; 255
    1b34:	7f 4f       	sbci	r23, 0xFF	; 255
    1b36:	83 81       	ldd	r24, Z+3	; 0x03
    1b38:	94 81       	ldd	r25, Z+4	; 0x04
    1b3a:	0e 94 c2 04 	call	0x984	; 0x984 <xQueueGenericSendFromISR>
    1b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    1b40:	81 11       	cpse	r24, r1
    1b42:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vPortYield>
    1b46:	0f 90       	pop	r0
    1b48:	0f 90       	pop	r0
    1b4a:	df 91       	pop	r29
    1b4c:	cf 91       	pop	r28
    1b4e:	ff 91       	pop	r31
    1b50:	ef 91       	pop	r30
    1b52:	bf 91       	pop	r27
    1b54:	af 91       	pop	r26
    1b56:	9f 91       	pop	r25
    1b58:	8f 91       	pop	r24
    1b5a:	7f 91       	pop	r23
    1b5c:	6f 91       	pop	r22
    1b5e:	5f 91       	pop	r21
    1b60:	4f 91       	pop	r20
    1b62:	3f 91       	pop	r19
    1b64:	2f 91       	pop	r18
    1b66:	0f 90       	pop	r0
    1b68:	0b be       	out	0x3b, r0	; 59
    1b6a:	0f 90       	pop	r0
    1b6c:	0a be       	out	0x3a, r0	; 58
    1b6e:	0f 90       	pop	r0
    1b70:	09 be       	out	0x39, r0	; 57
    1b72:	0f 90       	pop	r0
    1b74:	08 be       	out	0x38, r0	; 56
    1b76:	0f 90       	pop	r0
    1b78:	0f be       	out	0x3f, r0	; 63
    1b7a:	0f 90       	pop	r0
    1b7c:	1f 90       	pop	r1
    1b7e:	18 95       	reti

00001b80 <__vector_58>:
    1b80:	1f 92       	push	r1
    1b82:	0f 92       	push	r0
    1b84:	0f b6       	in	r0, 0x3f	; 63
    1b86:	0f 92       	push	r0
    1b88:	11 24       	eor	r1, r1
    1b8a:	08 b6       	in	r0, 0x38	; 56
    1b8c:	0f 92       	push	r0
    1b8e:	18 be       	out	0x38, r1	; 56
    1b90:	09 b6       	in	r0, 0x39	; 57
    1b92:	0f 92       	push	r0
    1b94:	19 be       	out	0x39, r1	; 57
    1b96:	0a b6       	in	r0, 0x3a	; 58
    1b98:	0f 92       	push	r0
    1b9a:	1a be       	out	0x3a, r1	; 58
    1b9c:	0b b6       	in	r0, 0x3b	; 59
    1b9e:	0f 92       	push	r0
    1ba0:	1b be       	out	0x3b, r1	; 59
    1ba2:	2f 93       	push	r18
    1ba4:	3f 93       	push	r19
    1ba6:	4f 93       	push	r20
    1ba8:	5f 93       	push	r21
    1baa:	6f 93       	push	r22
    1bac:	7f 93       	push	r23
    1bae:	8f 93       	push	r24
    1bb0:	9f 93       	push	r25
    1bb2:	af 93       	push	r26
    1bb4:	bf 93       	push	r27
    1bb6:	ef 93       	push	r30
    1bb8:	ff 93       	push	r31
    1bba:	cf 93       	push	r28
    1bbc:	df 93       	push	r29
    1bbe:	1f 92       	push	r1
    1bc0:	1f 92       	push	r1
    1bc2:	cd b7       	in	r28, 0x3d	; 61
    1bc4:	de b7       	in	r29, 0x3e	; 62
    1bc6:	e0 91 19 38 	lds	r30, 0x3819
    1bca:	f0 91 1a 38 	lds	r31, 0x381A
    1bce:	1a 82       	std	Y+2, r1	; 0x02
    1bd0:	a0 81       	ld	r26, Z
    1bd2:	b1 81       	ldd	r27, Z+1	; 0x01
    1bd4:	8c 91       	ld	r24, X
    1bd6:	89 83       	std	Y+1, r24	; 0x01
    1bd8:	20 e0       	ldi	r18, 0x00	; 0
    1bda:	ae 01       	movw	r20, r28
    1bdc:	4e 5f       	subi	r20, 0xFE	; 254
    1bde:	5f 4f       	sbci	r21, 0xFF	; 255
    1be0:	be 01       	movw	r22, r28
    1be2:	6f 5f       	subi	r22, 0xFF	; 255
    1be4:	7f 4f       	sbci	r23, 0xFF	; 255
    1be6:	83 81       	ldd	r24, Z+3	; 0x03
    1be8:	94 81       	ldd	r25, Z+4	; 0x04
    1bea:	0e 94 c2 04 	call	0x984	; 0x984 <xQueueGenericSendFromISR>
    1bee:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf0:	81 11       	cpse	r24, r1
    1bf2:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vPortYield>
    1bf6:	0f 90       	pop	r0
    1bf8:	0f 90       	pop	r0
    1bfa:	df 91       	pop	r29
    1bfc:	cf 91       	pop	r28
    1bfe:	ff 91       	pop	r31
    1c00:	ef 91       	pop	r30
    1c02:	bf 91       	pop	r27
    1c04:	af 91       	pop	r26
    1c06:	9f 91       	pop	r25
    1c08:	8f 91       	pop	r24
    1c0a:	7f 91       	pop	r23
    1c0c:	6f 91       	pop	r22
    1c0e:	5f 91       	pop	r21
    1c10:	4f 91       	pop	r20
    1c12:	3f 91       	pop	r19
    1c14:	2f 91       	pop	r18
    1c16:	0f 90       	pop	r0
    1c18:	0b be       	out	0x3b, r0	; 59
    1c1a:	0f 90       	pop	r0
    1c1c:	0a be       	out	0x3a, r0	; 58
    1c1e:	0f 90       	pop	r0
    1c20:	09 be       	out	0x39, r0	; 57
    1c22:	0f 90       	pop	r0
    1c24:	08 be       	out	0x38, r0	; 56
    1c26:	0f 90       	pop	r0
    1c28:	0f be       	out	0x3f, r0	; 63
    1c2a:	0f 90       	pop	r0
    1c2c:	1f 90       	pop	r1
    1c2e:	18 95       	reti

00001c30 <__vector_26>:
    1c30:	1f 92       	push	r1
    1c32:	0f 92       	push	r0
    1c34:	0f b6       	in	r0, 0x3f	; 63
    1c36:	0f 92       	push	r0
    1c38:	11 24       	eor	r1, r1
    1c3a:	08 b6       	in	r0, 0x38	; 56
    1c3c:	0f 92       	push	r0
    1c3e:	18 be       	out	0x38, r1	; 56
    1c40:	09 b6       	in	r0, 0x39	; 57
    1c42:	0f 92       	push	r0
    1c44:	19 be       	out	0x39, r1	; 57
    1c46:	0a b6       	in	r0, 0x3a	; 58
    1c48:	0f 92       	push	r0
    1c4a:	1a be       	out	0x3a, r1	; 58
    1c4c:	0b b6       	in	r0, 0x3b	; 59
    1c4e:	0f 92       	push	r0
    1c50:	1b be       	out	0x3b, r1	; 59
    1c52:	0f 93       	push	r16
    1c54:	1f 93       	push	r17
    1c56:	2f 93       	push	r18
    1c58:	3f 93       	push	r19
    1c5a:	4f 93       	push	r20
    1c5c:	5f 93       	push	r21
    1c5e:	6f 93       	push	r22
    1c60:	7f 93       	push	r23
    1c62:	8f 93       	push	r24
    1c64:	9f 93       	push	r25
    1c66:	af 93       	push	r26
    1c68:	bf 93       	push	r27
    1c6a:	ef 93       	push	r30
    1c6c:	ff 93       	push	r31
    1c6e:	cf 93       	push	r28
    1c70:	df 93       	push	r29
    1c72:	1f 92       	push	r1
    1c74:	1f 92       	push	r1
    1c76:	cd b7       	in	r28, 0x3d	; 61
    1c78:	de b7       	in	r29, 0x3e	; 62
    1c7a:	00 91 1d 38 	lds	r16, 0x381D
    1c7e:	10 91 1e 38 	lds	r17, 0x381E
    1c82:	ae 01       	movw	r20, r28
    1c84:	4f 5f       	subi	r20, 0xFF	; 255
    1c86:	5f 4f       	sbci	r21, 0xFF	; 255
    1c88:	be 01       	movw	r22, r28
    1c8a:	6e 5f       	subi	r22, 0xFE	; 254
    1c8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c8e:	d8 01       	movw	r26, r16
    1c90:	15 96       	adiw	r26, 0x05	; 5
    1c92:	8d 91       	ld	r24, X+
    1c94:	9c 91       	ld	r25, X
    1c96:	16 97       	sbiw	r26, 0x06	; 6
    1c98:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueReceiveFromISR>
    1c9c:	81 30       	cpi	r24, 0x01	; 1
    1c9e:	31 f4       	brne	.+12     	; 0x1cac <__vector_26+0x7c>
    1ca0:	d8 01       	movw	r26, r16
    1ca2:	ed 91       	ld	r30, X+
    1ca4:	fc 91       	ld	r31, X
    1ca6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ca8:	80 83       	st	Z, r24
    1caa:	06 c0       	rjmp	.+12     	; 0x1cb8 <__vector_26+0x88>
    1cac:	d8 01       	movw	r26, r16
    1cae:	ed 91       	ld	r30, X+
    1cb0:	fc 91       	ld	r31, X
    1cb2:	83 81       	ldd	r24, Z+3	; 0x03
    1cb4:	8c 7f       	andi	r24, 0xFC	; 252
    1cb6:	83 83       	std	Z+3, r24	; 0x03
    1cb8:	0f 90       	pop	r0
    1cba:	0f 90       	pop	r0
    1cbc:	df 91       	pop	r29
    1cbe:	cf 91       	pop	r28
    1cc0:	ff 91       	pop	r31
    1cc2:	ef 91       	pop	r30
    1cc4:	bf 91       	pop	r27
    1cc6:	af 91       	pop	r26
    1cc8:	9f 91       	pop	r25
    1cca:	8f 91       	pop	r24
    1ccc:	7f 91       	pop	r23
    1cce:	6f 91       	pop	r22
    1cd0:	5f 91       	pop	r21
    1cd2:	4f 91       	pop	r20
    1cd4:	3f 91       	pop	r19
    1cd6:	2f 91       	pop	r18
    1cd8:	1f 91       	pop	r17
    1cda:	0f 91       	pop	r16
    1cdc:	0f 90       	pop	r0
    1cde:	0b be       	out	0x3b, r0	; 59
    1ce0:	0f 90       	pop	r0
    1ce2:	0a be       	out	0x3a, r0	; 58
    1ce4:	0f 90       	pop	r0
    1ce6:	09 be       	out	0x39, r0	; 57
    1ce8:	0f 90       	pop	r0
    1cea:	08 be       	out	0x38, r0	; 56
    1cec:	0f 90       	pop	r0
    1cee:	0f be       	out	0x3f, r0	; 63
    1cf0:	0f 90       	pop	r0
    1cf2:	1f 90       	pop	r1
    1cf4:	18 95       	reti

00001cf6 <__vector_89>:
    1cf6:	1f 92       	push	r1
    1cf8:	0f 92       	push	r0
    1cfa:	0f b6       	in	r0, 0x3f	; 63
    1cfc:	0f 92       	push	r0
    1cfe:	11 24       	eor	r1, r1
    1d00:	08 b6       	in	r0, 0x38	; 56
    1d02:	0f 92       	push	r0
    1d04:	18 be       	out	0x38, r1	; 56
    1d06:	09 b6       	in	r0, 0x39	; 57
    1d08:	0f 92       	push	r0
    1d0a:	19 be       	out	0x39, r1	; 57
    1d0c:	0a b6       	in	r0, 0x3a	; 58
    1d0e:	0f 92       	push	r0
    1d10:	1a be       	out	0x3a, r1	; 58
    1d12:	0b b6       	in	r0, 0x3b	; 59
    1d14:	0f 92       	push	r0
    1d16:	1b be       	out	0x3b, r1	; 59
    1d18:	0f 93       	push	r16
    1d1a:	1f 93       	push	r17
    1d1c:	2f 93       	push	r18
    1d1e:	3f 93       	push	r19
    1d20:	4f 93       	push	r20
    1d22:	5f 93       	push	r21
    1d24:	6f 93       	push	r22
    1d26:	7f 93       	push	r23
    1d28:	8f 93       	push	r24
    1d2a:	9f 93       	push	r25
    1d2c:	af 93       	push	r26
    1d2e:	bf 93       	push	r27
    1d30:	ef 93       	push	r30
    1d32:	ff 93       	push	r31
    1d34:	cf 93       	push	r28
    1d36:	df 93       	push	r29
    1d38:	1f 92       	push	r1
    1d3a:	1f 92       	push	r1
    1d3c:	cd b7       	in	r28, 0x3d	; 61
    1d3e:	de b7       	in	r29, 0x3e	; 62
    1d40:	00 91 1b 38 	lds	r16, 0x381B
    1d44:	10 91 1c 38 	lds	r17, 0x381C
    1d48:	ae 01       	movw	r20, r28
    1d4a:	4f 5f       	subi	r20, 0xFF	; 255
    1d4c:	5f 4f       	sbci	r21, 0xFF	; 255
    1d4e:	be 01       	movw	r22, r28
    1d50:	6e 5f       	subi	r22, 0xFE	; 254
    1d52:	7f 4f       	sbci	r23, 0xFF	; 255
    1d54:	d8 01       	movw	r26, r16
    1d56:	15 96       	adiw	r26, 0x05	; 5
    1d58:	8d 91       	ld	r24, X+
    1d5a:	9c 91       	ld	r25, X
    1d5c:	16 97       	sbiw	r26, 0x06	; 6
    1d5e:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueReceiveFromISR>
    1d62:	81 30       	cpi	r24, 0x01	; 1
    1d64:	31 f4       	brne	.+12     	; 0x1d72 <__vector_89+0x7c>
    1d66:	d8 01       	movw	r26, r16
    1d68:	ed 91       	ld	r30, X+
    1d6a:	fc 91       	ld	r31, X
    1d6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d6e:	80 83       	st	Z, r24
    1d70:	06 c0       	rjmp	.+12     	; 0x1d7e <__vector_89+0x88>
    1d72:	d8 01       	movw	r26, r16
    1d74:	ed 91       	ld	r30, X+
    1d76:	fc 91       	ld	r31, X
    1d78:	83 81       	ldd	r24, Z+3	; 0x03
    1d7a:	8c 7f       	andi	r24, 0xFC	; 252
    1d7c:	83 83       	std	Z+3, r24	; 0x03
    1d7e:	0f 90       	pop	r0
    1d80:	0f 90       	pop	r0
    1d82:	df 91       	pop	r29
    1d84:	cf 91       	pop	r28
    1d86:	ff 91       	pop	r31
    1d88:	ef 91       	pop	r30
    1d8a:	bf 91       	pop	r27
    1d8c:	af 91       	pop	r26
    1d8e:	9f 91       	pop	r25
    1d90:	8f 91       	pop	r24
    1d92:	7f 91       	pop	r23
    1d94:	6f 91       	pop	r22
    1d96:	5f 91       	pop	r21
    1d98:	4f 91       	pop	r20
    1d9a:	3f 91       	pop	r19
    1d9c:	2f 91       	pop	r18
    1d9e:	1f 91       	pop	r17
    1da0:	0f 91       	pop	r16
    1da2:	0f 90       	pop	r0
    1da4:	0b be       	out	0x3b, r0	; 59
    1da6:	0f 90       	pop	r0
    1da8:	0a be       	out	0x3a, r0	; 58
    1daa:	0f 90       	pop	r0
    1dac:	09 be       	out	0x39, r0	; 57
    1dae:	0f 90       	pop	r0
    1db0:	08 be       	out	0x38, r0	; 56
    1db2:	0f 90       	pop	r0
    1db4:	0f be       	out	0x3f, r0	; 63
    1db6:	0f 90       	pop	r0
    1db8:	1f 90       	pop	r1
    1dba:	18 95       	reti

00001dbc <__vector_59>:
    1dbc:	1f 92       	push	r1
    1dbe:	0f 92       	push	r0
    1dc0:	0f b6       	in	r0, 0x3f	; 63
    1dc2:	0f 92       	push	r0
    1dc4:	11 24       	eor	r1, r1
    1dc6:	08 b6       	in	r0, 0x38	; 56
    1dc8:	0f 92       	push	r0
    1dca:	18 be       	out	0x38, r1	; 56
    1dcc:	09 b6       	in	r0, 0x39	; 57
    1dce:	0f 92       	push	r0
    1dd0:	19 be       	out	0x39, r1	; 57
    1dd2:	0a b6       	in	r0, 0x3a	; 58
    1dd4:	0f 92       	push	r0
    1dd6:	1a be       	out	0x3a, r1	; 58
    1dd8:	0b b6       	in	r0, 0x3b	; 59
    1dda:	0f 92       	push	r0
    1ddc:	1b be       	out	0x3b, r1	; 59
    1dde:	0f 93       	push	r16
    1de0:	1f 93       	push	r17
    1de2:	2f 93       	push	r18
    1de4:	3f 93       	push	r19
    1de6:	4f 93       	push	r20
    1de8:	5f 93       	push	r21
    1dea:	6f 93       	push	r22
    1dec:	7f 93       	push	r23
    1dee:	8f 93       	push	r24
    1df0:	9f 93       	push	r25
    1df2:	af 93       	push	r26
    1df4:	bf 93       	push	r27
    1df6:	ef 93       	push	r30
    1df8:	ff 93       	push	r31
    1dfa:	cf 93       	push	r28
    1dfc:	df 93       	push	r29
    1dfe:	1f 92       	push	r1
    1e00:	1f 92       	push	r1
    1e02:	cd b7       	in	r28, 0x3d	; 61
    1e04:	de b7       	in	r29, 0x3e	; 62
    1e06:	00 91 19 38 	lds	r16, 0x3819
    1e0a:	10 91 1a 38 	lds	r17, 0x381A
    1e0e:	ae 01       	movw	r20, r28
    1e10:	4f 5f       	subi	r20, 0xFF	; 255
    1e12:	5f 4f       	sbci	r21, 0xFF	; 255
    1e14:	be 01       	movw	r22, r28
    1e16:	6e 5f       	subi	r22, 0xFE	; 254
    1e18:	7f 4f       	sbci	r23, 0xFF	; 255
    1e1a:	d8 01       	movw	r26, r16
    1e1c:	15 96       	adiw	r26, 0x05	; 5
    1e1e:	8d 91       	ld	r24, X+
    1e20:	9c 91       	ld	r25, X
    1e22:	16 97       	sbiw	r26, 0x06	; 6
    1e24:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueReceiveFromISR>
    1e28:	81 30       	cpi	r24, 0x01	; 1
    1e2a:	31 f4       	brne	.+12     	; 0x1e38 <__vector_59+0x7c>
    1e2c:	d8 01       	movw	r26, r16
    1e2e:	ed 91       	ld	r30, X+
    1e30:	fc 91       	ld	r31, X
    1e32:	8a 81       	ldd	r24, Y+2	; 0x02
    1e34:	80 83       	st	Z, r24
    1e36:	06 c0       	rjmp	.+12     	; 0x1e44 <__vector_59+0x88>
    1e38:	d8 01       	movw	r26, r16
    1e3a:	ed 91       	ld	r30, X+
    1e3c:	fc 91       	ld	r31, X
    1e3e:	83 81       	ldd	r24, Z+3	; 0x03
    1e40:	8c 7f       	andi	r24, 0xFC	; 252
    1e42:	83 83       	std	Z+3, r24	; 0x03
    1e44:	0f 90       	pop	r0
    1e46:	0f 90       	pop	r0
    1e48:	df 91       	pop	r29
    1e4a:	cf 91       	pop	r28
    1e4c:	ff 91       	pop	r31
    1e4e:	ef 91       	pop	r30
    1e50:	bf 91       	pop	r27
    1e52:	af 91       	pop	r26
    1e54:	9f 91       	pop	r25
    1e56:	8f 91       	pop	r24
    1e58:	7f 91       	pop	r23
    1e5a:	6f 91       	pop	r22
    1e5c:	5f 91       	pop	r21
    1e5e:	4f 91       	pop	r20
    1e60:	3f 91       	pop	r19
    1e62:	2f 91       	pop	r18
    1e64:	1f 91       	pop	r17
    1e66:	0f 91       	pop	r16
    1e68:	0f 90       	pop	r0
    1e6a:	0b be       	out	0x3b, r0	; 59
    1e6c:	0f 90       	pop	r0
    1e6e:	0a be       	out	0x3a, r0	; 58
    1e70:	0f 90       	pop	r0
    1e72:	09 be       	out	0x39, r0	; 57
    1e74:	0f 90       	pop	r0
    1e76:	08 be       	out	0x38, r0	; 56
    1e78:	0f 90       	pop	r0
    1e7a:	0f be       	out	0x3f, r0	; 63
    1e7c:	0f 90       	pop	r0
    1e7e:	1f 90       	pop	r1
    1e80:	18 95       	reti

00001e82 <usartBufferInitialize>:
 *
 *  \param usart                Pointer to the USART module to use.
 *  \return usart_buffer        The USART_buffer_struct_t instance which can be used to read and write.
 */
UsartBuffer * usartBufferInitialize(USART_t * usart, Baudrate_enum baudrate ,char bufferSize)
{
    1e82:	cf 92       	push	r12
    1e84:	df 92       	push	r13
    1e86:	ef 92       	push	r14
    1e88:	ff 92       	push	r15
    1e8a:	0f 93       	push	r16
    1e8c:	1f 93       	push	r17
    1e8e:	cf 93       	push	r28
    1e90:	df 93       	push	r29
    1e92:	6c 01       	movw	r12, r24
    1e94:	16 2f       	mov	r17, r22
    1e96:	f4 2e       	mov	r15, r20
	USART_DREINTLVL_t dreIntLevel = USART_DREINTLVL_LO_gc;
	PORT_t * port;
	UsartBuffer * usartBuffer;
	//switch by pointer to usart structure, which will be used. Usually it is not a good idea to
	//switch by pointer, but in our case pointers are defined by hardware
	switch ((int)usart) {
    1e98:	80 ea       	ldi	r24, 0xA0	; 160
    1e9a:	c8 16       	cp	r12, r24
    1e9c:	89 e0       	ldi	r24, 0x09	; 9
    1e9e:	d8 06       	cpc	r13, r24
    1ea0:	b1 f0       	breq	.+44     	; 0x1ece <usartBufferInitialize+0x4c>
    1ea2:	80 ea       	ldi	r24, 0xA0	; 160
    1ea4:	c8 16       	cp	r12, r24
    1ea6:	8a e0       	ldi	r24, 0x0A	; 10
    1ea8:	d8 06       	cpc	r13, r24
    1eaa:	e9 f0       	breq	.+58     	; 0x1ee6 <usartBufferInitialize+0x64>
    1eac:	80 ea       	ldi	r24, 0xA0	; 160
    1eae:	c8 16       	cp	r12, r24
    1eb0:	88 e0       	ldi	r24, 0x08	; 8
    1eb2:	d8 06       	cpc	r13, r24
    1eb4:	19 f5       	brne	.+70     	; 0x1efc <usartBufferInitialize+0x7a>
		case (int)&USARTC0:
			//Allocate memory for usart structure and store the pointer
			usartBuffer = ( UsartBuffer * ) pvPortMalloc( sizeof( UsartBuffer ) );
    1eb6:	87 e0       	ldi	r24, 0x07	; 7
    1eb8:	90 e0       	ldi	r25, 0x00	; 0
    1eba:	0e 94 25 01 	call	0x24a	; 0x24a <pvPortMalloc>
    1ebe:	ec 01       	movw	r28, r24
			//copy pointer pUsartBuffer to global pUsartBufferC, which is use to handle interrupts
			usartBufferC = usartBuffer;
    1ec0:	80 93 1d 38 	sts	0x381D, r24
    1ec4:	90 93 1e 38 	sts	0x381E, r25
			//Since usart is on the port C, we will need to use PORTC
			port = &PORTC;
    1ec8:	e0 e4       	ldi	r30, 0x40	; 64
    1eca:	f6 e0       	ldi	r31, 0x06	; 6
			break;
    1ecc:	17 c0       	rjmp	.+46     	; 0x1efc <usartBufferInitialize+0x7a>
		case (int)&USARTD0:
			//Allocate memory for usart structure and store the pointer
			usartBuffer = ( UsartBuffer * ) pvPortMalloc( sizeof( UsartBuffer ) );
    1ece:	87 e0       	ldi	r24, 0x07	; 7
    1ed0:	90 e0       	ldi	r25, 0x00	; 0
    1ed2:	0e 94 25 01 	call	0x24a	; 0x24a <pvPortMalloc>
    1ed6:	ec 01       	movw	r28, r24
			//copy pointer pUsartBuffer to global pUsartBufferD, which is use to handle interrupts
			usartBufferD = usartBuffer;
    1ed8:	80 93 1b 38 	sts	0x381B, r24
    1edc:	90 93 1c 38 	sts	0x381C, r25
			//Since usart is on the port D, we will need to use PORTD
			port = &PORTD;
    1ee0:	e0 e6       	ldi	r30, 0x60	; 96
    1ee2:	f6 e0       	ldi	r31, 0x06	; 6
			break;
    1ee4:	0b c0       	rjmp	.+22     	; 0x1efc <usartBufferInitialize+0x7a>
		case (int)&USARTE0:
			//Allocate memory for usart structure and store the pointer
			usartBuffer = ( UsartBuffer * ) pvPortMalloc( sizeof( UsartBuffer ) );
    1ee6:	87 e0       	ldi	r24, 0x07	; 7
    1ee8:	90 e0       	ldi	r25, 0x00	; 0
    1eea:	0e 94 25 01 	call	0x24a	; 0x24a <pvPortMalloc>
    1eee:	ec 01       	movw	r28, r24
			//copy pointer pUsartBuffer to global pUsartBufferE, which is use to handle interrupts
			usartBufferE = usartBuffer;
    1ef0:	80 93 19 38 	sts	0x3819, r24
    1ef4:	90 93 1a 38 	sts	0x381A, r25
			//Since usart is on the port E, we will need to use PORTE
			port = &PORTE;
    1ef8:	e0 e8       	ldi	r30, 0x80	; 128
    1efa:	f6 e0       	ldi	r31, 0x06	; 6
			//use default, TODO: report error here with LED
			break;
	}

	/* (TX0) as output. */
	port->DIRSET = PIN3_bm;
    1efc:	88 e0       	ldi	r24, 0x08	; 8
    1efe:	81 83       	std	Z+1, r24	; 0x01
	/* (RX0) as input. */
	port->DIRCLR = PIN2_bm;
    1f00:	84 e0       	ldi	r24, 0x04	; 4
    1f02:	82 83       	std	Z+2, r24	; 0x02
	//totempole and pullup
	PORT_ConfigurePins( port,PIN3_bm,false,false,PORT_OPC_PULLUP_gc,PORT_ISC_BOTHEDGES_gc );
    1f04:	e1 2c       	mov	r14, r1
    1f06:	08 e1       	ldi	r16, 0x18	; 24
    1f08:	20 e0       	ldi	r18, 0x00	; 0
    1f0a:	40 e0       	ldi	r20, 0x00	; 0
    1f0c:	68 e0       	ldi	r22, 0x08	; 8
    1f0e:	cf 01       	movw	r24, r30
    1f10:	62 dd       	rcall	.-1340   	; 0x19d6 <PORT_ConfigurePins>
	/* Initialize buffers. Create a queue (allocate memory) and store queue handle in usart_struct
	 * On XMEGA port create all queues before vStartTaskScheduler() to ensure that heap size is enough */
	/* Store pointer to USART module */
	usartBuffer->usart = usart;
    1f12:	c8 82       	st	Y, r12
    1f14:	d9 82       	std	Y+1, r13	; 0x01
	/*Store DRE level so we will know which level to enable when we put data and want it to be sent. */
	usartBuffer->dreIntLevel = dreIntLevel;
    1f16:	81 e0       	ldi	r24, 0x01	; 1
    1f18:	8a 83       	std	Y+2, r24	; 0x02
	/* \brief  Receive buffer size: 2,4,8,16,32,64,128 bytes. */
	usartBuffer->xQueueRX = xQueueCreate(bufferSize,sizeof(char));
    1f1a:	61 e0       	ldi	r22, 0x01	; 1
    1f1c:	8f 2d       	mov	r24, r15
    1f1e:	0e 94 ee 03 	call	0x7dc	; 0x7dc <xQueueCreate>
    1f22:	8b 83       	std	Y+3, r24	; 0x03
    1f24:	9c 83       	std	Y+4, r25	; 0x04
	usartBuffer->xQueueTX = xQueueCreate(bufferSize,sizeof(char));
    1f26:	61 e0       	ldi	r22, 0x01	; 1
    1f28:	8f 2d       	mov	r24, r15
    1f2a:	0e 94 ee 03 	call	0x7dc	; 0x7dc <xQueueCreate>
    1f2e:	8d 83       	std	Y+5, r24	; 0x05
    1f30:	9e 83       	std	Y+6, r25	; 0x06

	/* USARTD0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(usartBuffer->usart, USART_CHSIZE_8BIT_gc, USART_PMODE_DISABLED_gc, true);
    1f32:	e8 81       	ld	r30, Y
    1f34:	f9 81       	ldd	r31, Y+1	; 0x01
    1f36:	8b e0       	ldi	r24, 0x0B	; 11
    1f38:	85 83       	std	Z+5, r24	; 0x05
	/* Enable RXC interrupt. */
	USART_RxdInterruptLevel_Set(usartBuffer->usart, USART_RXCINTLVL_LO_gc);
    1f3a:	e8 81       	ld	r30, Y
    1f3c:	f9 81       	ldd	r31, Y+1	; 0x01
    1f3e:	83 81       	ldd	r24, Z+3	; 0x03
    1f40:	8f 7c       	andi	r24, 0xCF	; 207
    1f42:	80 61       	ori	r24, 0x10	; 16
    1f44:	83 83       	std	Z+3, r24	; 0x03

	//http://prototalk.net/forums/showthread.php?t=188
	switch (baudrate) {
    1f46:	13 30       	cpi	r17, 0x03	; 3
    1f48:	e1 f0       	breq	.+56     	; 0x1f82 <usartBufferInitialize+0x100>
    1f4a:	28 f4       	brcc	.+10     	; 0x1f56 <usartBufferInitialize+0xd4>
    1f4c:	11 30       	cpi	r17, 0x01	; 1
    1f4e:	59 f1       	breq	.+86     	; 0x1fa6 <usartBufferInitialize+0x124>
    1f50:	12 30       	cpi	r17, 0x02	; 2
    1f52:	01 f1       	breq	.+64     	; 0x1f94 <usartBufferInitialize+0x112>
    1f54:	31 c0       	rjmp	.+98     	; 0x1fb8 <usartBufferInitialize+0x136>
    1f56:	14 30       	cpi	r17, 0x04	; 4
    1f58:	59 f0       	breq	.+22     	; 0x1f70 <usartBufferInitialize+0xee>
    1f5a:	15 30       	cpi	r17, 0x05	; 5
    1f5c:	69 f5       	brne	.+90     	; 0x1fb8 <usartBufferInitialize+0x136>
			case BAUD115200:
			USART_Baudrate_Set(usartBuffer->usart, 2094 , -7);
    1f5e:	e8 81       	ld	r30, Y
    1f60:	f9 81       	ldd	r31, Y+1	; 0x01
    1f62:	8e e2       	ldi	r24, 0x2E	; 46
    1f64:	86 83       	std	Z+6, r24	; 0x06
    1f66:	e8 81       	ld	r30, Y
    1f68:	f9 81       	ldd	r31, Y+1	; 0x01
    1f6a:	88 e9       	ldi	r24, 0x98	; 152
    1f6c:	87 83       	std	Z+7, r24	; 0x07
		break;
    1f6e:	2c c0       	rjmp	.+88     	; 0x1fc8 <usartBufferInitialize+0x146>
			case BAUD57600:
			USART_Baudrate_Set(usartBuffer->usart, 2158 , -6);
    1f70:	e8 81       	ld	r30, Y
    1f72:	f9 81       	ldd	r31, Y+1	; 0x01
    1f74:	8e e6       	ldi	r24, 0x6E	; 110
    1f76:	86 83       	std	Z+6, r24	; 0x06
    1f78:	e8 81       	ld	r30, Y
    1f7a:	f9 81       	ldd	r31, Y+1	; 0x01
    1f7c:	88 ea       	ldi	r24, 0xA8	; 168
    1f7e:	87 83       	std	Z+7, r24	; 0x07
		break;
    1f80:	23 c0       	rjmp	.+70     	; 0x1fc8 <usartBufferInitialize+0x146>
			case BAUD38400:
			USART_Baudrate_Set(usartBuffer->usart, 3269 , -6);
    1f82:	e8 81       	ld	r30, Y
    1f84:	f9 81       	ldd	r31, Y+1	; 0x01
    1f86:	85 ec       	ldi	r24, 0xC5	; 197
    1f88:	86 83       	std	Z+6, r24	; 0x06
    1f8a:	e8 81       	ld	r30, Y
    1f8c:	f9 81       	ldd	r31, Y+1	; 0x01
    1f8e:	8c ea       	ldi	r24, 0xAC	; 172
    1f90:	87 83       	std	Z+7, r24	; 0x07
		break;
    1f92:	1a c0       	rjmp	.+52     	; 0x1fc8 <usartBufferInitialize+0x146>
		case BAUD19200:
			USART_Baudrate_Set(usartBuffer->usart, 3301 , -5);
    1f94:	e8 81       	ld	r30, Y
    1f96:	f9 81       	ldd	r31, Y+1	; 0x01
    1f98:	85 ee       	ldi	r24, 0xE5	; 229
    1f9a:	86 83       	std	Z+6, r24	; 0x06
    1f9c:	e8 81       	ld	r30, Y
    1f9e:	f9 81       	ldd	r31, Y+1	; 0x01
    1fa0:	8c eb       	ldi	r24, 0xBC	; 188
    1fa2:	87 83       	std	Z+7, r24	; 0x07
			break;
    1fa4:	11 c0       	rjmp	.+34     	; 0x1fc8 <usartBufferInitialize+0x146>
		case BAUD9600:
			USART_Baudrate_Set(usartBuffer->usart, 3317 , -4);
    1fa6:	e8 81       	ld	r30, Y
    1fa8:	f9 81       	ldd	r31, Y+1	; 0x01
    1faa:	85 ef       	ldi	r24, 0xF5	; 245
    1fac:	86 83       	std	Z+6, r24	; 0x06
    1fae:	e8 81       	ld	r30, Y
    1fb0:	f9 81       	ldd	r31, Y+1	; 0x01
    1fb2:	8c ec       	ldi	r24, 0xCC	; 204
    1fb4:	87 83       	std	Z+7, r24	; 0x07
			break;
    1fb6:	08 c0       	rjmp	.+16     	; 0x1fc8 <usartBufferInitialize+0x146>
		default:
			//9600
			USART_Baudrate_Set(usartBuffer->usart, 3317 , -4);
    1fb8:	e8 81       	ld	r30, Y
    1fba:	f9 81       	ldd	r31, Y+1	; 0x01
    1fbc:	85 ef       	ldi	r24, 0xF5	; 245
    1fbe:	86 83       	std	Z+6, r24	; 0x06
    1fc0:	e8 81       	ld	r30, Y
    1fc2:	f9 81       	ldd	r31, Y+1	; 0x01
    1fc4:	8c ec       	ldi	r24, 0xCC	; 204
    1fc6:	87 83       	std	Z+7, r24	; 0x07
			break;
	}

	/* Enable both RX and TX. */
	USART_Rx_Enable(usartBuffer->usart);
    1fc8:	e8 81       	ld	r30, Y
    1fca:	f9 81       	ldd	r31, Y+1	; 0x01
    1fcc:	84 81       	ldd	r24, Z+4	; 0x04
    1fce:	80 61       	ori	r24, 0x10	; 16
    1fd0:	84 83       	std	Z+4, r24	; 0x04
	USART_Tx_Enable(usartBuffer->usart);
    1fd2:	e8 81       	ld	r30, Y
    1fd4:	f9 81       	ldd	r31, Y+1	; 0x01
    1fd6:	84 81       	ldd	r24, Z+4	; 0x04
    1fd8:	88 60       	ori	r24, 0x08	; 8
    1fda:	84 83       	std	Z+4, r24	; 0x04
	//return the buffer struct, to be used for reading and writing
	return usartBuffer;
}
    1fdc:	ce 01       	movw	r24, r28
    1fde:	df 91       	pop	r29
    1fe0:	cf 91       	pop	r28
    1fe2:	1f 91       	pop	r17
    1fe4:	0f 91       	pop	r16
    1fe6:	ff 90       	pop	r15
    1fe8:	ef 90       	pop	r14
    1fea:	df 90       	pop	r13
    1fec:	cf 90       	pop	r12
    1fee:	08 95       	ret

00001ff0 <usartBufferPutByte>:
 *  \param usart_struct The USART_buffer_struct_t struct instance.
 *  \param data       The data to send.
 *  \param xTicksToWait       Amount of RTOS ticks (1 ms default) to wait if there is space in queue.
 */
void usartBufferPutByte(UsartBuffer * usart_buffer_t, uint8_t data, int ticksToWait )
{
    1ff0:	0f 93       	push	r16
    1ff2:	1f 93       	push	r17
    1ff4:	cf 93       	push	r28
    1ff6:	df 93       	push	r29
    1ff8:	1f 92       	push	r1
    1ffa:	cd b7       	in	r28, 0x3d	; 61
    1ffc:	de b7       	in	r29, 0x3e	; 62
    1ffe:	8c 01       	movw	r16, r24
    2000:	69 83       	std	Y+1, r22	; 0x01
	uint8_t tempCTRLA;
	/* If we successfully loaded byte to queue */
	if (xQueueSendToBack(usart_buffer_t->xQueueTX,&data,ticksToWait))
    2002:	20 e0       	ldi	r18, 0x00	; 0
    2004:	be 01       	movw	r22, r28
    2006:	6f 5f       	subi	r22, 0xFF	; 255
    2008:	7f 4f       	sbci	r23, 0xFF	; 255
    200a:	dc 01       	movw	r26, r24
    200c:	15 96       	adiw	r26, 0x05	; 5
    200e:	8d 91       	ld	r24, X+
    2010:	9c 91       	ld	r25, X
    2012:	16 97       	sbiw	r26, 0x06	; 6
    2014:	0e 94 3a 04 	call	0x874	; 0x874 <xQueueGenericSend>
    2018:	88 23       	and	r24, r24
    201a:	51 f0       	breq	.+20     	; 0x2030 <usartBufferPutByte+0x40>
	{
		/* Enable DRE interrupt. */
		tempCTRLA = usart_buffer_t->usart->CTRLA;
    201c:	d8 01       	movw	r26, r16
    201e:	ed 91       	ld	r30, X+
    2020:	fc 91       	ld	r31, X
    2022:	11 97       	sbiw	r26, 0x01	; 1
    2024:	83 81       	ldd	r24, Z+3	; 0x03
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | usart_buffer_t->dreIntLevel;
    2026:	8c 7f       	andi	r24, 0xFC	; 252
    2028:	12 96       	adiw	r26, 0x02	; 2
    202a:	9c 91       	ld	r25, X
    202c:	89 2b       	or	r24, r25
		usart_buffer_t->usart->CTRLA = tempCTRLA;
    202e:	83 83       	std	Z+3, r24	; 0x03
	}
}
    2030:	0f 90       	pop	r0
    2032:	df 91       	pop	r29
    2034:	cf 91       	pop	r28
    2036:	1f 91       	pop	r17
    2038:	0f 91       	pop	r16
    203a:	08 95       	ret

0000203c <usartBufferGetByte>:
 *	\param xTicksToWait       Amount of RTOS ticks (1 ms default) to wait if there is data in queue.
 *  \return					  Success.
 */
inline int8_t usartBufferGetByte(UsartBuffer * usartBuffer, char * receivedChar, int ticksToWait )
{
	return xQueueReceive(usartBuffer->xQueueRX, receivedChar, ticksToWait);
    203c:	20 e0       	ldi	r18, 0x00	; 0
    203e:	fc 01       	movw	r30, r24
    2040:	83 81       	ldd	r24, Z+3	; 0x03
    2042:	94 81       	ldd	r25, Z+4	; 0x04
    2044:	0c 94 ec 04 	jmp	0x9d8	; 0x9d8 <xQueueGenericReceive>
}
    2048:	08 95       	ret

0000204a <usartBufferPutString>:
 *  \param usart_struct The USART_struct_t struct instance.
 *  \param string       The string to send.
 *  \param xTicksToWait       Amount of RTOS ticks (1 ms default) to wait if there is space in queue.
 */
inline void usartBufferPutString(UsartBuffer * usartBuffer, const char *string, int ticksToWait )
{
    204a:	ef 92       	push	r14
    204c:	ff 92       	push	r15
    204e:	0f 93       	push	r16
    2050:	1f 93       	push	r17
    2052:	cf 93       	push	r28
    2054:	df 93       	push	r29
    2056:	8c 01       	movw	r16, r24
    2058:	eb 01       	movw	r28, r22
    205a:	7a 01       	movw	r14, r20
	//send the whole string. Note that if buffer is full, USART_TXBuffer_PutByte will do nothing
	while (*string) usartBufferPutByte(usartBuffer,*string++, ticksToWait );
    205c:	68 81       	ld	r22, Y
    205e:	66 23       	and	r22, r22
    2060:	39 f0       	breq	.+14     	; 0x2070 <usartBufferPutString+0x26>
    2062:	21 96       	adiw	r28, 0x01	; 1
    2064:	a7 01       	movw	r20, r14
    2066:	c8 01       	movw	r24, r16
    2068:	c3 df       	rcall	.-122    	; 0x1ff0 <usartBufferPutByte>
    206a:	69 91       	ld	r22, Y+
    206c:	61 11       	cpse	r22, r1
    206e:	fa cf       	rjmp	.-12     	; 0x2064 <usartBufferPutString+0x1a>
}
    2070:	df 91       	pop	r29
    2072:	cf 91       	pop	r28
    2074:	1f 91       	pop	r17
    2076:	0f 91       	pop	r16
    2078:	ff 90       	pop	r15
    207a:	ef 90       	pop	r14
    207c:	08 95       	ret

0000207e <memcpy>:
    207e:	fb 01       	movw	r30, r22
    2080:	dc 01       	movw	r26, r24
    2082:	02 c0       	rjmp	.+4      	; 0x2088 <memcpy+0xa>
    2084:	01 90       	ld	r0, Z+
    2086:	0d 92       	st	X+, r0
    2088:	41 50       	subi	r20, 0x01	; 1
    208a:	50 40       	sbci	r21, 0x00	; 0
    208c:	d8 f7       	brcc	.-10     	; 0x2084 <memcpy+0x6>
    208e:	08 95       	ret

00002090 <memset>:
    2090:	dc 01       	movw	r26, r24
    2092:	01 c0       	rjmp	.+2      	; 0x2096 <memset+0x6>
    2094:	6d 93       	st	X+, r22
    2096:	41 50       	subi	r20, 0x01	; 1
    2098:	50 40       	sbci	r21, 0x00	; 0
    209a:	e0 f7       	brcc	.-8      	; 0x2094 <memset+0x4>
    209c:	08 95       	ret

0000209e <strncpy>:
    209e:	fb 01       	movw	r30, r22
    20a0:	dc 01       	movw	r26, r24
    20a2:	41 50       	subi	r20, 0x01	; 1
    20a4:	50 40       	sbci	r21, 0x00	; 0
    20a6:	48 f0       	brcs	.+18     	; 0x20ba <strncpy+0x1c>
    20a8:	01 90       	ld	r0, Z+
    20aa:	0d 92       	st	X+, r0
    20ac:	00 20       	and	r0, r0
    20ae:	c9 f7       	brne	.-14     	; 0x20a2 <strncpy+0x4>
    20b0:	01 c0       	rjmp	.+2      	; 0x20b4 <strncpy+0x16>
    20b2:	1d 92       	st	X+, r1
    20b4:	41 50       	subi	r20, 0x01	; 1
    20b6:	50 40       	sbci	r21, 0x00	; 0
    20b8:	e0 f7       	brcc	.-8      	; 0x20b2 <strncpy+0x14>
    20ba:	08 95       	ret

000020bc <_exit>:
    20bc:	f8 94       	cli

000020be <__stop_program>:
    20be:	ff cf       	rjmp	.-2      	; 0x20be <__stop_program>
